//-------------------------------------------------------------------------------------------------
// <copyright file="Output.cs" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
//
//    The use and distribution terms for this software are covered by the
//    Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
//    which can be found in the file CPL.TXT at the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by
//    the terms of this license.
//
//    You must not remove this notice, or any other, from this software.
// </copyright>
//
// <summary>
// Output of linker before binding.
// </summary>
//-------------------------------------------------------------------------------------------------

namespace Microsoft.Tools.WindowsInstallerXml
{
	using System;
	using System.Diagnostics;
	using System.Globalization;
	using System.Xml;

	/// <summary>
	/// Various types of output.
	/// </summary>
	public enum OutputType
	{
		/// <summary>Unknown output type.</summary>
		Unknown,
		/// <summary>Module output type.</summary>
		Module,
		/// <summary>Product output type.</summary>
		Product,
		/// <summary>Patch Creation output type.</summary>
		PatchCreation
	}

	/// <summary>
	/// Output is generated by the linker.
	/// </summary>
	public class Output
	{
		private string path;

		private Section entrySection;
		private OutputType type;
		private int codepage;
		private bool compressed;
		private bool longFileNames;
		private string moduleGuid;

		private SectionCollection sections;
		private ConnectToFeatureCollection componentsToFeatures;
		private ConnectToFeatureCollection modulesToFeatures;
		private ConnectToFeatureCollection featuresToFeatures;
		private IgnoreModularizationCollection ignoreModularizations;

		private OutputTableCollection outputTables;
		private ImportStreamCollection importStreams;
		private RowCollection modules;
		private FileMediaInformationCollection fileMediaInfoCollection;
		private MediaRowCollection mediaRows;
		private bool suppressAdminSequence;
		private bool suppressAdvertiseSequence;
		private bool suppressUISequence;

		/// <summary>
		/// Creates a new empty output object.
		/// </summary>
		internal Output()
		{
			this.componentsToFeatures = new ConnectToFeatureCollection();
			this.modulesToFeatures = new ConnectToFeatureCollection();
			this.featuresToFeatures = new ConnectToFeatureCollection();
			this.ignoreModularizations = new IgnoreModularizationCollection();

			this.outputTables = new OutputTableCollection();
			this.importStreams = new ImportStreamCollection();
			this.modules = new RowCollection();
			this.fileMediaInfoCollection = new FileMediaInformationCollection();
			this.mediaRows = new MediaRowCollection();
			this.suppressAdminSequence = false;
			this.suppressAdvertiseSequence = false;
			this.suppressUISequence = false;
		}

		/// <summary>
		/// Creates a new output object with the specified entry section.
		/// </summary>
		/// <param name="entrySection">Entry section for the output.</param>
		internal Output(Section entrySection) :
			this()
		{
			this.entrySection = entrySection;
			this.sections = new SectionCollection();
			this.codepage = entrySection.Codepage;

			switch (this.entrySection.Type)
			{
				case SectionType.Product:
					this.type = OutputType.Product;
					this.compressed = false;
					break;
				case SectionType.Module:
					this.type = OutputType.Module;
					this.compressed = true;
					break;
				case SectionType.PatchCreation:
					this.type = OutputType.PatchCreation;
					this.compressed = false;
					break;
				default:
					throw new ApplicationException(String.Format("Unexpected entry section type: {0}", this.entrySection.Type));
			}
		}

		/// <summary>
		/// Gets or sets the path to this output on disk.
		/// </summary>
		/// <value>Path to output on disk.</value>
		/// <remarks>The Path may be null if this output was never persisted to disk.</remarks>
		public string Path
		{
			get { return this.path; }
			set { this.path = value; }
		}

		/// <summary>
		/// Gets the entry section for the output
		/// </summary>
		/// <value>Entry section for the output.</value>
		public Section EntrySection
		{
			get { return this.entrySection; }
		}

		/// <summary>
		/// Gets the type of the output.
		/// </summary>
		/// <value>Type of the output.</value>
		public OutputType Type
		{
			get { return this.type; }
		}

		/// <summary>
		/// Gets or sets the codepage for this output.
		/// </summary>
		/// <value>Codepage of the output.</value>
		public int Codepage
		{
			get { return this.codepage; }
			set { this.codepage = value; }
		}

		/// <summary>
		/// Gets or sets the compressed flag for this output.
		/// </summary>
		/// <value>Compressed flag of the output.</value>
		public bool Compressed
		{
			get { return this.compressed; }
			set { this.compressed = value; }
		}

		/// <summary>
		/// Gets or sets the long file names flag for this output.
		/// </summary>
		/// <value>Long file names flag of the output.</value>
		public bool LongFileNames
		{
			get { return this.longFileNames; }
			set { this.longFileNames = value; }
		}

		/// <summary>
		/// Gets or sets the guid used by modularization.
		/// </summary>
		/// <value>Modularization guid.</value>
		public string ModularizationGuid
		{
			get { return this.moduleGuid; }
			set { this.moduleGuid = value; }
		}

		/// <summary>
		/// Gets the sections contained in the output.
		/// </summary>
		/// <value>Sections in the output.</value>
		public SectionCollection Sections
		{
			get { return this.sections; }
		}

		/// <summary>
		/// Gets the Modules to Features map.
		/// </summary>
		/// <value>Modules to Features map.</value>
		public ConnectToFeatureCollection ModulesToFeatures
		{
			get { return this.modulesToFeatures; }
		}

		/// <summary>
		/// Gets the collection of values to ignore modulatization
		/// </summary>
		/// <value>Collection of values to ignore modularization.</value>
		public IgnoreModularizationCollection IgnoreModularizations
		{
			get { return this.ignoreModularizations; }
		}

		/// <summary>
		/// Gets the tables contained in this ouput.
		/// </summary>
		/// <value>Collection of tables.</value>
		public OutputTableCollection OutputTables
		{
			get { return this.outputTables; }
		}

		/// <summary>
		/// Gets the collection of streams to import into the final output.
		/// </summary>
		/// <value>Streams to import.</value>
		public ImportStreamCollection ImportStreams
		{
			get { return this.importStreams; }
		}

		/// <summary>
		/// Gets the collection of Merge records.
		/// </summary>
		/// <value>Merge rows to merge.</value>
		public RowCollection Modules
		{
			get { return this.modules; }
		}

		/// <summary>
		/// Gets the information about all the files and their media layout.
		/// </summary>
		/// <value>Collection of file/media information.</value>
		public FileMediaInformationCollection FileMediaInformationCollection
		{
			get { return this.fileMediaInfoCollection; }
		}

		/// <summary>
		/// Gets the collection of Media records.
		/// </summary>
		/// <value>Media records for final output.</value>
		public MediaRowCollection MediaRows
		{
			get { return this.mediaRows; }
		}

		/// <summary>
		/// Gets or sets the option to suppress admin sequence actions.
		/// </summary>
		/// <value>The option to suppress admin sequence actions.</value>
		public bool SuppressAdminSequence
		{
			set { this.suppressAdminSequence = value; }
			get { return this.suppressAdminSequence; }
		}

		/// <summary>
		/// Gets or sets the option to suppress advertise sequence actions.
		/// </summary>
		/// <value>The option to suppress admin advertise actions.</value>
		public bool SuppressAdvertiseSequence
		{
			set { this.suppressAdvertiseSequence = value; }
			get { return this.suppressAdvertiseSequence; }
		}

		/// <summary>
		/// Gets or sets the option to suppress UI sequence actions.
		/// </summary>
		/// <value>The option to suppress UI sequence actions.</value>
		public bool SuppressUISequence
		{
			set { this.suppressUISequence = value; }
			get { return this.suppressUISequence; }
		}

		/// <summary>
		/// Loads an output from a path on disk.
		/// </summary>
		/// <param name="path">Path to output file saved on disk.</param>
		/// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
		/// <remarks>This method will set the Path property to the appropriate values on successful load.</remarks>
		/// <returns>Output object.</returns>
		public static Output Load(string path, bool suppressVersionCheck)
		{
			XmlTextReader reader = null;

			try
			{
				reader = new XmlTextReader(path);

				reader.MoveToContent();

				if ("wixOutput" != reader.LocalName)
				{
					throw new WixParseException(String.Format("The xml document element was expected to be tableDefinitions, but was actually {0}.", reader.Name));
				}

				Output output = Parse(reader, suppressVersionCheck, path);

				return output;
			}
			catch (XmlException xe)
			{
				throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), xe.Message);
			}
			catch (WixException we)
			{
				throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), we.Message);
			}
			catch (FormatException fe)
			{
				throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), fe.Message);
			}
			catch (OverflowException oe)
			{
				throw new WixInvalidOutputException(SourceLineNumberCollection.FromFileName(path), oe.Message);
			}
			finally
			{
				if (null != reader)
				{
					reader.Close();
				}
			}
		}

		/// <summary>
		/// Saves an output to a path on disk.
		/// </summary>
		/// <param name="path">Path to save output file to disk.</param>
		/// <remarks>This method will set the Path property to the passed in value before saving.</remarks>
		public void Save(string path)
		{
			this.path = path;
			this.Save();
		}

		/// <summary>
		/// Saves an output to a path on disk.
		/// </summary>
		/// <remarks>This method will save the output to the file specified in the Path property.</remarks>
		public void Save()
		{
			XmlWriter writer = null;
			try
			{
				writer = new XmlTextWriter(this.path, System.Text.Encoding.UTF8);
				this.Persist(writer);
			}
			finally
			{
				if (null != writer)
				{
					writer.Close();
				}
			}
		}

		/// <summary>
		/// Persists an output in an XML format.
		/// </summary>
		/// <param name="writer">XmlWriter where the Output should persist itself as XML.</param>
		internal void Persist(XmlWriter writer)
		{
			writer.WriteStartDocument();
			writer.WriteStartElement("wixOutput");
			writer.WriteAttributeString("xmlns", "http://schemas.microsoft.com/wix/2003/04/output");
			writer.WriteAttributeString("output", this.path);
			writer.WriteAttributeString("type", this.type.ToString());
			writer.WriteAttributeString("entrySectionId", this.entrySection.Id);
			if (0 != this.codepage)
			{
				writer.WriteAttributeString("codepage", this.codepage.ToString());
			}
			if (this.compressed)
			{
				writer.WriteAttributeString("compressed", "yes");
			}
			if (this.longFileNames)
			{
				writer.WriteAttributeString("longFileNames", "yes");
			}
			if (null != this.moduleGuid && 0 != this.moduleGuid.Length)
			{
				writer.WriteAttributeString("moduleGuid", this.moduleGuid);
			}
			if (this.suppressAdminSequence)
			{
				writer.WriteAttributeString("suppressAdminSequence", "yes");
			}
			if (this.suppressAdvertiseSequence)
			{
				writer.WriteAttributeString("suppressAdvertiseSequence", "yes");
			}
			if (this.suppressUISequence)
			{
				writer.WriteAttributeString("suppressUISequence", "yes");
			}

			Version currentVersion = Common.OutputFormatVersion;
			writer.WriteAttributeString("version", currentVersion.ToString());

			foreach (OutputTable outputTable in this.outputTables)
			{
				outputTable.Persist(writer);
			}

			foreach (ImportStream importStream in this.importStreams)
			{
				importStream.Persist(writer);
			}

			if (0 < this.componentsToFeatures.Count)
			{
				writer.WriteStartElement("componentsToFeatures");
				foreach (ConnectToFeature ctf in this.componentsToFeatures)
				{
					ctf.Persist(writer);
				}
				writer.WriteEndElement();
			}

			if (0 < this.modulesToFeatures.Count)
			{
				writer.WriteStartElement("modulesToFeatures");
				foreach (ConnectToFeature ctf in this.modulesToFeatures)
				{
					ctf.Persist(writer);
				}
				writer.WriteEndElement();
			}

			if (0 < this.featuresToFeatures.Count)
			{
				writer.WriteStartElement("featuresToFeatures");
				foreach (ConnectToFeature ctf in this.featuresToFeatures)
				{
					ctf.Persist(writer);
				}
				writer.WriteEndElement();
			}

			if (0 < this.modules.Count)
			{
				writer.WriteStartElement("merge");
				this.outputTables["Merge"].TableDefinition.Persist(writer);
				foreach (MergeRow row in this.modules)
				{
					row.Persist(writer);
				}
				writer.WriteEndElement();
			}

			foreach (FileMediaInformation fmi in this.fileMediaInfoCollection)
			{
				fmi.Persist(writer);
			}

			if (0 < this.mediaRows.Count)
			{
				writer.WriteStartElement("media");
				this.outputTables["Media"].TableDefinition.Persist(writer);
				foreach (MediaRow row in this.mediaRows)
				{
					row.Persist(writer);
				}
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
			writer.WriteEndDocument();
		}

		/// <summary>
		/// Processes an XmlReader and builds up the output object.
		/// </summary>
		/// <param name="reader">Reader to get data from.</param>
		/// <param name="suppressVersionCheck">Suppresses wix.dll version mismatch check.</param>
		/// <param name="path">The path to display in an error message.</param>
		/// <returns>The Output represented by the Xml.</returns>
		private static Output Parse(XmlReader reader, bool suppressVersionCheck, string path)
		{
			Debug.Assert("wixOutput" == reader.LocalName);

			Output output = new Output();
			output.path = path;
			string entrySectionId = null;
			SectionType sectionType = SectionType.Unknown;
			Version objVersion = null;
			bool empty = reader.IsEmptyElement;

			while (reader.MoveToNextAttribute())
			{
				switch (reader.LocalName)
				{
					case "type":
						switch (reader.Value)
						{
							case "Module":
								output.type = OutputType.Module;
								sectionType = SectionType.Module;
								break;
							case "Product":
								output.type = OutputType.Product;
								sectionType = SectionType.Product;
								break;
							case "PatchCreation":
								output.type = OutputType.PatchCreation;
								sectionType = SectionType.PatchCreation;
								break;
							default:
								throw new WixParseException(String.Format("The wixOutput/@type attribute contains an unexpected value '{0}'.", reader.Value));
						}
						break;
					case "codepage":
						output.codepage = Convert.ToInt32(reader.Value, CultureInfo.InvariantCulture.NumberFormat);
						break;
					case "compressed":
						output.compressed = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
						break;
					case "longFileNames":
						output.longFileNames = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
						break;
					case "entrySectionId":
						entrySectionId = reader.Value;
						break;
					case "moduleGuid":
						output.moduleGuid = reader.Value;
						break;
					case "output":
						output.path = reader.Value;
						break;
					case "suppressAdminSequence":
						output.suppressAdminSequence = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
						break;
					case "suppressAdvertiseSequence":
						output.suppressAdvertiseSequence = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
						break;
					case "suppressUISequence":
						output.suppressUISequence = Common.IsYes(reader.Value, null, "wixOutput", reader.Name, null);
						break;
					case "version":
						objVersion = new Version(reader.Value);
						break;
					case "xmlns":
						break;
					default:
						throw new WixParseException(String.Format("The wixOutput element contains an unexpected attribute {0}.", reader.Name));
				}
			}
			if (null == entrySectionId)
			{
				throw new WixParseException("The wixOutput/@entrySectionId attribute was not found; it is required.");
			}
			if (null != objVersion && !suppressVersionCheck)
			{
				Version currentVersion = Common.OutputFormatVersion;
				if (0 != currentVersion.CompareTo(objVersion))
				{
					throw new WixVersionMismatchException(currentVersion, objVersion, "Output", output.Path);
				}
			}

			// create a section for all the rows to belong to
			Intermediate intermediate = new Intermediate();
			output.entrySection = new Section(intermediate, entrySectionId, sectionType, output.codepage);

			// loop through the rest of the xml building up the Output object
			if (!empty)
			{
				bool done = false;

				// loop through all the fields in a row
				while (!done && reader.Read())
				{
					switch (reader.NodeType)
					{
						case XmlNodeType.Element:
							switch (reader.LocalName)
							{
								case "outputTable":
									output.outputTables.Add(OutputTable.Parse(reader, output.entrySection));
									break;
								case "importStream":
									output.importStreams.Add(ImportStream.Parse(reader));
									break;
								case "componentsToFeatures":
								case "featuresToFeatures":
								case "modulesToFeatures":
									ParseConnectToFeatures(output, reader);
									break;
								case "merge":
									ParseMerge(output, reader);
									break;
								case "fileMediaInformation":
									output.fileMediaInfoCollection.Add(FileMediaInformation.Parse(reader));
									break;
								case "media":
									ParseMedia(output, reader);
									break;
								default:
									throw new WixParseException(String.Format("The wixOutput element contains an unexpected child element {0}.", reader.Name));
							}
							break;
						case XmlNodeType.EndElement:
							done = true;
							break;
					}
				}

				if (!done)
				{
					throw new WixParseException("Missing end element while processing the wixOutput element.");
				}
			}

			return output;
		}

		/// <summary>
		/// Reads all of the component to features entries out of the xml.
		/// </summary>
		/// <param name="output">Output object to add the connection.</param>
		/// <param name="reader">Xml reader.</param>
		private static void ParseConnectToFeatures(Output output, XmlReader reader)
		{
			Debug.Assert("componentsToFeatures" == reader.LocalName || "featuresToFeatures" == reader.LocalName || "modulesToFeatures" == reader.LocalName);

			string elementLocalName = reader.LocalName;
			bool empty = reader.IsEmptyElement;

			if (!empty)
			{
				bool done = false;

				// loop through all the fields in a row
				while (!done && reader.Read())
				{
					switch (reader.NodeType)
					{
						case XmlNodeType.Element:
							switch (reader.LocalName)
							{
								case "connectToFeature":
									switch (elementLocalName)
									{
										case "componentsToFeatures":
											output.componentsToFeatures.Add(ConnectToFeature.Parse(reader));
											break;
										case "featuresToFeatures":
											output.featuresToFeatures.Add(ConnectToFeature.Parse(reader));
											break;
										case "modulesToFeatures":
											output.modulesToFeatures.Add(ConnectToFeature.Parse(reader));
											break;
									}
									break;
								default:
									throw new WixParseException(String.Format("The {0} element contains an unexpected child element {1}.", elementLocalName, reader.Name));
							}
							break;
						case XmlNodeType.EndElement:
							done = true;
							break;
					}
				}

				if (!done)
				{
					throw new WixParseException(String.Format("Missing end element while processing the {0} element.", elementLocalName));
				}
			}
		}

		/// <summary>
		/// Reads a media row entry out of the xml.
		/// </summary>
		/// <param name="output">Output object to add the row.</param>
		/// <param name="reader">Xml reader.</param>
		private static void ParseMerge(Output output, XmlReader reader)
		{
			Debug.Assert("merge" == reader.LocalName);

			TableDefinition mergeTableDefinition = null;
			bool empty = reader.IsEmptyElement;

			if (!empty)
			{
				bool done = false;

				while (!done && reader.Read())
				{
					switch (reader.NodeType)
					{
						case XmlNodeType.Element:
							switch (reader.LocalName)
							{
								case "tableDefinition":
									mergeTableDefinition = TableDefinition.Parse(reader);
									break;
								case "tuple":
									if (null == mergeTableDefinition)
									{
										throw new WixParseException("The merge element is missing a tableDefinition child element.");
									}
									output.modules.Add((MergeRow)Row.Parse(reader, output.entrySection, mergeTableDefinition));
									break;
								default:
									throw new WixParseException(String.Format("The merge element contains an unexpected child element {0}.", reader.Name));
							}
							break;
						case XmlNodeType.EndElement:
							done = true;
							break;
					}
				}

				if (!done)
				{
					throw new WixParseException("Missing end element while processing the merge element.");
				}
			}
		}

		/// <summary>
		/// Reads a media row entry out of the xml.
		/// </summary>
		/// <param name="output">Output object to add the row.</param>
		/// <param name="reader">Reader to get data from.</param>
		private static void ParseMedia(Output output, XmlReader reader)
		{
			Debug.Assert("media" == reader.LocalName);

			TableDefinition mediaTableDefinition = null;
			bool empty = reader.IsEmptyElement;

			if (!empty)
			{
				bool done = false;

				// loop through all the fields in a row
				while (!done && reader.Read())
				{
					switch (reader.NodeType)
					{
						case XmlNodeType.Element:
						switch (reader.LocalName)
						{
							case "tableDefinition":
								mediaTableDefinition = TableDefinition.Parse(reader);
								break;
							case "tuple":
								if (null == mediaTableDefinition)
								{
									throw new WixParseException("The merge element is missing a tableDefinition child element.");
								}
								output.mediaRows.Add((MediaRow)Row.Parse(reader, output.entrySection, mediaTableDefinition));
								break;
							default:
								throw new WixParseException(String.Format("The media element contains an unexpected child element {0}.", reader.Name));
						}
							break;
						case XmlNodeType.EndElement:
							done = true;
							break;
					}
				}

				if (!done)
				{
					throw new WixParseException("Missing end element while processing the media element.");
				}
			}
		}
	}
}
