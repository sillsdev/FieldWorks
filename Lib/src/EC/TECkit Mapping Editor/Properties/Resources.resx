<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
	Microsoft ResX Schema

	Version 2.0

	The primary goals of this format is to allow a simple XML format
	that is mostly human readable. The generation and parsing of the
	various data types are done through the TypeConverter classes
	associated with the data types.

	Example:

	... ado.net/XML headers & schema ...
	<resheader name="resmimetype">text/microsoft-resx</resheader>
	<resheader name="version">2.0</resheader>
	<resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
	<resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
	<data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
	<data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
	<data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
		<value>[base64 mime encoded serialized .NET Framework object]</value>
	</data>
	<data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
		<value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
		<comment>This is a comment</comment>
	</data>

	There are any number of "resheader" rows that contain simple
	name/value pairs.

	Each data row contains a name, and value. The row also contains a
	type or mimetype. Type corresponds to a .NET class that support
	text/value conversion through the TypeConverter architecture.
	Classes that don't support this are serialized and stored with the
	mimetype set.

	The mimetype is used for serialized objects, and tells the
	ResXResourceReader how to depersist the object. This is currently not
	extensible. For a given mimetype the value must be set accordingly:

	Note - application/x-microsoft.net.object.binary.base64 is the format
	that the ResXResourceWriter will generate, however the reader can
	read any of the formats listed below.

	mimetype: application/x-microsoft.net.object.binary.base64
	value   : The object must be serialized with
			: System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
			: and then encoded with base64 encoding.

	mimetype: application/x-microsoft.net.object.soap.base64
	value   : The object must be serialized with
			: System.Runtime.Serialization.Formatters.Soap.SoapFormatter
			: and then encoded with base64 encoding.

	mimetype: application/x-microsoft.net.object.bytearray.base64
	value   : The object must be serialized into a byte array
			: using a System.ComponentModel.TypeConverter
			: and then encoded with base64 encoding.
	-->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
	<xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
	<xsd:element name="root" msdata:IsDataSet="true">
	  <xsd:complexType>
		<xsd:choice maxOccurs="unbounded">
		  <xsd:element name="metadata">
			<xsd:complexType>
			  <xsd:sequence>
				<xsd:element name="value" type="xsd:string" minOccurs="0" />
			  </xsd:sequence>
			  <xsd:attribute name="name" use="required" type="xsd:string" />
			  <xsd:attribute name="type" type="xsd:string" />
			  <xsd:attribute name="mimetype" type="xsd:string" />
			  <xsd:attribute ref="xml:space" />
			</xsd:complexType>
		  </xsd:element>
		  <xsd:element name="assembly">
			<xsd:complexType>
			  <xsd:attribute name="alias" type="xsd:string" />
			  <xsd:attribute name="name" type="xsd:string" />
			</xsd:complexType>
		  </xsd:element>
		  <xsd:element name="data">
			<xsd:complexType>
			  <xsd:sequence>
				<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
				<xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
			  </xsd:sequence>
			  <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
			  <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
			  <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
			  <xsd:attribute ref="xml:space" />
			</xsd:complexType>
		  </xsd:element>
		  <xsd:element name="resheader">
			<xsd:complexType>
			  <xsd:sequence>
				<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
			  </xsd:sequence>
			  <xsd:attribute name="name" type="xsd:string" use="required" />
			</xsd:complexType>
		  </xsd:element>
		</xsd:choice>
	  </xsd:complexType>
	</xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
	<value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
	<value>2.0</value>
  </resheader>
  <resheader name="reader">
	<value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
	<value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="DragSrc" type="System.Resources.ResXFileRef, System.Windows.Forms">
	<value>..\DragSrc.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="CompilerResults" xml:space="preserve">
	<value>This pane displays compiler errors.

The program is configured to automatically compile the map whenever changes are
made so that you can see where problems in syntax occur more easily. To turn off
automatic compiling of the map, press the F5 key (or use the
'File', 'Auto-Compile' command).

If an error is displayed here, you can click on the error message to jump to the
corresponding line in the map where the error occurred.
	</value>
  </data>
  <data name="CPChars" xml:space="preserve">
	<value>Check this box to show the characters in the sample string
enclosed in double-quotes.

For example, if the Sample box contains the letter "A", then the
corresponding cell would show "A".
	</value>
  </data>
  <data name="CPDataGridCharacters" xml:space="preserve">
	<value>
This window displays the characters in the font you've specified for either the
left or right-hand side of the conversion. If this corresponds to a Legacy (non-Unicode)
encoding, then all (upto) 255 characters in the font will be displayed. If it corresponds
to a Unicode encoding, then only a range of 128 characters will be displayed along with a
combo box with which you can switch the range being displayed.

If you want to change the font, on the main form, click "View", "Configure Left-side font"
or "Configure Right-side font". Once the characters are displayed, you can resize the dialog
if needed to see all the characters at one time.

This grid has the following features:

 o  You can click on a cell with the left mouse button to have the code point of that
	 character inserted in the map at the current insertion point. If the grid corresponds
	 to a Legacy (non-Unicode) encoding, then you can insert either the decimal or
	 hexadecimal value based on which button is selected at the top of the window. If the
	 grid corresponds to a Unicode encoding, then you can select the different buttons to
	 have either the Unicode name, value, or a quoted character inserted.

 o  You can drag a cell and drop it in the map to have its code point value inserted in
	 the map at the drop location.

 o  You can click on a cell with the right mouse button to have an enlarged image of the
	 cell shown just above the grid. If you click on this zoomed view, then it will behave
	 as above. To remove the zoomed view window, click on it with the right-mouse button.

 o  You can click on a cell with the CTRL key pressed to have the character sent to the
	 Sample box. The grid associated with the left-hand side encoding will send characters
	 to the "Left side Sample" text box and the grid associated with the right-hand side
	 encoding will send characters to the "Right-side Sample" text box. Drag-drop also works
	 with the Sample boxes).
	</value>
  </data>
  <data name="CPDataGridCodePoints" xml:space="preserve">
	<value>
This control displays the code point values of the characters entered
into either the Left-side Sample box or the Right-side Sample box
(at the bottom of the main Form). Click in the Sample box which contains
the characters whose code point values you want to see displayed here.

For example, if you are creating a Legacy_to_from_Unicode converter,
then the Left-side Sample box will contain data in a Legacy (non-
Unicode) encoded font. To use these code point values in a TECkit
map, you'll want to show them in either Hex (e.g. 0x41)
or Decimal (e.g. 65) format. For Unicode encodings, you can use
either Unicode Names (e.g. LATIN_CAPITAL_LETTER_A),
Unicode Values (e.g. U+0041), or Quoted Character strings (e.g. "A").

Once these different values are display in this grid, then you can
insert them into your map in one of two ways:

 o  To insert the value at the current insertion point, then
	 click once on the desired cell with the left mouse button.

 o  To insert the value in some other place in the map, then
	 drag the desired cell and drop it at the location in the map
	 where you want the value to be inserted.
	</value>
  </data>
  <data name="CPDecValues" xml:space="preserve">
	<value>Check this box to show the decimal format of the characters
in the sample string.

For example, if the Sample box contains the letter "A", then the
corresponding cell would show "65"
	</value>
  </data>
  <data name="CPHexValues" xml:space="preserve">
	<value>Check this box to show the hex format of the characters in the
sample string.

For example, if the Sample box contains the letter "A", then the
corresponding cell would show "0x41".
	</value>
  </data>
  <data name="CPUnicodeNames" xml:space="preserve">
	<value>Check this box to show the Unicode names for the characters in the
sample string.

For example, if the Sample box contains the letter "A", then the
corresponding cell would show "latin_capital_letter_a".
	</value>
  </data>
  <data name="CPUnicodeValues" xml:space="preserve">
	<value>Check this box to show the Unicode values for the characters
in the sample string.

For example, if the Sample box contains the letter "A", then the
corresponding cell would show "U+0041".
	</value>
  </data>
  <data name="SampleBox" xml:space="preserve">
	<value>
Enter some sample data here to test the map.

You can type characters here (e.g. using a Keyman keyboard) or you can add them from the Code Point Values dialog box by holding down the CTRL key and
clicking on the cells in the character map grid.

The code point values of the characters shown in this text box will be displayed in the grid below, from which they can be inserted into the map by
clicking (or using drag-drop).

When the map is successfully compiled, any code point values in the Left-side text box will be converted using the TECkit map and the result will
be put into the Right-side text box. You can also type characters in the Right-side text box to show their code point values in the grid below,
from which they can be inserted into the map by clicking on them.

Whatever characters are in the Right-side Sample box will also be converted in the reverse direction and inserted into the Roundtrip text box below.
This is useful to see whether your map is fully reversable. If you position your cursor over the label by the Round-trip text box, a tool tip will be
displayed showing the code point values of the characters in all three text boxes to compare with each other.

These text boxes also support converting 3 or 4 digit numbers into the corresponding character. For Legacy (non-Unicode) encodings, type in the decimal
or hex value of a character (e.g. 0x41 or 065 for "A"). For Unicode encodings, type in the 4 digit hex value (e.g. 0065 for "A"). Then hold down the
ALT key and press the 'X' key. This will cause the 3 or 4 digits to be replaced by the corresponding character in the font/encoding of the configured
field.
	</value>
  </data>
  <data name="MainEditor" xml:space="preserve">
	<value>
This pane is for editing the TECkit map.

A new, blank map is automatically loaded with a typical TECkit map header depending
on the type of converter you are creating (which you choose when starting the program
or when you click 'File', 'New' to create a new map). Be sure to edit the map properies
appropriately for the encoding that it applies to. Also, note that the first several
lines of comments at the top of the map file contain information used by the editor
(e.g. conversion type, font names, and window positions) so that it is retained across
editing sessions.

Changes you make to the map are automatically compiled by the program. To turn off
automatic compiling of the map, press the F5 key.

[aside: in fact, what is compiled is a temporary copy of the map (.map) and what
is created is a temporary copy of the compile map (.tec). So be sure to manually
save the map with an explicit name when finished editing it and use the 'File',
'Compile' command to create a compiled version of the map with the same name as
the .map file. You can also use the 'File', 'Add to System Repository' command
to add the TECkit map to the system repository for use by other SILConverters'
client programs, such as Word, Fieldworks, Bulk SFM Converter, etc.]

You can click on the characters in the Character Map Windows to insert the code point
values (or Unicode Names for Unicode encodings) into the map. See the help for the
different controls in that window for details.

When a map compiles successfully, it will be used to convert any data in the
Sample boxes below. You can use those boxes to make sure that the map is working
correctly.
	</value>
  </data>
  <data name="SendToEditorHelpString" xml:space="preserve">
	<value>
These radio buttons can be used to select the format for the code point values
sent to the map Editor window.

If this dialog is displaying a Legacy encoding, then the 'Decimal' and
'Hexadecimal' buttons will be visible. If you click on the cell for the letter
'A', for example, and have the 'Decimal' button selected, then the value '65'
will be sent to the map editor. If you have 'Hexadecimal' selected, then the
value '0x41' (the hex equivalent of '65') will be sent to the map editor.

If this dialog is displaying a Unicode encoding, then the 'Unicode Name'
(e.g. latin_capital_letter_a), 'Unicode Value (e.g. 'U+0041'), or Quoted
Character (e.g. "A") buttons will be visible.
	</value>
  </data>
  <data name="ComboUnicodeRangeHelpString" xml:space="preserve">
	<value>
This drop down list contains all the possible ranges of Unicode characters.
You can change the range of characters displayed in the above grid by selecting
a different range from this list.
	</value>
  </data>
  <data name="UnicodeRangesHelpString" xml:space="preserve">
	<value>
This button is for choosing the characters to display in the table above based on
the Unicode range rather than code point values. If you click this button, then
the box to the right will display Unicode Range names rather than code point values.
The Unicode Range names can be customized by modifying the file UnicodeRanges.xml
located in the same folder as this executable (normally,
"C:\Program Files\SIL\SILConverters").
	</value>
  </data>
</root>