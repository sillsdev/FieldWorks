/*--------------------------------------------------------------------*//*:Ignore this sentence.
Copyright (C) 1999, 2002 SIL International. All rights reserved.

Distributable under the terms of either the Common Public License or the
GNU Lesser General Public License, as specified in the LICENSING.txt file.

File: Views.idh
Responsibility: John Thomson
Last reviewed:

	Includes interfaces used for
		-Views  (views used for displaying data, that is, not database views)
		-Data access (ISilDataAccess)
		-Data caching (IVwCacheDa)
		-Undo/redo functionality (IActionHandler, IUndoAction, ISqlUndoAction)
		-Progress stepping (IAdvInd) which is used for StatusBars
		-Stopping a search operation
	This file will be processed by the MIDL tool to
	produce the type library (ViewsTlb.tlb), C++ headers (ViewsTlb.h) and marshalling code.
-------------------------------------------------------------------------------*//*:End Ignore*/

	//Forward declarations.
//:End Ignore
	interface IVwNotifier;
	interface IVwNotifyChange;
	interface IVwSelection;
	interface IVwRootContainer;
	interface IVwEmbeddedWindow;
	interface IVwStylesheet;
	interface IVwEnv;
	interface IVwViewConstructor;
	interface IVwRootSite;
	interface ISilDataAccess;
	interface IStructuredTextDataAccess;
	interface IVwCacheDa;
	interface IVwRootBox;
	interface IVwPropertyStore;
	interface IVwOverlay;
	interface IVwPrintContext;
	//interface DIVwSelection;
	interface IVwSearchKiller;
	interface IVwSynchronizer;
	interface IVwNotifyObjCharDeletion;
	interface IVwVirtualHandler;
	interface IVwLayoutStream;
	interface IVwLayoutManager;
	interface ILgWritingSystemFactory;

	typedef int HVO; // Hungarian hvo; Handle to viewable object.
	typedef int PropTag; // Hungarian tag
	/*******************************************************************************************
		Interface IVwNotifyChange
		This interface is implemented by objects that want to receive notifications of changes
		to properties of viewable objects (HVOs). Usually these notifications are sent by
		implementors of ISilDataAccess, and the notification is requested by calling
		${ISilDataAccess#AddNotification}. Most commonly, notifications are requested by
		objects within the view subsystem (such as ${VwNotifier}), but others may do so as well.

		@h3{When to implement}
		Most users of the View subsystem will not need to implement this interface, as the
		View subsystem automatically requests most notifications that are required to keep the
		display up to date. However, anyone who wants notifications of property changes may
		do so.

		@h3{When to use}
		Most programmers will not use this interface directly. Implementors of ${ISilDataAccess}
		must do so by contract when requested to send notifications. Usually this will be
		achieved, if you need to implement ISilDataAccess at all, by inheriting from ${VwBaseDa}.

		@h3{How to obtain an instance}
		There is no straightforward way to get an instance of any of the standard
		implementations.

		@h3{Hungarian: vnc}
	*******************************************************************************************/
	DeclareInterface(VwNotifyChange, Unknown, 6C456541-C2B6-11d3-8078-0000C0FB81B5)
	{
		// Informs the recipient that a property of an object has changed. In some cases, may
		// provide useful information about how much of it changed. Note that some objects
		// reporting changes may not have full information about the extent of the change, in
		// which case, they should err on the side of exaggerating it, for example by
		// pretending that all objects were deleted and  a new group inserted.
		// @param hvo The object that changed
		// @param tag The property that changed
		// @param ivMin For vectors, the starting index where the change occurred.
		// For MultiStrings, the writing system where the change occurred.
		// @param cvIns For vectors, the number of items inserted. For atomic objects,
		//	1 if an item was added. Otherwise (including basic properties), 0.
		// @param cvDel For vectors, the number of items deleted. For atomic objects,
		//	1 if an item was deleted. Otherwise (including basic properties), 0.
		HRESULT PropChanged(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ivMin,
			[in] int cvIns,
			[in] int cvDel);
	};

	/*******************************************************************************************
		Interface ICheckWord
		This interface is implemented by a Views Client which wishes to have the Views code
		perform spell-checking. It is passed a word and indicates whether it is correct.

		@h3{When to implement}
		Implement this to enable spell-checking.

		@h3{When to use}
		You will not use this directly.

		@h3{How to obtain an instance}
		You must provide one

		@h3{Hungarian: cw}
	*******************************************************************************************/
	DeclareInterface(CheckWord, Unknown, 69F4D944-C786-47EC-94F7-15193EED6758)
	{
		HRESULT Check(
			[in] LPCOLESTR pszWord,
			[out, retval] ComBool * pfCorrect);
	}

	/*******************************************************************************************
		Interface IGetSpellChecker
		This interface is implemented by a Views Client which wishes to have the Views code
		perform spell-checking. It is passed a dictionary identifier and returns an ICheckWord
		if spell-checking should be performed for that identifier.

		@h3{When to implement}
		Implement this to enable spell-checking. Pass an instance to VwRootbox::SetSpellingRepository().

		@h3{When to use}
		You will not use this directly.

		@h3{How to obtain an instance}
		You must provide one.

		@h3{Hungarian: gsp}
	*******************************************************************************************/
	DeclareInterface(GetSpellChecker, Unknown, F0A60670-D280-45EA-A5C5-F0B84C027EFC)
	{
		HRESULT GetChecker(
			[in] LPCOLESTR pszDictId,
			[out, retval] ICheckWord ** pcw);
	}

	// A set of special character codes that are conveniently declared here to be shared by
	// the code that implements them in Views and the code that transmits them in AfVwWnd.
	// @h3{Hungarian sc}
	typedef [v1_enum] enum VwSpecialChars
	{
		kscBackspace = 8,
		kscDelForward = 0x7f
	} VwSpecialChars;

	// Types returned by the IVwSelection::SelType property.
	typedef [v1_enum] enum VwSelType
	{
		kstText = 1,
		kstPicture = 2,
	} VwSelType;

	// Strategies that can be requested by callers of ${ISilDataAccess#PropChanged} for
	// broadcasting changes. The client can request a simple broadcast to everyone, request
	// that the notification be sent first to the requester (this can help make the active
	// window more responsive), or to everyone except the requester (this is appropriate when
	// the requester has already updated its own window).
	// @h3{Hungarian pct}
	typedef [v1_enum] enum PropChangeType
	{
		kpctNotifyMeThenAll,
		kpctNotifyAll,
		kpctNotifyAllButMe,
	} PropChangeType;

	// Types of selection that are a problem to delete.
	// @h3{Hungarian dpt}
	typedef [v1_enum] enum VwDelProbType
	{
		// Not a problem! (This value is currently never passed to OnProblemDeletion,
		// but used internally by the Views code.)
		kdptNone,
		// The selection is range which is not entirely contained in one editable string property.
		// (Special case: a selection entirely within a single StText can be handled
		// by the Views code without help, and is not considered a problem.)
		// Note: it is possible that a further problem is that all or part of the selected
		// text is read-only. This case is not currently distinguished when the user attempts
		// to delete a complex range. Note that the selection may be entirely within a single
		// read-only property.
		// Default behavior: shrink selection to selected part of anchor property, delete that.
		kdptComplexRange,

		// The selection is an IP at the start of a paragraph, and the user has pressed
		// backspace. (Special case: a selection at the start of an StTxtPara that is not
		// the first in its StText is not a problem.)
		// (Usually the implementation, if successful, would in some way combine the current
		// and previous paragraph, and return kdprDone.)
		// Default behavior: do nothing.
		kdptBsAtStartPara,
		// The selection is an IP at the end of a paragraph, and the user has pressed DEL.
		// (Special case: not a problem if at the end of an StTxtPara that is not the last.)
		// (Usually the implementation, if successful, would in some way combine the current
		// and following paragraph, and return kdprDone.)
		// Default behavior: do nothing.
		kdptDelAtEndPara,

		// (Note that the remaining options are not currently used and so have not been
		// extensively tested.)

		// We are trying to delete a read-only character by typing backspace at an IP.
		// (Note that the current selection may indicate an editable property, but if
		// so, it starts at the IP.)
		// (The most likely behavior we have thought of is to move the IP back to the
		// nearest editable property and return kdprRetry.)
		// Default behavior: do nothing.
		kdptBsReadOnly,
		// We are trying to delete a read-only character by typing delete at an IP.
		// (Note that the current selection may indicate an editable property, but if
		// so, it ends at the IP.)
		// (The most likely behavior we have thought of is to move the IP forward to the
		// nearest editable property and return kdprRetry.)
		// Default behavior: do nothing.
		kdptDelReadOnly,
		// Editing is being attempted at an IP within a read-only part of the display.
		// (For example, if the display is read-only because it is part of the display of
		// a reference, the implementation might delete the reference, leave the IP
		// position for typing a new item, and return kdprDone.)
		// Default behavior: do nothing.
		kdptReadOnly,
	} VwDelProbType;

	// Response values for OnProblemDeletion.
	// @h3{Hungarian dpr}
	typedef [v1_enum] enum VwDelProbResponse
	{
		// The root site implementation was not able to perform the deletion.
		// This response is particularly approprite following something like
		// a confirmation dialog where the user chooses cancel. It aborts all
		// changes that were requested in the calling OnTyping.
		kdprAbort,
		// The root site implementation was not able to solve the problem.
		// The views code should give up attempting this kind of deletion.
		// (For example, if this is returned when attempting a backspace,
		// the views code will not attempt to process any more pending
		// backspaces, but will attempt to process any pending del forward
		// or characters typed.)
		kdprFail,
		// The root site implementation carried out the requested deletion.
		// The views code will assume that the necessary changes for one backspace
		// or delete have been made. (When this result is returned, the selection
		// should have been changed to an insertion point. If it is still a range,
		// the Views code will try to delete it again.)
		kdprDone,
	} VwDelProbResponse;

	// Response values for OnInsertDiffPara
	// @h3{Hungarian idpr}
	typedef [v1_enum] enum VwInsertDiffParaResponse
	{
		// The root site implementation does not want any special behavior. The view should
		// go ahead and insert the paragraphs in its default manner.
		kidprDefault,
		// The root site implementation decided to abort the whole paste (text insertion).
		// The root site should already have reported the problem if necessary.
		kidprFail,
		// The root site implementation has done the insertion itself and established a new
		// selection following the inserted material. (Note that this may well have
		// messed up the selection that called InsertDiffParas.)
		kidprDone,
	} VwInsertDiffParaResponse;

	/*******************************************************************************************
		This ennumeration is used by DbColSpec to identify the type of a column in a given
		SQL result set.
	*******************************************************************************************/
	typedef [v1_enum] enum DbColType
	{
		koctGuid = 0, // uniqueidentifier's
		koctInt = 1, // Column contains an integer property of the object
		koctString = 2, // Column contains a String property; next column should contain format
		// Col contains a String format; previous cols should contain koctString or one of the
		// multistring sequences indicated below that uses koctFmt
		koctFmt = 3,
		// Used for a list of alternatives of a MultiString or MultiText
		// Columns are koctBaseId, koctMlaAlt, koctFlid, koctEnc, koctFmt (unused by MultiText)
		koctMlaAlt = 4,
		// Used for a single alternative of a MultiString.
		// Columns are koctMlsAlt, koctFmt. The writing system is passed in m_ws of DbColSpec.
		koctMlsAlt = 5,
		// Used for a single alternative of a MultiText
		// Columns are koctMltAlt. The writing system is passed in m_ws of DbColSpec.
		koctMltAlt = 6,
		koctObj = 7, // Column contains ID of an atomic property; may also be base for another.
		koctObjVec = 8, // Column contains info about a vector property; if tag 0, use previous koctFlid
		koctBaseId = 9, // Column is used as a base for another property only
		koctTtp = 10, // Column is binary data representing a TsTextProps
		// ENHANCE JohnT: handle reading writing system of Mls alt as part of data:
		// koctMlsEnc, // Column contains MLS ws; next 2 cols must be MlsAlt and Fmt
		koctUnicode = 11, // Column contains a Unicode string property of the object
		// Note:  I (KenZ) added int64 for accessing 8-byte time. As it turns out, what
		// we get back is a 16 byte structure. I'm leaving this in for now in case it is useful
		// for something else.
		koctInt64 = 12, // Column contains an 8 byte integer property of the object.
		koctTime = 13, // Column contains a DBTIMESTAMP structure.
		koctEnc = 14, // The writing system for an alternative in a MultiText or MultiString.
		koctFlid = 15, // The field id for MultiStrings or MultiTexts or vectors.
		koctTimeStamp = 16, // Time stamp field. (Note: use koctTimeStampIfMissing unless you know no props of this object already loaded)
		koctObjOwn = 17, // Owning atomic, Obj + set owner and flid
		koctObjVecOwn = 18, // Owning seq, ObjVec + set owner and flid.
		koctBinary = 19, // arbitrary binary data, handled by application
		koctTimeStampIfMissing = 20, // Load time stamp if not already cached from loading some other prop
		// ENHANCE JohnT: handle other basic types
		koctLim = 21, // limit is here because ObjVecExtra is NOT yet a valid type.
		koctObjVecExtra = 22,
	} DbColType;  // Hungarian: oct

	/*******************************************************************************************
		This ennumeration is used by IVwOleDbDa.AutoloadPolicy to specify what should be done
		when a property is not found in the cache. Not all options are currently
		implemented for all property types.
	*******************************************************************************************/
	typedef [v1_enum] enum AutoloadPolicies
	{
		// default behavior, laod from database for the one object for which the property
		// value was requested.
		kalpLoadForThisObject = 0,
		// Suppress autoload altogether, properties not preloaded will appear empty.
		kalpNoAutoload = 1,
		// Autoload for all instances of the class of the object for which the property
		// value was requested.
		kalpLoadForAllOfObjectClass = 2,
		// Subtly different in some cases, load for all objects that possess the property
		// value. (For example: if the object is a CmPerson, a subclass of CmPossibility,
		// and we get a cache miss on CmPossibility_Name, AllOfObjectClass loads
		// CmPossibility_Name for all CmPersons, while LoadForAllOfBaseClass will load
		// it for all CmPossibilities. This option is not yet implemented.
		kalpLoadForAllOfBaseClass = 3,
		// This is a variation of kalpLoadForAllOfObjectClass, suitable for a temporary cache
		// used in a read-only (or perhaps single-user) mode where we do not expect any other
		// program to be changing the data. Accordingly, we do not load the timestamp
		// information that allows us to detect conflicts. Also, we don't load values for
		// any empty properties, merely remembering that we've loaded all of a particular
		// property.
		kalpLoadAllOfClassForReadOnly = 4,
		// This is another variation of kalpLoadForAllOfObjectClass, which changes the behavior
		// of virtual handlers to also try to load everything at once, even if the "Compute
		// Every Time" flag is set.  When the policy is changed away from this mode, the virtual
		// handlers are responsible for "forgetting" all the loaded data that they would
		// normally compute every time.  The client is responsible for ensuring that the data
		// in the database does not change while this policy is in effect, at least not in a
		// way that would cause problems due to stale data.  The initial use of this policy is
		// for printing a complex display which loads lots of data.
		kalpLoadAllOfClassIncludingAllVirtuals = 5,

		kalpLim = 6, // One more than max allowed value, do not use.
	} AutoloadPolicies;  // Hungarian: alp

	/*******************************************************************************************
		This ennumeration is used by IVwDataSpec to indicate various types of fields that
		data can be loaded about. AppCore applications also use it to distinguish various ways
		of displaying those fields, so there are more types than the underlying field types
		specified in CmTypes. On the other hand, some distinctions (such as between long and
		short string fields) are not important for this purpose.
	*******************************************************************************************/
	typedef [v1_enum] enum FldType
	{
		kftString, // TsString string.
		// These types only specify that we are dealing with a MultiString or MultiText field.
		// The actual writing system(s) can be a real writing system or a magic writing system (in common.h)
		// and is specified in another spot, such as m_ws in FldSpec.
		kftMsa, // Multi string alternative.
		kftMta,  // MultiText alternative.
		kftRefAtomic, // Atomic reference to a PossibilityItem set via the poss. chooser.
		kftRefCombo, // Atomic reference to a PossibilityItem set via a combo box.
		kftRefSeq, // Seq of refs to PossibilityItem set via the poss. chooser.
		kftEnum, // An enumeration of possible values set via a combo box.
		// The next two are not (yet?) supported for display in the dialog, nor in resulting
		// views. They are for the tertiary use of CustViewDa as a way of accessing database
		// contents.
		kftUnicode, // A plain Unicode string property.
		kftTtp, // A binary column in the database interpreted as a TsTextProps.
		kftStText, // Structured text (Block only).
		kftDummy, // Fake field, no data to load. (Usually a subfield of a kftTitleGroup.)

		kftLimEmbedLabel, // On blocks, smaller FTs mean embed label in para.

		kftGroup, // Group (Block only: use fields in FldVec).
		kftGroupOnePerLine, // Like group, but each field uses a new indented line
		kftTitleGroup, // Special group of a main text field with a small subfield right aligned
		kftDateRO, // Standard read-only date/time as stored in MSDE.
		kftDate, // Standard editable date/time as stored in MSDE.
		kftGenDate, // Generic date (covers BC/AD and fuzzy dates).
		kftSubItems, // Sub items (Hierarchical field type).
		kftObjRefAtomic, // Atomic reference to non-PossibilityItem.
		kftObjRefSeq, // Seq of refs to non-PossibilityItems.
		kftInteger, // Integer property.
		kftBackRefAtomic, // BackRef from atomic ref (no editor type for this yet)
		kftExpandable, // example:  Participants
		kftObjOwnSeq,	// Owning sequence
		kftObjOwnCol,	// Owning collection
		kftGuid,	// GUID of object
		kftStTextParas, // Paragraphs of a Structured text.

		kftLim		// Last item.
	} FldType; // Hungarian ft.

	// Types of boxes used in layout.
	// @h3{Hungarian vbt}
	typedef [v1_enum] enum VwBoxType
	{
		kvbtUnknown = 0,
		kvbtGroup,
		kvbtParagraph,
		kvbtConcPara,
		kvbtPile,
		kvbtInnerPile,
		kvbtMoveablePile,
		kvbtDiv,
		kvbtRoot,
		kvbtTable,
		kvbtTableRow,
		kvbtTableCell,
		kvbtLeaf,
		kvbtString,
		kvbtDropCapString,
		kvbtAnchor,
		kvbtSeparator,
		kvbtBar,
		kvbtPicture,
		kvbtIndepPicture,
		kvbtIntegerPicture,
		kvbtLazy
	} VwBoxType;	// Hungarian vbt.


	/*******************************************************************************************
		Interface ISilDataAccess
		This interface provides object property data to the view and allows properties to be
		updated and objects to be added or deleted.It also allows client code to register
		itself to be notified if a given property changes.

		ENHANCE JohnT: these methods are rather inconsistent in what they do when no value is
		found for a property being read.

		@h3{When to implement}
		Most users will use the standard implementations in ${VwCacheDa} or ${CustViewDa}. You
		can make your own if you want to store data in a special way and make it available to
		the view subsystem. In such cases it will usually be helpful to inherit from
		${VwBaseDataAccess}.

		@h3{When to use}
		Pass an instance of this interface to a ${IVwRootBox#putref_DataAccess} when
		initializing it. You can also use it directly to read and write data. In the case of
		${CustViewDa}, this has the effect of an immediate update to the database.

		Another common use is within an implementation of ${IVwViewConstructor} to get
		direct access to the data being displayed.

		@h3{How to obtain an instance}
		${VwCacheDa} is often instantiated directly using NewObj. We may soon provide a way to
		create one using CoCreateInstance.

		CustViewDa is initially obtained by using NewObj. Usually there is one master instance
		of this class per database.  In a database application it is obtained by calling
		${AfDbApp::GetDbInfo), asking the resulting ${AfDbInfo} for its AfLpInfo, and asking
		that to ${AfLpInfo#GetDataAccess}. This process may well change (hopefully simplifying)
		as we refine the factoring of the AfApp subclasses to offer the right functions at each
		level, and as we improve the encapsulation of CustViewDa. (The name of the latter may
		well change, too.)

		In a view constructor, call ${IVwEnv#get_DataAccess}, using the pvwenv passed to most
		view constructor methods.

		@h3{Hungarian: sda}
	*******************************************************************************************/
	DeclareInterface(SilDataAccess, Unknown, 26E6E70E-53EB-4372-96F1-0F4707CCD1EB)
	{
		// Obtain the value of an atomic object property.  The output parameter @i{phvo} will be
		// set to zero if no object is stored.
		// @return S_FALSE if the object property is not in the cache.  S_OK if it is. Some
		// implementations may choose to load the data instead, other implementations
		// may return S_OK and set @i{phvo} to zero.
		[propget] HRESULT ObjectProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] HVO * phvo);
		// Obtain one item from an object sequence or collection property.
		// @param index Indicates the item of interest. @b{Zero based}.
		//
		// @error E_INVALIDARG if index is out of range.
		[propget] HRESULT VecItem(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int index, // first item is 0
			[out, retval] HVO * phvo);
		// Get the length of the specified sequence or collection property.
		[propget] HRESULT VecSize(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] int * pchvo);
		// Get the length of the specified sequence or collection property.
		[propget] HRESULT VecSizeAssumeCached(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] int * pchvo);
		// Get the full contents of the specified sequence in one go.
		HRESULT VecProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int chvoMax,
			[out] int * pchvo,
			[out, size_is(chvoMax), length_is(*pchvo)] HVO * prghvo);


		// Get the value of a binary property.
		// @param prgb, cbMax Buffer to which to copy data. May pass NULL, 0 to request
		// required length.
		// @param pcb Indicates how many bytes of binary data were read.
		// @error E_FAIL if buffer is too small (other than zero length).
		// @return S_FALSE if no value is known for this property. *pcb will be zero.
		// Some implementations may return S_OK and set @i{*pcb} to zero.
		HRESULT BinaryPropRgb(
			[in] HVO obj,
			[in] PropTag tag,
			[out, size_is(cbMax)] byte * prgb,
			[in] int cbMax,
			[out] int * pcb);
		// Get the value of a property whose value is a GUID.
		// @return S_FALSE if no value is known for this property. *pguid will be GUID_NULL,
		// all zeros.
		// Some implementations may return S_OK and set @i{*puid} to zero.
		[propget] HRESULT GuidProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] GUID * puid);
		// Get the object that has the given guid.
		// @return S_FALSE if no value is known for this property. *Hvo will be 0.
		// Some implementations may return S_OK and set @i{*pHvo} to zero.
		[propget] HRESULT ObjFromGuid(
			[in] GUID uid,
			[out, retval] HVO * pHvo);
		// Get the value of a integer property. May also be used for enumerations.
		// @return 0 if no value known for this property.
		// ENHANCE JohnT: shouldn't it also return S_FALSE?
		[propget] HRESULT IntProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] int * pn);
		// Get the value of a 64-bit integer property (often actually a time).
		// @return 0 if no value known for this property.
		// ENHANCE JohnT: shouldn't it also return S_FALSE?
		[propget] HRESULT Int64Prop(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] __int64 * plln);
		// Get the value of a boolean property.
		// @return false if no value known for this property.
		[propget] HRESULT BooleanProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] ComBool * pn);
		// Get the value of one alternative of a Multilingual alternation.
		// @return an empty string in the correct writing system if no value recorded.
		[propget] HRESULT MultiStringAlt(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ws,
			[out, retval] ITsString ** pptss);
		// Method used to get a whole MultiString when asked to display all the alternatives.
		// This is unusual and not widely implemented.
		[propget] HRESULT MultiStringProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] ITsMultiString ** pptms);
		// Read an arbitrary property as a variant.  The view subsystem does not care what
		// kind of value you put in the variant.  However, when you use AddProp, the view
		// subsystem calls back to Prop to get the variant which is then passed to
		// DisplayVariant.  DisplayVariant must be prepared to handle whatever Prop puts there.
		// If you put an IUnknown or IDispatch value in the variant, the Views code will
		// call Release once on that object. Normally you should pass a ${SmartVariant}.
		// @return S_FALSE (and variant VT-EMPTY) if no known value for this property, or
		// if the implemetation does not know how to represent it as a variant. Current
		// implementations can represent 32 and 64 bit integers and (non-multilingual) strings.
		// Some implementations may return S_OK and variant VT-EMPTY.
		[propget] HRESULT Prop(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] VARIANT * pvar);
		// Read a (non-multilingual) string property.
		// @return an empty string, writing system 0, if property not found.
		[propget] HRESULT StringProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] ITsString ** pptss);
		// Read a time property.
		// @param ptim Actually an SilTime.
		// @return 0 if property not found.
		[propget] HRESULT TimeProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] __int64 * ptim);
		// Read a Unicode string property. (Note also ${#UnicodePropRgch} if you don't want
		// a BSTR allocated.
		// @return NULL, S_FALSE if property not found. Some implementations may return
		// S_OK and empty string if property not found.
		[propget] HRESULT UnicodeProp(
			[in] HVO obj,
			[in] PropTag tag,
			[out, retval] BSTR * pbstr);
		// Sets a Unicode string property.
		[propput] HRESULT UnicodeProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in] BSTR bstr);
		// Read a Unicode string property. See ${get_UnicodeProp} for a BSTR result.
		// @param prgch Buffer for result. Pass NULL to inquire length.
		// @param cchMax Buffer length for result. Pass 0 to inquire length.
		// @error E_FAIL if buffer too small.
		// @return *pcch 0, S_FALSE if property not found (or S_OK from some implementations).
		HRESULT UnicodePropRgch(
			[in] HVO obj,
			[in] PropTag tag,
			[out, size_is(cchMax)] OLECHAR * prgch,
			[in] int cchMax,
			[out] int * pcch);
		// Get an object which is typically a non-CmObject derived from a Binary field.
		// It is up to each SilDataAccess what kinds of objects it can persist in this way.
		// The current ones mostly use this for ${ITsTextProps}.
		[propget] HRESULT UnknownProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[out, retval] IUnknown ** ppunk);

		// Begin a sequence of actions that will be treated as one task for the purposes
		// of undo and redo. If there is already such a task in process, this sequence will be
		// included (nested) in that one, and the descriptive strings will be ignored.
		// @param bstrUndo Short description of an action.  This is intended to appear on the
		// "undo" menu item (e.g. "Typing" or "Clear")
		// @param bstrRedo Short description of an action.  This is intended to appear on the
		// "redo" menu item (e.g. "Typing" or "Clear").  Usually, this is the same as @i{bstrUndo}
		HRESULT BeginUndoTask(
			[in] BSTR bstrUndo,
			[in] BSTR bstrRedo);

		// End the current task sequence. If an outer sequence is in progress, that one will
		// continue.
		HRESULT EndUndoTask();

		// Continue the previous sequence. This is intended to be called from a place like
		// OnIdle that performs "clean-up" operations that are really part of the previous
		// sequence.
		HRESULT ContinueUndoTask();

		// End the current sequence, and any outer ones that are in progress. This is intended
		// to be used as a clean-up function to get everything back in sync.
		HRESULT EndOuterUndoTask();

		// End current sequences and rollback pending changes on the action handler.
		HRESULT Rollback();

		// Break the current undo task into two at the current point. Subsequent actions will
		// be part of the new task which will be assigned the given labels.
		HRESULT BreakUndoTask(
			[in] BSTR bstrUndo,
			[in] BSTR bstrRedo);

		// Begin a sequence of actions that cannot be undone.
		// This sequence will commit any previous undo actions.
		HRESULT BeginNonUndoableTask();

		// End the task sequence and commit it.
		HRESULT EndNonUndoableTask();

		// Return the IActionHandler that is being used to record undo information.
		// May be NULL
		HRESULT GetActionHandler(
			[out, retval] IActionHandler ** ppacth);

		// Set the IActionHandler that is being used to record undo information.
		// May be NULL
		HRESULT SetActionHandler(
			[in] IActionHandler * pacth);

		// Delete the specified object. Use this when you know the owning property
		// is not in the cache, or for some other reason don't care about having the
		// owning property cleaned up. Usually use ${#DeleteObjOwner}.
		//
		// The caller should also call PropChanged to notify interested parties.
		HRESULT DeleteObj(
			[in] HVO hvoObj);
		// Delete an object and clean up the owning property
		// If the owning property is not cached at all, the object is simply deleted.
		// This is not an error. In a database application, deletion ensures that any
		// subsequent read of the owning property will get the modified value of the
		// owning property.
		// @param hvoObj the one to delete.
		// @param ihvo Pass -2 for atomic properties.
		// For collections or sequences, if you know the position, pass it; otherwise,
		// pass -1.

		// The caller should also call PropChanged to notify interested parties.
		HRESULT DeleteObjOwner(
			[in] HVO hvoOwner,
			[in] HVO hvoObj,
			[in] PropTag tag,
			[in] int ihvo);
		// Insert chvo new objects after the one at ihvo, which functions as a pattern.
		// Typically used when splitting a paragraph at ihvo.
		// The new objects should generally be similar to the one at ihvo, except that
		// the main text property that forms the paragraph body should be empty.
		// If the object has a paragraph style property, the new objects should have
		// the same style as the one at ihvo, except that, if a stylesheet is passed,
		// each successive paragraph inserted should have the appropriate next style
		// for the one named in the previous paragraph.

		// The caller should also call PropChanged to notify interested parties.
		HRESULT InsertNew(
			[in] HVO hvoObj,
			[in] PropTag tag,
			[in] int ihvo,
			[in] int chvo,
			[in] IVwStylesheet * pss);
		// Make a new object owned in a particular position. The object is created immediately.
		// (Actually in the database, in database implementations; this will roll back if
		// the transaction is not committed.)
		// If ord is >= 0, the object is inserted in the appropriate place in the (presumed
		// sequence) property, both in the database itself and in the data access object's
		// internal cache, if that property is cached.
		// If ord is < 0, it is entered as a null into the database, which is appropriate for
		// collection and atomic properties.
		// Specifically, use -2 for an atomic property, and -1 for a collection; this will
		// ensure that the cache is updated. You may use -3 if you know the property is not
		// currently cached.

		// The caller should also call PropChanged to notify interested parties.
		HRESULT MakeNewObject(
			[in] int clid,
			[in] HVO hvoOwner,
			[in] PropTag tag,
			[in] int ord,
			[out, retval] HVO * phvoNew);

		// Change the owner of a range of objects in a sequence (given by the indexes
		// ihvoStart and ihvoEnd) and insert them in another sequence. The object is
		// inserted in the destination sequence before the object located at ihvoDstStart.
		// The "ord" values change accordingly (first one to ihvoDstStart).

		// The caller should also call PropChanged to notify interested parties.
		HRESULT MoveOwnSeq(
			[in] HVO hvoSrcOwner,
			[in] PropTag tagSrc,
			[in] int ihvoStart,
			[in] int ihvoEnd,
			[in] HVO hvoDstOwner,
			[in] PropTag tagDst,
			[in] int ihvoDstStart);

		// Change the owner of an object. The source and destination objects can be of
		// any type. If the destination is a sequence, one can specify the location to
		// insert the object. The object is inserted in the destination sequence before
		// the object located at ihvoDstStart.

		// The caller should also call PropChanged to notify interested parties.
		HRESULT MoveOwn(
			[in] HVO hvoSrcOwner,
			[in] PropTag tagSrc,
			[in] HVO hvo,
			[in] HVO hvoDstOwner,
			[in] PropTag tagDst,
			[in] int ihvoDstStart);

		// Replace the range of objects [ihvoMin, ihvoLim) in property tag of object hvoObj
		// with the sequence of chvo objects at prghvo. (prghvo may be null if chvo is zero;
		// this amounts to a deletion).
		// Use this for REFERENCE sequences and collections; use methods like ${#MoveOwnSeq},
		// ${#MakeNewObject}, or ${#DeleteObjOwner} to make similar changes to owning sequences
		// and collections.
		// The actual objects deleted will be the ones at the specified positions in the cache.
		// Therefore if you are using a collection it is important to be sure that the way the
		// items are ordered is going to give the effect you expect. (Indeed, even for sequences,
		// you could load things into the cache in some order other than by their ord field,
		// though this would be unusual.)

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT Replace(
			[in] HVO hvoObj,
			[in] PropTag tag,
			[in] int ihvoMin,
			[in] int ihvoLim,
			[in, size_is(chvo)] HVO * prghvo,
			[in] int chvo);

		// Change the value of an atomic REFERENCE property. (Use ${MakeNewObject} or
		// ${DeleteObjOwner} to make similar changes to owning atomic properties.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetObjProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] HVO hvoObj);

		// This processes all atomic and sequence owning and reference props in the cache
		// and removes the given hvo from any property where it is found. PropChanged is
		// called on each modified property to notify interested parties.
		HRESULT RemoveObjRefs(
			[in] HVO hvo);

		// Change a binary data property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetBinary(
			[in] HVO hvo,
			[in] PropTag tag,
			[in, size_is(cb)] byte * prgb,
			[in] int cb);

		// Change a GUID property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetGuid(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] GUID uid);

		// Change an integer property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetInt(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int n);

		// Change a long integer property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetInt64(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] __int64 lln);

		// Change an boolean property of an object.
		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetBoolean(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] ComBool n);

		// Change one alternative of a multilingual string property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetMultiStringAlt(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ws,
			[in] ITsString * ptss);

		// Change a string-valued property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetString(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] ITsString * ptss);

		// Change a time property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetTime(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] __int64 lln);

		// Change a Unicode property of an object.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetUnicode(
			[in] HVO hvo,
			[in] PropTag tag,
			[in, size_is(cch)] OLECHAR * prgch,
			[in] int cch);

		// Change a binary property of an object to a suitable representation of
		// the object represented by the IUnknown. Particular implementations may
		// differ in the range of object types supported. The current implementation
		// only handles ITsTextProps objects.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.
		HRESULT SetUnknown(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] IUnknown * punk);

		// Request notification when properties change. The ${IVwNotifyChange#PropChanged}
		// method will be called when the property changes (provided the client making the
		// change properly calles ${#PropChanged}.
		HRESULT AddNotification(
			[in] IVwNotifyChange * pnchng);

		// Notify clients who have requested it that the specified property is changing.
		// The last five arguments indicate the nature of the change, as in
		// ${IVwNotifyChange#PropChanged}. In general, that method will be called for
		// all clients that have requested notification. Certain variations in this
		// process can be made using the first two arguments.

		// If pct is kpctNotifyAll, the first argument is ignored, and all clients are
		// notified in an arbitrary order. (Currently this is also the default behavior
		// if some unrecognized constant is passed. This may eventually become an error.)

		// If pct is kpctNotifyMeThenAll, then the object indicated by the first argument
		// is notified first. This allows the main focus window to update first.

		// If pct is kpctNotifyAllButMe, then the object indicated by the first argument
		// is not notified at all, even if it is listed as requesting notification. This
		// is useful when the object making the change has already done the work that it
		// would normally do when receiving such a notification.
		HRESULT PropChanged(
			[in] IVwNotifyChange * pnchng,
			[in] int pct,
			[in] HVO hvo,
			[in] int tag,
			[in] int ivMin,
			[in] int cvIns,
			[in] int cvDel);

		// Request removal from the list of objects to notify when properties change.
		HRESULT RemoveNotification(
			[in] IVwNotifyChange * pnchng);

		// Get the display index for the property item. Used in prop changed processing
		// since the SilDataAccess given to the VwRootBox may be filtered.
		// Display index will be -1 if the item is not being displayed.
		HRESULT GetDisplayIndex(
			[in] HVO hvoOwn,
			[in] int tag,
			[in] int ihvo,
			[out, retval] int * ihvoDisp);

		// Get the language writing system factory associated with the database associated with
		// the underlying object.
		[propget] HRESULT WritingSystemFactory(
			[out, retval] ILgWritingSystemFactory ** ppwsf);

		// Set the language writing system factory associated with the database associated with
		// the underlying object.
		[propputref] HRESULT WritingSystemFactory(
			[in] ILgWritingSystemFactory * pwsf);

		// Fill in the given array with the encodings this database finds interesting, up
		// to the given max, and return the number obtained--eg, vernacular plus analysis
		// encodings. (Currently this is used by the Styles dialog to flesh out the fonts tab.)

		// ENHANCE JohnT: Replace with a method or methods asking for specifc kinds of encodings?

		// Return a list of the encodings that are of interest within the database.
		// If cwsMax is zero, return the actual number (but no encodings).
		// If there is not enough room, return E_INVALIDARG.
		[propget] HRESULT WritingSystemsOfInterest(
			[in] int cwsMax,
			[out, size_is(cwsMax)] int * pws,
			[out, retval] int * pcws);

		// Insert the object hvoDst at position ihvo in property tag of the object hvoSrc,
		// and associate the given bstrExtra info with it.
		//
		// To enable storing extra info, add something like the following to PostCM.sql:
		//
		// if exists (select * from sysobjects where name = 'StTxtPara_TextObjects')
		//	begin
		//		ALTER TABLE StTxtPara_TextObjects
		//		ADD Extra nvarchar(4000) NULL
		//	end

		// This also requires creating a new stored procedure like
		// InsertRef_StTxtPara_TextObjects_Extra$ for any relationship table that needs it.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.

		// NOTE: This is not fully implemented yet.
		HRESULT InsertRelExtra(
			[in] HVO hvoSrc,
			[in] PropTag tag,
			[in] int ihvo,
			[in] HVO hvoDst,
			[in] BSTR bstrExtra);

		// Update the bstrExtra info associated with the object at
		// position ihvo in property tag of the object hvoSrc.
		//
		// To enable storing extra info, add something like the following to PostCM.sql:
		//
		// if exists (select * from sysobjects where name = 'StTxtPara_TextObjects')
		//	begin
		//		ALTER TABLE StTxtPara_TextObjects
		//		ADD Extra nvarchar(4000) NULL
		//	end

		// This also requires creating a new stored procedure like
		// InsertRef_StTxtPara_TextObjects_Extra$ for any relationship table that needs it.

		// The caller should also call PropChanged to notify interested parties,
		// except where the change is being made to a newly created object.

		// NOTE: This is not fully implemented yet.
		HRESULT UpdateRelExtra(
			[in] HVO hvoSrc,
			[in] PropTag tag,
			[in] int ihvo,
			[in] BSTR bstrExtra);

		// Get the bstrExtra info associated with the object at
		// position ihvo in property tag of the object hvoSrc.
		//
		// To enable extra info, add something like the following to PostCM.sql:
		//
		// if exists (select * from sysobjects where name = 'StTxtPara_TextObjects')
		//	begin
		//		ALTER TABLE StTxtPara_TextObjects
		//		ADD Extra nvarchar(4000) NULL
		//	end

		// NOTE: This is not fully implemented yet.
		HRESULT GetRelExtra(
			[in] HVO hvoSrc,
			[in] PropTag tag,
			[in] int ihvo,
			[out, retval] BSTR * pbstrExtra);

		// Find out whether a particular property is cached.
		// Eventually we may support using kcptNil as 'any' but not yet.
		// cpt is a member of the defines in CmTypes.h
		// ws is ignored unless cpt is kcptMulti...
		[propget] HRESULT IsPropInCache(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int cpt,
			[in] int ws,
			[out, retval] ComBool * pfCached);

		// A method that indicates if the cache has changed since it was first loaded by means
		// of Set* methods.  Basically what this means is that client code has called one
		// of the property modification methods (eg. "Set" methods, NewObject, DeleteObject*,
		// MoveOwnSeq, or Replace methods).

		// ENHANCE JohnT: It would be nice to have
		// a way to retrieve information about what changed.
		HRESULT IsDirty(
			[out, retval] ComBool * pf);

		// Clear the dirty flag (typically after saving).
		HRESULT ClearDirty();

		// Get the meta data cache, if any. Type IUnknown is used to avoid circularity
		// between FieldWorks components in type definitions.
		// (Arguably these functions would make more sense in IVwCachDa. But they are
		// very parallel to the writing system factory methods, which are well-established
		// in this interface.)
		[propget] HRESULT MetaDataCache(
			[out, retval] IFwMetaDataCache ** ppmdc);

		// Set the meta data cache.
		// (Note that currently this is most commonly done in the Init method of IVwOleDbDa.
		// A setter is added here so that non-database caches can have metadata.)
		[propputref] HRESULT MetaDataCache(
			[in] IFwMetaDataCache * pmdc);

		// Test whether an HVO represents a valid object. For the simple memory cache,
		// any HVO is potentially valid, and true will be returned; but for the database
		// cache, it will test that the object has a known class. For dummy objects, this
		// just tests that there is a class in the cache, but for objects not known to be
		// dummies, it does an actual SQL query EVERY time it is called. This can get VERY
		// expensive; try not to do it for every object in a long loop.
		[propget] HRESULT IsValidObject(
			[in] HVO hvo,
			[out, retval] ComBool * pfValid);

		// Test whether the specified ID is in the range of dummy objects that have been
		// allocated by this cache. Note that a true result does NOT guarantee that we have
		// the necessary class information to create, say, an FDO object. You may want to
		// also check IsValidObject (which in this case will be fast) if this returns true.
		[propget] HRESULT IsDummyId(
			[in] HVO hvo,
			[out, retval] ComBool * pfDummy);

		// Return the index of hvo in the flid vector of hvoOwn.
		// @param hvoOwn The object ID of the owner.
		// @param flid The parameter on hvoOwn that owns hvo.
		// @param hvo The target object ID we are looking for.
		// @param ihvo Pointer to return the index, or -1 if not found.
		// @return S_OK with index in *pihvo, or E_POINTER if pihvo is a NULL pointer.
		// Return -1 if hvo is not present in the flid vector of hvoOwn.
		HRESULT GetObjIndex(
			[in] HVO hvoOwn,
			[in] int flid,
			[in] HVO hvo,
			[out, retval] int * ihvo);

		// Return a string outline number for the given hvo. hvo should be recursively owned in
		// the flid property. For a doubly-nested subentry, this may return 1.2.4. It does not
		// return a number for the major entry. If an owner is missing, the string generated
		// thus far is returned.
		// @param hvo The object for which we want the outline number.
		// @param flid The field ID which presumably owns hvo.
		// @param fFinPer True if we want to append a final period to the string.
		// @param pbstr Pointer to the BSTR receiving the outline string.
		// @return S_OK with outline number in *pbstr, or E_POINTER if pbstr is a NULL pointer.
		HRESULT GetOutlineNumber(
			[in] HVO hvo,
			[in] int flid,
			[in] ComBool fFinPer,
			[out, retval] BSTR * pbstr);

		// Move a (sub)string from one string property to another. Specifically, the range of characters
		// from ichMin to ichLim is removed from property flidSrc on object hvoSrc (in writing system wsSrc,
		// if the property is multilingual), and inserted at ichDest in property flidDst of hvoDst
		// (in writing system wsDst, if that property is multilingual). The ws arguments should be zero for
		// non-multilingual strings.
		// Current plans call for this to be implemented only to handle cases where the source and
		// destination are the Contents of different paragraphs.
		// @param fDstIsNew True if the destination paragraph is a brand new paragraph. In this
		// case the segment translation for the partially moved segment doesn't need to be
		// copied over to the destination paragraph because the source paragraph will be keeping
		// its segment translation.
		HRESULT MoveString(
			[in] int hvoSource,
			[in] PropTag flidSrc,
			[in] int wsSrc,
			[in] int ichMin,
			[in] int ichLim,
			[in] HVO hvoDst,
			[in] PropTag flidDst,
			[in] int wsDst,
			[in] int ichDest,
			[in] ComBool fDstIsNew);
	};

	/*******************************************************************************************
		Interface IStructuredTextDataAccess
		This interface provides information about specific flids used for storing data about
		structured text. Certain editing operations implemented by the view need those flids in
		order to request properties of texts and paragraphs.

		@h3{When to implement}
		Any implementation of ISILDataAccess that wants to allow editing of structured texts
		needs to implement this. Specifically, this is needed for pasting multiple paragraphs,
		dealing with editing when multiple paragraphs are selected, formatting paragraphs, etc.

		@h3{How to obtain an instance}
		Attempt to cast the ISILDataAccess to see if it implements this interface.

		@h3{Hungarian: stda}
	*******************************************************************************************/
	DeclareInterface(StructuredTextDataAccess, Unknown, A2A4F9FA-D4E8-4bfb-B6B7-5F45DAF2DC0C)
	{
		// Obtain the flid used for accessing the contents (a TsString) of a paragraph.
		[propget] HRESULT ParaContentsFlid(
			[out, retval] PropTag * pflid);

		// Obtain the flid used for accessing the Properties (TsTextProps) of a paragraph.
		[propget] HRESULT ParaPropertiesFlid(
			[out, retval] PropTag * pflid);

		// Obtain the flid used for accessing the paragraphs of a text.
		[propget] HRESULT TextParagraphsFlid(
			[out, retval] PropTag * pflid);
	};

	typedef [v1_enum] enum VwClearInfoAction
	{
		kciaRemoveObjectInfoOnly = 0,		// Remove from cache only this object's information
		kciaRemoveObjectAndOwnedInfo = 1,	// Remove from cache information for this object and
											//   everything it owns
		kciaRemoveAllObjectInfo = 2,		// Remove from cache all information related to this
											//   object, including incoming references
	} VwClearInfoAction;

	/*******************************************************************************************
		Interface IVwCacheDa.

		This interface is always implemented as a secondary interface on an object that
		implements ISilDataAccess. Its purpose is to load initial values into the cache, as
		opposed to the similar methods in ISilDataAccess which set a dirty flag or, in some
		implementations, actually modify the underlying data store.

		ENHANCE JohnT: A more appropriate name should be devised, something like ISetupData
		or IInitData or perhaps ISilDataInit.

		@h3{When to implement}
		Implement this when you implement ISilDataAccess if you need this additional capability.

		@h3{When to use}
		Use this interface when loading data into the cache, usually before you start to use
		it as a data source.

		@h3{How to obtain an instance}
		Use QueryInterface on an instance of ISilDataAccess.

		@h3{Hungarian: vcd}
	*******************************************************************************************/
	DeclareInterface(VwCacheDa, Unknown, B9ADC49A-E28B-4858-8C04-53E0D2E5A76F)
	{
		// Cache the value of an atomic object property (owning or reference does not matter
		// since we are not changing the underlying data).

		// To make a change in the underlying data, use ${ISilDataAccess#SetObjProp} for
		// reference properties, and methods like ${ISilDataAccess#MoveOwnSeq},
		// ${ISilDataAccess#MakeNewObject}, or ${ISilDataAccess#DeleteObjOwner}
		HRESULT CacheObjProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in] HVO val);
		// Cache the value of a collection or sequence object property (owning or reference
		// does not matter since we are not changing the underlying data).
		HRESULT CacheVecProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in, size_is(chvo)] HVO rghvo[],
			[in] const int chvo);
		// Change the value of a collection or sequence object property (owning or reference
		// does not matter since we are not changing the underlying data). Use this method only
		// when the underlying data has been changed in some other way, so it is not necessary
		// to save this change to the persistent store. Otherwise use ${ISilDataAccess#Replace}
		// for reference properties, or ${ISilDataAccess#MoveOwnSeq} for owning ones.
		// @param ihvoMin indicates range to remove. May be equal to ivhoLim to indicate a pure insertion.
		// @param ihvoLim indicates range to remove. May be equal to ihvoMin to indicate a pure insertion.
		// @param prghvo indicates objects to insert in place of deleted ones. prghvo
		// may be null if chvo is 0, indicating a pure deletion.
		// @param chvo indicates number objects to insert in place of deleted ones.
		HRESULT CacheReplace(
			[in] HVO hvoObj,
			[in] PropTag tag,
			[in] int ihvoMin,
			[in] int ihvoLim,
			[in, size_is(chvo)] HVO prghvo[],
			[in] int chvo);

		// Methods used for initially loading the cache with object PROPERTY information
		// (excluding reference information).  Note that after loading the cache, these methods
		// should NOT be used but rather the Set* methods.
		HRESULT CacheBinaryProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in, size_is(cb)] byte * prgb,
			[in] int cb);
		HRESULT CacheGuidProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in] GUID uid);
		HRESULT CacheInt64Prop(
			[in] HVO obj,
			[in] PropTag tag,
			[in] __int64 val);
		HRESULT CacheIntProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in] int val);
		HRESULT CacheBooleanProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in] ComBool val);
		HRESULT CacheStringAlt(
			[in] HVO obj,
			[in] PropTag tag,
			[in] int ws,
			[in] ITsString * ptss);
		HRESULT CacheStringProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in] ITsString * ptss);
		HRESULT CacheTimeProp(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] SilTime val);
		HRESULT CacheUnicodeProp(
			[in] HVO obj,
			[in] PropTag tag,
			[in, size_is(cch)] OLECHAR * prgch,
			[in] int cch);
		HRESULT CacheUnknown(
			[in] HVO obj,
			[in] PropTag tag,
			[in] IUnknown * punk);

		// Remove from the cache all information about this object and, if the second
		// argument is true, everything it owns.
		//
		// Note that this is not absolutely guaranteed to work. It tells the system that you
		// no longer need this information cached. However, whether it can find the information
		// efficiently enough to actually do the deletion depends on whether the implementation
		// has a MetaDataCache that can tell it what properties the object has, and in the
		// case of owned objects, it will only find children that are accessible through
		// properties that are in the cache.
		//
		// Note that the property that owns this object is not modified, nor are any
		// references or backreferences that point at it. Only outward references from the
		// object (and its children) are cleared.
		HRESULT ClearInfoAbout(
			[in] HVO hvo,
			[in] VwClearInfoAction cia);
		// This routine similarly (but much more efficiently, especially when clearing incoming refs)
		// removes information about a group of objects.
		HRESULT ClearInfoAboutAll(
			[in, size_is(chvo)] HVO * prghvo,
			[in] int chvo,
			[in] VwClearInfoAction cia);

		// Method to retrieve a particular int property if it is in the cache, and return a bool
		// to say whether it was or not. Similar to ISilDataAccess::get_IntProp, but this method
		// is guaranteed not to do a lazy load of the property and it makes it easier for .Net
		// clients to see whether the property was loaded, because this info is not hidden in an
		// HRESULT.
		[propget] HRESULT CachedIntProp(
			[in] HVO obj,
			[in] PropTag tag,
			[out] ComBool * pf,
			[out, retval] int * pn);

		// Clear all data (but not definitions of virtual properties) out of the cache.
		// Typically this is done before reloading all needed (but perhaps not computed virtual)
		// properties...the virtual ones get recomputed as needed.
		HRESULT ClearAllData();

		// Install the specified virtual handler. This has the following effects:
		// 1. Read the class name and field name from the handler.
		// 2. If a handler already exists for this field of this class, report an error.
		// 3. Allocate a Tag to identify this property, and store it in the handler.
		// 4. Store information in the MetaDataCache (if this cache has one) so that
		//		this tag can be found for the class/field and vice versa.
		// Specifically, on the MDC,
		//		GetOwnClsName will find the class name from the tag,
		//		GetDstClsName will return E_UNEXPECTED (and GetDstClsId E_INVALIDARG),
		//		GetOwnClsId will return the ID of the class,
		//		GetFieldName will find the field name,
		//		GetFieldType will return the data type read from get_DataType() plus kcptVirtual,
		//		IsValidClass will return true (arbitrary, we don't know what sort of objects
		//			if any this property is supposed to contain),
		//		both versions of GetFieldId will find it given the field name and class name or id.
		//		FieldCount will include it, GetFieldIds will return its tag.
		//		GetFields(clsid) will include it if its type (excluding the virtual bit)
		//		matches the requested type.
		HRESULT InstallVirtual(
			[in] IVwVirtualHandler * pvh);
		// This retrieves the VH with the specified tag.
		HRESULT GetVirtualHandlerId(
			[in] PropTag tag,
			[out, retval] IVwVirtualHandler ** ppvh);
		// This retrieves the VH with the specified class and field names.
		// This is redundant if there is an MDC (could ask it for the tag, then look that up), but
		// not all caches currently have an MDC, and we need to be able to test whether a handler
		// is already registered before trying to register a new one. (And the MDC will throw
		// an exception (return a bad HR) if a field is not found...this one just returns null.)
		HRESULT GetVirtualHandlerName(
			[in] BSTR bstrClass,
			[in] BSTR bstrField,
			[out, retval] IVwVirtualHandler ** ppvh);
		// Clear all virtual property data.
		HRESULT ClearVirtualProperties();
	};

	#ifndef NO_COCLASSES
	DeclareCoClass(VwCacheDa, 81EE73B1-BE31-49cf-BC02-6030113AC56F)
	{
		interface ISilDataAccess;
		interface IVwCacheDa;
		interface IStructuredTextDataAccess;
	};
	DeclareCoClass(VwUndoDa, 5BEEFFC6-E88C-4258-A269-D58390A1F2C9)
	{
		interface ISilDataAccess;
		interface IVwCacheDa;
		interface IStructuredTextDataAccess;
	};
	#endif // !NO_COCLASSES


	// One of these values is passed as an argument to IVwRootBox::OnExtendedKey.
	typedef [v1_enum] enum VwShiftStatus
	{
		kfssNone = 0,

		kfssShift = 1,
		kfssControl = 2,

		kgrfssShiftControl = kfssShift | kfssControl,
	} VwShiftStatus;

	// These objects are used in describing selections, for example in ${IVwRootBox#MakeSelection}
	// and ${IVwSelection#GetAllSelInfo}. See the explanation in ..\..\doc\guides\
	// views_user_guide.htm (section 6).
	// Note: SelLevInfo (in src/common/COMInterfaces/ComUtils.cs) MUST be kept in sync
	// with any changes to this struct.
	typedef struct VwSelLevInfo
	{
		// identifies a property, typically containing objects, of a containing object.
		PropTag tag;
		// Usually zero, indicates if that property has been displayed previously as part of
		// the current display of the containing object.
		int cpropPrevious;
		// if tag identifies an object sequence (or collection) property, indicates the
		// index within it of the contained object. If the tag is an atomic property, it
		// is zero. If the tag is a string property, it is -1.
		int ihvo;
		// On retrieval gives the actual hvo at ihvo; CANNOT BE USED currently for creating
		// a selection (routines that create selections IGNORE it). (This is partly because
		// it can be ambiguous, since in a reference sequence the same object can occur
		// repeatedly.)
		int hvo;
		// If the property is a multitext one, gives the identifier of the alternative.
		// Value is meaningless unless ihvo == -1. Always ignored as an input.
		int ws;
		// If the property is a text (or multitext) one, gives the char index of the ORC
		// that 'contains' the embedded object containing the selection.
		// Value is meaningless unless ihvo == -1.
		int ich;
	} VwSelLevInfo; // Hungarian vsli

	// This struct contains information about how an object property changed.

	typedef struct VwChangeInfo
	{
		HVO hvo; // object that changed
		PropTag tag; // property that changed
		int ivIns; // index of first object (or char) changed in prop.
		int cvIns; // number of objects (or chars) inserted at that index
		int cvDel; // number of objects (or chars) deleted (previously at and following ivMin)
	} VwChangeInfo; // Hungarian ci

	// Units of measurement, used in ${VwLength} structs.
	typedef [v1_enum] enum VwUnit { //for VwLengths
		kunPoint1000 = 0,	// actual distance in 1/1000 of point
		kunPercent100 = 1,	// hundredths of a percent of other length, spec for each use
		kunRelative = 2		// left over space assigned to relative items proportionally
	} VwUnit;

	// A dimension, mainly used for tables, consisting of a distance and a unit.
	typedef struct {
		int nVal;
		VwUnit unit;
	} VwLength; // Hungarian vlen

	// Possible ways of aligning text.
	typedef [v1_enum] enum VwAlignment {
		kvaLeft,
		kvaCenter,
		kvaRight,
		kvaJustified
	} VwAlignment; // Hungarian frmpos

	//	Which sides of a table to draw a frame.
	typedef [v1_enum] enum VwFramePosition {
		kvfpVoid = 0x00,
		kvfpAbove = 0x01,
		kvfpBelow = 0x02,
		kvfpLhs = 0x04,
		kvfpRhs = 0x08,

		kvfpHsides = kvfpAbove | kvfpBelow,
		kvfpVsides = kvfpLhs | kvfpRhs,
		kvfpBox = kvfpHsides | kvfpVsides
	} VwFramePosition; // Hungarian vfp

	// Which rows and columns to draw rules between. Values are chosen so
	// that group rules are added when bit 1 is on,
	// rules between all rows when bit 2 is on,
	// and rules between all columns when bit 4 is on.
	// However for consistency with HTML we don't allow the combinations
	// where rules are missing only at group bondaries.
	typedef [v1_enum] enum VwRule {
		kvrlNone = 0x00,
		kvrlGroups = 0x01,
		kvrlRowNoGroups = 0x02, // Reserved for internal use
		kvrlRows = kvrlGroups | kvrlRowNoGroups,
		kvrlColsNoGroups = 0x04, // Reserved for internal use
		kvrlCols = kvrlGroups | kvrlColsNoGroups,
		kvrlAll = kvrlRows | kvrlCols,
	} VwRule; // Hungarian vrl

	// Possible values of the ktptBulNumScheme property. See the ${VwStyleProperty}
	// enumeration. Members of the enumeration can specify a particular style for
	// numbering paragraphs, or one of the standard FieldWorks bullets.
	typedef [v1_enum] enum VwBulNum {
		kvbnNone = 0,
		kvbnNumberBase = 10,	// Number styles
		kvbnArabic = kvbnNumberBase,
		kvbnRomanUpper,
		kvbnRomanLower,
		kvbnLetterUpper,
		kvbnLetterLower,
		kvbnArabic01,
		kvbnNumberMax,
		// Make no attempt to give names to all the bullets.  Just identify them with
		// kvbnBulletBase + x, where x is the kctidFbnCbBullet combo-box selection.
		kvbnBulletBase = 100,	// Bullets.
		kvbnBullet = kvbnBulletBase,
		kvbnBulletMax = kvbnBulletBase + 100 // allow up to 100 bullet types
	} VwBulNum; // Hungarian vbn

	// This enumeration identifies layout and formatting properties used in the views code,
	// in addition to those defined in ${FwTextPropType} (in TextServ.idh). It is rather
	// arbitrary which are listed in which place, having to do with which are required for
	// some reason in the Kernel code, and which are exclusively used in the View code or its
	// clients. Possibly we should unify the lists in TextServe.idh. In a few cases, the
	// model of text formatting reflected in FwTextPropType (based on MS Word) conflicts
	// with the one used internally in the views code (based on HTML/CSS). Sometimes the
	// reconciliation of the two is a bit awkward.

	// ******WARNING--WARNING--WARNING--WARNING--WARNING--WARNING--WARNING--WARNING******
	// The actual values of these constants are important and are used in the database!
	// New ones should only be added at the end.

	// Note that the views subsystem adds some options to ktptBold; see ${VwFontWeights}.

	// Note that ktptTabDef (from the FwTextPropType enum) is not presently used or supported.

	// Note that we don't exactly support ktptParaColor. We set back color to the same
	// value, which has the right effect in every case I can think of, except for someone
	// trying to read the property. ENHANCE JohnT: should we eliminate this property?

	// Note that views add some options to font size: percent and enumeration.
	//
	typedef [v1_enum] enum VwStyleProperty
	{
	// ENHANCE JohnT: these names are deprecated, as time permits change them
	// to the corresponding ktpt values. Eventually eliminate this enumeration.

		kspNamedStyle = 133,
		kspMarginLeading = 19,
		kspMarginTrailing = 20,
		kspMarginTop = 21,
		kspMarginBottom = 22,
		kspMaxLines = 151,

		kspWsStyle = 156,
		kspRelLineHeight = 160,
	} VwStyleProperty;

	// A list of sizes, roughly corresponding to the similarly named CSS ones, that
	// can be used as absolute (ktpvMilliPoint) font sizes.
	typedef [v1_enum] enum VwFontAbsoluteSize
	{
		kvfsXXSmall, kvfsXSmall, kvfsSmall, kvfsNormal, kvfsLarge,
		kvfsXLarge, kvfsXXLarge, kvfsSmaller, kvfsLarger
	} VwFontAbsoluteSize;

	// A list of standard values that can be used for font weight, in addition to
	// ktpvOn, ktpvOff, and ktpvInvert.
	typedef [v1_enum] enum VwFontWeight {
		kvfw100 = 100,
		kvfw200 = 200,
		kvfw300 = 300,
		kvfw400 = 400,
		kvfw500 = 500,
		kvfw600 = 600,
		kvfw700 = 700,
		kvfw800 = 800,
		kvfw900 = 900,
		kvfwNormal = 400,
		kvfwBold = 700,
		kvfwBolder = -1,
		kvfwLighter = -2
	} VwFontWeight;


	// Reserved values used in place of tags (or flids) to identify the property to which
	// a sequence of boxes belongs. These values must not be used for any real property.
	typedef [v1_enum] enum VwSpecialAttrTags
	{
		// used as pseudo-property-tag in OpenAttribute() when the object sequence to be
		// displayed does not come from a real property of the current object
		ktagNotAnAttr = -1,
		// used as pseudo-property-tag when boxes are inserted that are not declared to
		// be part of any property.
		ktagGapInAttrs = -2
	} VwSpecialAttrTags;

#if 0
	/*******************************************************************************************
		Interface DIVwRootBox
		This interface expresses the part of IVwRootBox that can successfully be used from
		an oleautomation client. Eventually we may merge the two interfaces.
	*******************************************************************************************/
	DeclareDualInterface(VwRootBox, 6E5B9180-C2BC-4968-AE2C-A00E7B97E707)
	{
		[propget] HRESULT DSelection(
			[out, retval] DIVwSelection ** ppsel);
	};
#endif

	// Possible states of a selection, as passed to ${IVwRootBox#Activate}.
	// Hungarian: vss
	typedef [v1_enum] enum VwSelectionState
	{
		vssDisabled, // Insertion point and ranges are disabled.
		vssOutOfFocus, // Insertion point is disabled, ranges are enabled.
		vssEnabled, // Insertion point and ranges are enabled.
		vssLim,
	} VwSelectionState;

	// Results that IVwRootBox::PrepareToDraw can return.
	// It is important that they stay in this order, from most benign to worst.
	typedef [v1_enum] enum VwPrepDrawResult
	{
		kxpdrNormal, // OK to draw, no lazy box needed expansion
		kxpdrAdjust, // Lazy box expanded, thumb position changed but not visible.
		kxpdrInvalidate, // Had to change visible scroll position, invalidate needed.
		kxpdrLim,
	} VwPrepDrawResult; // Hungarian xpdr

	// Specifies how the paragraph and section marks should be displayed (with or without highlighting)
	typedef [v1_enum] enum VwBoundaryMark
	{
		none,	// display no boundary marker
		endOfParagraph,	// display paragraph mark without highlighting
		endOfSection, // display section mark without highlighting
		endOfParagraphHighlighted, // display paragraph mark with highlighting
		endofSectionHighlighted, // display section mark with highlighting
	} VwBoundaryMark;

	/*******************************************************************************************
		Interface IVwRootBox.
		This is the main interface implemented by the main object that makes up a view.
		It has several sets of methods, which should perhaps be factored out into separate
		interfaces.

		The first group have to do with initializing the root box: setting up the object(s)
		to be displayed, the view constructor that specifies the layout, and the data source.

		The second group is used, typically by the containing window (see methods of
		${AfVwRootSite}, to pass to the root box information about events (such as mouse,
		keyboard, and timer events).

		The third group is used to make enquiries about the current selection, and to change it.

		Finally there are a few miscellaneous methods to make inquiries and change things.

		@h3{When to implement}
		Don't even think about it. This is the core of the whole Views package. Use the
		standard implementation in Views.dll.

		@h3{When to use}
		You will usually make and initialize an instance in the MakeRoot method of a subclass
		of one of the Window classes ${AfVwWnd}, ${AfVwScrollWnd}, or ${AfVwSplitChild}.

		Other methods may be used for special purposes, such as controlling the selection
		from your program.

		If you are not using one of the standard window classes to contain the root box, you
		must use this interface to forward various event notifications to it.

		@h3{How to obtain an instance}
		Use CoCreateInstance (or more often, CreateInstance on a smart pointer) with
		CLSID_VwRootBox or CLSID_VwInvertedRootBox.

		@H3{Hungarian: rootb}
	*******************************************************************************************/
	DeclareInterface(VwRootBox, VwNotifyChange, 85DB7D7D-D47B-440e-A213-F62D5224C982)
	{
		//:> Initialization

		// This must be called along with either SetRootObjects or SetRootVariant or
		// SetRootString.

		// @H3{WARNING}: The site must not be changed in a method that could be called from
		// the rootbox. This is usually only called when the rootbox is first created.
		HRESULT SetSite(
			[in] IVwRootSite * pvrs);
		// Retrieve the data access object used to interpret requests for object properties.
		[propget] HRESULT DataAccess(
			[out, retval] ISilDataAccess ** ppsda);
		// Set the data access object that will interpret requests for properties to be
		// read and set. This is required if your view constructors issue commands that
		// involve reading properties.
		[propputref] HRESULT DataAccess(
			[in] ISilDataAccess * psda);

		// This is the main method typically used to initialize a root object. It is passed
		// three arrays, all the same size (as indicated by chvo); usually all are of size 1.

		// @param prghvo The root object(s) to be displayed.
		// @param prgpvwvc The corresponding view constructor that should be asked to display
		// each root object.
		// @param prgfrag The corresponding fragment argument that should be passed to each
		// Display call on the view constructor.
		// @param pss The style sheet that should be used to interpret all named styles
		// used within this view (whether embedded in strings or explictly requested by the
		// view constructor).
		HRESULT SetRootObjects(
			[in, size_is(chvo)] HVO * prghvo,
			[in, size_is(chvo)] IVwViewConstructor ** prgpvwvc,
			[in, size_is(chvo)] int * prgfrag,
			[in] IVwStylesheet * pss,
			[in] int chvo);
		// Like ${#SetRootObjects, but establishes a single root}
		HRESULT SetRootObject(
			[in] HVO hvo,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag,
			[in] IVwStylesheet * pss);

		// This is an alternative to ${#SetRootObjects} which may be used
		// if the view contains some basic item. The view constructor, if any, will be asked
		// to display it using DisplayVariant; if no view constructor is supplied, a default
		// view of the variant will be produced. Currently the system knows how to make
		// default views of strings and ints only. A style sheet may be supplied to control
		// style interpretations.

		// @H3{Warning} Use of this method has not been extensively tested, if at all.
		HRESULT SetRootVariant(
			[in] VARIANT v,
			[in] IVwStylesheet * pss,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// This is an alternative to ${#SetRootObjects} which may be used
		// if the view will display a single TsString. The style sheet governs its
		// appearance. This method always produces the standard default display of the
		// string; the view constructor is not used in constructing it.
		// If a view constructor and fragment are supplied, they will be used (with
		// object cookie null and tag 0) to notify you of editing of the string,
		// using UpdateProp; otherwise, the string will be non-editable.
		// Calling this must not be combined with calls to the other initializers;
		// however, it is permitted to call this method repeatedly. Each call completely
		// replaces the contents of the root box. No invalidate messages will be sent.
		// This can be used to make one root box display different strings in different
		// places; note however that this makes subsequent paint operations somewhat
		// slower, in that the root must be setup and laid out for each string each time.

		// @H3{Warning} Use of this method has not been extensively tested, if at all.
		HRESULT SetRootString(
			[in] ITsString * ptss,
			[in] IVwStylesheet * pss,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// Retrieve the overlay currently being used to modify text appearance.
		[propget] HRESULT Overlay(
			[out, retval] IVwOverlay ** ppvo);
		// Set an Overlay specifier, which will cause certain appearance changes in text.
		// Setting the overlay will cause a complete regeneration of the display,
		// and may destroy the selection.
		[propputref] HRESULT Overlay(
			[in] IVwOverlay * pvo);

		// Where the root is initialized with SetRootVariant, this allows the client to
		// retrieve the current value, as edited by the end user. This allows a simple view-
		// based editor to work without a HVO at all.

		// @H3{Warning} Use of this method has not been extensively tested, if at all.
		HRESULT GetRootVariant(
			[out, retval] VARIANT * pv);

		//:> Serialization

		// Write the contents of the box to a stream, from which it can be read back
		// and reconstructed. Links to the underlying objects
		// are not recorded.

		// @H3{Warning} This capability is not implemented.
		HRESULT Serialize(
			[in] IStream* pstrm);
		// Read the contents of the box from a stream which was created using Serialize.
		// Links to the underlying objects are not restored.

		// @H3{Warning} This capability is not implemented.
		HRESULT Deserialize(
			[in] IStream* pstrm);

		// Write the contents of the box to a stream in the form of (possibly) multiple
		// <StTxtPara> elements, which are suitable for including in the <Body> elements
		// of a WorldPad XML document.  (When WorldPad can handle other element types in
		// addition to <StTxtPara>, then those may be written by this method as well.)
		// @param pstrm Pointer to an IStream object for output.
		HRESULT WriteWpx(
			[in] IStream * pstrm);

		// Selections
		[propget] HRESULT Selection(
			[out, retval] IVwSelection ** ppsel);

		// Get rid of the selection. Used (for example) when a box in a data entry field
		// loses the focus, and hence its active window, but is kept around for drawing
		// the field.
		HRESULT DestroySelection();

		// To make a selection under program control requires a very precise
		// understanding of the structure of the display. This is discussed in
		// fw\doc\guides\Views_User_Guide.htm, section 6; also in the views architecture.

		// The basic idea is that the selection is part of the display of one of
		// the root objects of the display: which one is indicated by ihvoRoot.

		// In the simplest case, the selection is a range or IP within some
		// text (or other basic) property of the root object. In that case,
		// tagTextProp indicates which property, and cpropPrevious indicates any
		// previous occurrences of that property in the display of that object,
		// cvsli is 0, and ichAnchor and ichEnd indicate
		// the range of it that is selected, and if they are
		// the same (so it is an insertion point) fAssocPrev indicates whether
		// it associates most closely with the preceding or following character.
		// If the property is a multi-string alternate one showing several alternatives,
		// ws indicates which one is to contain the selection.

		// [Note: there is some confusion possible when showing multiple WS alternatives
		// of the same property. For example, if we show in the display of the same parent object the
		// English and Spanish alternatives of a definition, should a selection in the Spanish
		// be considered the first (cpropPrevious = 0) occurrence of the SPANISH definition, or the second
		// (cpropPrevious = 1) occurrence of (any WS of) the definition? Currently the second
		// interpretation is used, so previous occurrences of the property in ANY WS count in cpropPrevious.
		// This also means that ws is IGNORED as an input parameter...depending on cpropPrevious, it
		// might make a selection inconsistent with the ws passed.]

		// Next more complex is where the selection is still in a single string property,
		// but it is not a property of one of the root objects. In that case,
		// ${VwSelLevInfo} objects are added to indicate the path from the root
		// object to the one that has the selection property.
		// The object that has the selection must be (directly or indirectly)
		// contained in some one property of the root object: which
		// property is indicated by prgvsli[cvsli-1].tag. In rare cases, that property
		// may be displayed more than once: the number of occurrences before the one
		// we want is indicated by cpropPrevious.
		// On output from AllTextSelInfo, hvo is set to the actual object; this field
		// is ignored in MakeTextSelection.

		// As a special case, a selection may occur in an embedded display, typically the
		// caption of an embedded picture. Such embedded displays are associated with an
		// ORC (object replacement character) in a string property. An extra level in the
		// SelLevInfo array identifies this character. The previous level will have
		// identified the object that has the string property. The special level will
		// identify the object character by having
		//		- ihvo = -1; and
		//		- tag = the tag of the string property containing the ORC
		//		- chvoPrevious the number of previous occurrences of that string (typically 0)
		//		- ws indicates which alternative of the string property, if it is multilingual
		//		- ich gives the character index of the ORC.
		// ws is 0 and ich is -1 for ordinary levels.
		// It is theoretically possible to have more than one root object in the display of an
		// embedded object. This is not yet handled; there will be no indication of it on
		// retrieving selection info, and there is no way to specify any object other than
		// the first root.

		// The selection must, furthermore, be at a
		// particular position in the list of objects displayed for that property
		// (if it is a sequence): which one is indicated by prgvsli[cvsli-1].ihvo.
		// This pattern repeats until we have indicated the path down to the
		// object that has the basic property, and the exact part of that property
		// that is selected is indicated as before.

		// Finally, we can make a selection that spans multiple paragraphs, where the
		// anchor and end point are in different objects. Currently, several
		// restrictions apply to this. First, the anchor and end point must be in
		// the same property: thus, tagTextProp can identify them both.
		// Next, the objects containing the end points must be displayed in a common
		// property one level up: they are both part of the property indicated by
		// prgvsli[0].(tag, cpropPrevious). The anchor object in that list is indicated by
		// prgvsli[0].ihvo. The end-point object is indiated by ihvoEnd.

		// In the simpler cases, where ihvoEnd is not needed, it should be set to -1.

		// The information required to make an equivalent selection can be obtained
		// from an existing one by calling ${IVwSelection#CLevels} to get cvlsi+1,
		// then creating a suitable
		// prgvsli, then calling the ${IVwSelecton#AllTextSelInfo} method.
		HRESULT MakeTextSelection(
			[in] int ihvoRoot,
			[in] int cvlsi,
			[in, size_is(cvlsi)] VwSelLevInfo * prgvsli,
			[in] int tagTextProp,
			[in] int cpropPrevious,
			[in] int ichAnchor,
			[in] int ichEnd,
			[in] int ws,
			[in] ComBool fAssocPrev,
			[in] int ihvoEnd,
			[in] ITsTextProps * pttpIns,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// Make a text range selection whose endpoints are the given selections.
		HRESULT MakeRangeSelection(
			[in] IVwSelection * pselAnchor,
			[in] IVwSelection * pselEnd,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// This allows simple selections to be made without knowledge of the contents
		// of the view, for example, tabbing into a field.
		// If fInitial is true, it makes a selection at the first possible place;
		// otherwise, the last possible place.
		// If fEdit is true, the place selected must be somewhere that the user can
		// do text editing.
		// If fRange is true, then the IP resulting from the previous two steps is
		// expanded to a range involving all the text in the same property.
		// Note: changed in Aug 2006: previously returned E_FAIL if a selection with
		// the desired characteristics could not be made, now just returns a null
		// selection.
		HRESULT MakeSimpleSel(
			[in] ComBool fInitial,
			[in] ComBool fEdit,
			[in] ComBool fRange,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// This combines some of the features of ${#MakeTextSelection} and ${#MakeSimpleSel}.
		// The ihvoRoot argument indicates one of the root objects of the view.
		// prgvsli[cvsli-1] indicates a particular object in a particular
		// property of that root. The next preceding prgvsli indicates an object that
		// is part of that, and so forth. (If cvsli is 0, the object is the root
		// object itself.)
		// Similarly, cvsliEnd and prgvsliEnd indicate a path to the end object of the
		// selection. If fWholeObject is true, these arguments are not used, and
		// cvsliEnd should be 0.
		// These paths having designated some particular display of some particular object,
		// if fWholeObj is false, fInitial, fEdit, and fRange indicate how to make
		// a selection near the start of the first object (if fInitial is true) or near
		// the end of the last object (if fInitial is false), as in ${#MakeSimpleSel}.
		// In this case the other path is ignored.
		// If fWholeObj is true, the fInitial, fEdit, and fRange
		// arguments are ignored: the whole object or sequence of objects from the initial
		// one to the final one is selected.
		// If fEdit is true, it searches (forward or backward according to fInitial) for
		// an editable selection. Currently this could take it beyond the object indicated;
		// we may change this, because it doesn't feel right to me (JohnT).
		// It is, however, limited to 1/10 second, so that it won't take a ridiculous time
		// in a large, read-only view.
		// Note: as of 12 Aug 2006, if unable to make the requested selection, returns S_OK
		// with selection null rather than E_FAIL. This makes for fewer spurious exceptions
		// in C#.
		HRESULT MakeTextSelInObj(
			[in] int ihvoRoot,
			[in] int cvsli,
			[in, size_is(cvsli)] VwSelLevInfo * prgvsli,
			[in] int cvsliEnd,
			[in, size_is(cvsliEnd)] VwSelLevInfo * prgvsliEnd,
			[in] ComBool fInitial,
			[in] ComBool fEdit,
			[in] ComBool fRange,
			[in] ComBool fWholeObj,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// This one selects a picture or similar non-text thing that is, or is part of,
		// the display of the specified object. Eventually we may extend it to selecting
		// objects and part of them other than pictures.
		// If tag is 0, we expect the picture to be the whole display of the object
		// specified by prgvsli; if it is non-null, we select everything in that
		// property (currently assumed to be a single picture).
		HRESULT MakeSelInObj(
			[in] int ihvoRoot,
			[in] int cvsli,
			[in, size_is(cvsli)] VwSelLevInfo * prgvsli,
			[in] int tag,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// Make a selection at the position that a selection would have been made by a
		// ${#MouseDown} using the same first four parameters, ignoring editability
		// restrictions.
		// @param fInstall If true, install the selection in the root box.
		// @param ppsel Used to return the new selection (may be null if fInstall is true)
		HRESULT MakeSelAt(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// Make a selection in the layout box indicated by iLevel and iBox.  If fRange is true,
		// select everything in that box.  Otherwise if fInitial is true, make the selection
		// near the beginning of the box, else make the selection near the end.
		// Note that it will attempt to make an editable selection; this may cause it to be
		// in a later box, or to fail if it can't find one quickly.
		// @param pselInit Current selection used to determine range of iLevel.  (may be null to
		// use the installed selection)
		// @param fEndPoint Chooses which end of the given selection to use.
		// @param iLevel Chooses the level of the box (0 = root).
		// @param iBox Chooses which box at the given level.
		// @param fInitial If true, make insertion point at the beginning of the given box's
		// contents; otherwise, select at the end of the contents.
		// @param fRange If true, select everything contained in the given box.
		// @param fInstall If true, install the selection in the root box.
		// @param ppsel Used to return the new selection (may be null if fInstall is true)
		// Note: as of 12 Aug 2006, if unable to make the requested selection, returns S_OK
		// with selection null rather than E_FAIL. This makes for fewer spurious exceptions
		// in C#.
		HRESULT MakeSelInBox(
			[in] IVwSelection * pselInit,
			[in] ComBool fEndPoint,
			[in] int iLevel,
			[in] int iBox,
			[in] ComBool fInitial,
			[in] ComBool fRange,
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// Test whether the click is in a text part of the display. A click beyond the end
		// of a line, an embedded picture or divider box are not considered text. Nor is the
		// space between lines. Basically, it is the area that would be inverted if the text
		// were selected.
		[propget] HRESULT IsClickInText(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[out, retval] ComBool * pfInText);

		// Test whether the click is over a "hot link" in a text part of the display.
		// This is a subset of the area tested by IsClickInText.
		[propget] HRESULT IsClickInObject(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[out] int * podt,
			[out, retval] ComBool * pfInObject);

		[propget] HRESULT IsClickInOverlayTag(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc1,
			[in] RECT rcDst1,
			[out] int * piGuid,
			[out] BSTR * pbstrGuids,
			[out] RECT * prcTag,
			[out] RECT * prcAllTags,
			[out] ComBool * pfOpeningTag,
			[out, retval] ComBool * pfInOverlayTag);

		//:> Event notification methods.

		// Handle typed input consisting of bstrInput, with the following constraints:
		// 1. Selection must be entirely within a single editable property for editing to take place.
		// If the selection is in read-only text nothing is done; if it is a complex range, return E_UNEXPECTED.
		// Caller should normally call DeleteRangeIfComplex first (as a separate UOW) to ensure all is well.
		// 2. bstrInput should not include any control characters, except that it may consist of a single
		// backspace, del, or \r.
		// Typical response is to delete any range that is selected and insert the text.
		// If backspace or del is passed at an IP, delete a character in the appropriate direction.
		// If \r is passed, try to insert a paragraph break.
		// The caller should usually accumulate all current input events before calling this method,
		// but not wait for additional ones if any input is available.
		// Returns the writing system that should be used for subsequent input.
		HRESULT OnTyping(
			[in] IVwGraphics * pvg,
			[in] BSTR bstrInput,
			[in] VwShiftStatus ss,
			[in, out] int * pwsPending);

		// If there is a complex range selection, try to delete it (possibly by calling OnProblemDeletion).
		// Return true if changes were made. If it returns true, indicating changes were made, the caller
		// should end the UOW and make a new one for OnTyping, then combine the two when the OnTyping one
		// is complete.
		HRESULT DeleteRangeIfComplex(
			[in] IVwGraphics * pvg,
			[out] ComBool * pfWasComplex);

		//:> Passing window events to box

		// Inform the box of a key press. Call ${#OnTyping} instead if possible.
		HRESULT OnChar(
			[in] int chw);
		// Inform the box of a 'system' character input, as received through WM_SYSCHAR.
		HRESULT OnSysChar(
			[in] int chw);
		// Inform the box of an 'extended' character input. See ${AfVwRootSite#OnKeyDown}
		// for what keys are currently handled this way, mainly arrow and similar keys.
		// We need to clarify the intent of this message.
		// @param nFlags - bit 0: logical (on) or physical (off) arrow key behavior
		//:> Custom attribute for .NET: PreserveSignature
		[custom("842883D3-DC67-45cf-B968-E763D37A7A19", "true")]
		HRESULT OnExtendedKey(
			[in] int chw,
			[in] VwShiftStatus ss,
			[in] int nFlags);
		// Call every half second or so, at least when the root box is active and needs
		// to flash its insertion point. However, it is preferable to call it anyway,
		// since we may eventually use it for other things that flash (e.g., blinking
		// underline).
		HRESULT FlashInsertionPoint();
		// Call this to inform the box of a mouse down event for the primary mouse button
		// when the shift key is not
		// pressed and the click is not the second half of a double click.
		// @param rcSrc See ${DrawRoot}
		// @param rcDst See ${DrawRoot}
		HRESULT MouseDown(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst);
		// Call this to inform the box of a mouse down event for the primary mouse button
		// when the shift key is not
		// pressed and the click is the second half of a double click.
		// @param rcSrc See ${DrawRoot}
		// @param rcDst See ${DrawRoot}
		HRESULT MouseDblClk(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst);
		// Call this to inform the box of a mouse movement while the primary mouse button
		// is held down.
		// @param rcSrc See ${DrawRoot}
		// @param rcDst See ${DrawRoot}
		HRESULT MouseMoveDrag(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst);
		// Call this to inform the box of a mouse down event for the primary mouse button
		// when the shift key is pressed.
		// @param rcSrc See ${DrawRoot}
		// @param rcDst See ${DrawRoot}
		HRESULT MouseDownExtended(
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst);
		// Call this to inform the box of a mouse up event for the primary mouse button.
		// @param rcSrc See ${DrawRoot}
		// @param rcDst See ${DrawRoot}
		HRESULT MouseUp( //main button
			[in] int xd,
			[in] int yd,
			[in] RECT rcSrc,
			[in] RECT rcDst);

		// Call this when there is a change in the activation state of the root box.
		// Currently this affects how the selection is drawn; see ${VwSelectionState}.
		// Also call this if the input language changes on this root box when it is in
		// focus in order to get Text Services to set its focus.
		HRESULT Activate( // Set the selection state.
			[in] VwSelectionState vss);

		// Gets the current selection state
		[propget] HRESULT SelectionState(
			[out, retval] VwSelectionState * pvss);

		//:> ENHANCE JohnT: methods to inform box of mouse movement when button not clicked, right button activity, ...
		//:> Could we generalize somehow, with an event method, so we can add new kinds of event handling
		//:> without actually having to change the interface?

		//:> Window drawing and size.
		// Call this before drawing or printing. (Its purpose is to fully evaluate any parts of
		// the display that have not been fully generated before trying to draw them.
		// Calling it may be omitted if the view constructor does not use laziness.)
		// It returns a result indicating whether the preparation process forced a change in thumb
		// position, or worse, a change in scroll range that caused the window to be invalidated.
		// A change in thumb position should result in another call to PrepareToDraw, to
		// properly validate drawing at the new position. An invalidate should abort the whole
		// paint operation and the window and start drawing again.
		// @param rcSrc See ${DrawRoot}
		// @param rcDst See ${DrawRoot}
		HRESULT PrepareToDraw(
			[in] IVwGraphics * pvg,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[out, retval] VwPrepDrawResult * pxpdr);

		// Draw the root box at the position indicated by rcSrc and rcDst in pvg.

		// The source and destination rectangles specify a coordinate transformation.
		// There is probably some way to envision the transformation in terms of
		// rectangles, but I have not yet figured it out. Rather, think of the two
		// rectangles together as specifying a transformation between "source" coordinates,
		// where (0,0) is the top left of the root box, and the resolution is that of the
		// IVwGraphics object passed to ${#Layout}. "Destination" coordinates are where the
		// client actually wants the box drawn, that is, the coordinates that should be
		// passed to the (possibly different) IVwGraphics object used here to actually draw it.
		// The client should make sure that the rectangles passed to other methods are exactly
		// the same as those passed to ${DrawRoot} in order to get the correct interpretation
		// of mouse and similar events.

		// The actual transformation is a process defined by the ${Point#Map} and
		// related methods. The source point is moved up and left by the origin of rcSrc.
		// It is then scaled by multiplying by the {height, width} of rcDst and dividing
		// by the {height, width} of rcSrc. Finally, it is moved down and right by the
		// origin of rcDst. The effect is to both scale and translate the point. The advantage
		// of having in effect two translations applied is that one is in each coordinate
		// system. Thus, one can adjust the Destination translation to precisely position
		// the box in the output coordinates (for example, to make a scroll adjustment).
		// We can also make adjustments that are precise in source coordinates (this is mainly
		// used internally in the views code, to adjust for the position of one box relative
		// to another). By making the translations in the appropriate resolution, we avoid
		// rounding errors which can lead to things like a doubled or omitted line of pixels.

		// @param fDrawSel true if selection should be drawn here (only in active pane of split)
		HRESULT DrawRoot(
			[in] IVwGraphics * pvg,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[in] ComBool fDrawSel);
		// Lay the box out so that if possible it will fit in the requested width
		// Must be called before calling ${#Draw}, ${#get_Height}, or $#{get_Width}.
		HRESULT Layout(
			[in] IVwGraphics * pvg,
			[in] int dxsAvailWidth);
		// Get the height of the root box in source cordinates (see ${DrawRoot}).
		[propget] HRESULT Height(
			[out, retval] int * pdysHeight);
		// Get the width of the root box in source cordinates (see ${DrawRoot}).
		[propget] HRESULT Width(
			[out, retval] int * pdxsWidth);

		// This will construct a view to print and make sure all lazy boxes are expanded.
		// @param pvpc print context from which to initialize.
		HRESULT InitializePrinting(
			[in] IVwPrintContext * pvpc);

		// Returns the total number of pages in a print document.
		// @param pvpc print context.
		HRESULT GetTotalPrintPages(
			[in] IVwPrintContext * pvpc,
			[out, retval] int *pcPageTotal);

		// Prints a single page, including header/footer.
		// @param pvpc print context.
		// @param nPageNo page to print.
		HRESULT PrintSinglePage(
			[in] IVwPrintContext * pvpc,
			[in] int nPageNo);

		//:> Store and retrieve containing window.

		// Get the root site which represents the containing window.
		[propget] HRESULT Site(
			[out, retval] IVwRootSite ** ppvrs);

		//:> Focus change

		// Use this to request permission to switch focus away from this root box.
		// The root box may veto the focus change, for example, after performing some validation
		// of a field the user has been editing. If *pfOk is set to false, the caller should
		// SetFocus back to the window containing the root box.
		HRESULT LoseFocus(
			[out, retval] ComBool * pfOk);

		//:> Misc

		// The root box is closing. It should release all referernce counts, especially the
		// reference to its site, to facilitate breaking reference cycles. It is very
		// important to call this when closing a window, because the window and the root box
		// are otherwise guaranteed to form a cycle and cause a memory leak...often a lot of
		// them, because of all the data stored in the root box.
		HRESULT Close();

		// Request notification when the selection changes. The listener will be sent

		// Notify(1, 0) if it moved within the same paragraph.

		// Notify(2, 0) if the selection moved to a different paragraph,

		// Notify(3, 0) if a completely new selection was installed (may be same para or different)

		// Notify(4, 0) if the selection was destroyed (may be followed by another notification
		//		when a new one is created)
		// The integers in the first arguments are members of the VwSelChangeType enumeration.

		// Clean out everything and rebuild the view from scratch. Selections are lost. This is
		// a last resort if some property changed and we are not sure what the consequences
		// should be. It can also be used when the client has made some drastic change, such as
		// a change to a mode or other internal state of the view constructor.
		HRESULT Reconstruct();

		// Send this when the definition of one or more styles has changed within the stylesheet.
		// It recomputes the appearance and layout of all affected text.
		// Review: this is also the method to call when the old writing system properties have
		// changed. Should it be renamed?
		HRESULT OnStylesheetChange();

		// Find out if any non-fatal errors occurred during the drawing process.
		HRESULT DrawingErrors(
			[in] IVwGraphics * pvg);

		// Get the style sheet
		[propget] HRESULT Stylesheet(
			[out, retval] IVwStylesheet ** ppvss);

		// Change the column widths for the first table in the view. This is used in views
		// such as the Advanced Filters dialog to keep view columns in sync with the column
		// header control. Usually, the top-level box in the root is a table. If not, the
		// boxes are traversed until a table is found.

		// ENHANCE JohnT: Currently, the column widths and the table width must be in units of
		// kunPoint1000. Also, when setting column widths, the width of every column in the
		// table must be set. This means cvlen must equal the number of columns in the table.
		// One or both of these restrictions might be removed in the future.
		HRESULT SetTableColWidths(
			[in, size_is(cvlen)] VwLength * prgvlen,
			[in] int cvlen);

		// Ask whether editing has occurred which needs to be checked before losing focus.
		HRESULT IsDirty(
			[out, retval] ComBool * pfDirty);

		// The horizontal location for moving to the next (or previous) field.
		// This is used when an arrow or similar key causes the IP to move from one root box
		// to an adjacent one, for example, in a Data Entry window. We want to find the
		// position where the IP was in the old root box in order to make a new selection in
		// the corresponding place in the new one.
		[propget] HRESULT XdPos(
			[out, retval] int * pxdPos);

		//:> Synchronization support
		// Currently it is not necessary for these to be interface methods.
		// Set the synchronizer that will coordinate this root box being synchronized
		// with others.
		//[propputref] HRESULT Synchronizer(
		//	[in] IVwSynchronizer * psync);
		[propget] HRESULT Synchronizer(
			[out, retval] IVwSynchronizer ** ppsync);
		// Set the actual height to use for the display of the specified object
		// (as a result of synchronization).
		//HRESULT SetActualHeight(
		//	[in] HVO hvoObj,
		//	[in] int dypActualHeight);

		// Retrieve the information set by SetRootObject (or the first one set by SetRootObjects).
		HRESULT GetRootObject(
			[out] HVO * phvo,
			[out] IVwViewConstructor ** ppvwvc,
			[out] int * pfrag,
			[out] IVwStylesheet ** ppss);

		// Similar to DrawRoot, but drawing is limited to lines between ysTop and ysTop
		// + dysHeight in the original layout.
		HRESULT DrawRoot2(
			[in] IVwGraphics * pvg,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[in] ComBool fDrawSel,
			[in] int ysTop,
			[in] int dysHeight);

		// Set the proper keyboard for the given writing system.
		// The reason this method belongs in this interface is that it may use the selection
		// location to place an IME composition window, and most callers know the rootbox
		// explicitly, but not the selection.
		HRESULT SetKeyboardForWs(
			[in] ILgWritingSystem * pws,
			[in, out] BSTR * pbstrActiveKeymanKbd,
			[in, out] int * pnActiveLangId,
			[in, out] int * phklActive,
			[in, out] ComBool * pfSelectLangPending);


		// Get/set the the maximum number of paragraphs to scan looking for editable text.  If
		// we can't find anything editable in this many paragraphs, we'll assume the whole text
		// is read-only.  (This affects cursor movement, which likes to find the editable text
		// closest to where the cursor would land if that particular spot is not editable.)
		// The default is set to 4, but may need to be larger for interlinear texts, or smaller
		// if the entire view really is supposed to be read-only.
		// This value applies to using the cursor movement keys, but not to mouse clicks.
		[propget] HRESULT MaxParasToScan(
			[out, retval] int * pcParas);
		[propput] HRESULT MaxParasToScan(
			[in] int cParas);

		// Do a step of spell-checking the view. Return true if everything (except contents
		// of lazy boxes that have not been expanded) has been checked. One call should be short
		// enough to be performed during idle time without significant impact.
		HRESULT DoSpellCheckStep(
			[out, retval] ComBool * pfComplete);

		// Return true if everything (except contents
		// of lazy boxes that have not been expanded) has been checked. Same result as DoSpellCheckStep(),
		// but does not do any checking; should be VERY fast, enough to have no significant impact
		// when called on every paint, for example.
		HRESULT IsSpellCheckComplete(
			[out, retval] ComBool * pfComplete);

		// Tells whether an IME composition is in progress (e.g., a chinese character is
		// partly typed). Clients should try to avoid committing changes that may destroy
		// and replace the selection while this is the case, since otherwise the composition
		// will be interrupted (e.g., see LT-9929)
		[propget] HRESULT IsCompositionInProgress(
			[out, retval] ComBool * pfInProgress);

		// Tells whether this root box is running a PropChanged. We should not attempt
		// to paint while this is happening, because the changes caused by expanding
		// lazy boxes may conflict with the work being done by the PropChanged.
		[propget] HRESULT IsPropChangedInProgress(
			[out, retval] ComBool * pfInProgress);

		// Restart the spell-checking process (e.g., when turning spelling on or off).
		HRESULT RestartSpellChecking();

		// Pass in the repository that will be used to get spell-checkers.
		HRESULT SetSpellingRepository(
			[in] IGetSpellChecker * pgsp);
	}

#ifndef NO_COCLASSES
	DeclareCoClass(VwRootBox, 705C1A9A-D6DC-4C3F-9B29-85F0C4F4B7BE)
	{
		interface IVwRootBox;
	};
	DeclareCoClass(VwInvertedRootBox, 73BCAB14-2537-4b7d-B1C7-7E3DD7A089AD)
	{
		interface IVwRootBox;
	};
#endif

	/*******************************************************************************************
		Interface IVwViewConstructor
		This interface contains methods to construct fragments of the view. Typically, methods
		are implemented as a switch on the frag argument.

		View constructors are extensively discussed and exemplified in
		fw\doc\guides\Views_User_Guide.htm.

		@h3{When to implement}
		When you want to specify how a network of objects should be represented on the screen,
		and possibly edited.

		@h3{When to use}
		You will usually need to pass an instance of this interface to any IVwRootBox that you
		initialize. You shouldn't call its methods yourself (in fact, you can't, because you
		need an IVwEnv argument and there is no way to get one). The only exception is that
		one call to a Display method might result in recursive calls to Display.

		@h3{How to obtain an instance}
		Make one from your own class, typically using NewObj.

		It may eventually be possible to get various standard view constructors such as StVc
		using CoCreateInstance. This is not yet implemented.

		@H3{Hungarian: vc}
	*******************************************************************************************/
	DeclareInterface(VwViewConstructor, Unknown, 5b1a08f6-9af9-46f9-9fd7-1011a3039191)
	{
		// This is the main display method. The view calls this method to display the top
		// level object(s) in your view, and also when you ask a ${IVwEnv} to
		// ${IVwEnv#AddObjProp} or ${IVwEnv#AddObjVecItems} or ${IVwEnv#AddObj}.
		// @param pvwenv View environment to which you send messages to specify how to display
		// the object.
		// @param hvo The handle to the object to be displayed.
		// @param frag Identifies the "fragment" to be displayed. For root objects, this is
		// the value you passed to ${IVwRootBox#SetRootObjects}. In other cases, it is the
		// frag value you passed to ${IVwEnv#AddObjProp} or ${IVwEnv#AddObjVecItems} or
		// ${IVwEnv#AddObj}
		HRESULT Display(
			[in] IVwEnv * pvwenv,
			[in] HVO hvo,
			[in] int frag);
		// Display the whole of the specified sequence of collection property. This allows
		// the constructor to insert separators, filter or sort the list, and so forth. Called
		// in response to your calling ${IVwEnv#AddObjVec}. Usually, you will retrieve the
		// contents of the specified property from the data source (which you can get from the
		// pvwenv) and display it somehow.
		// @param pvwenv View environment to which you send messages to specify how to display
		// the object.
		// @param hvo The handle to the object to be displayed.
		// @param tag Indicates which property of the object to display. The tag you passed to
		// ${IVwEnv#AddObjVec}.
		// @param frag Identifies the "fragment" to be displayed. This is
		// the value you passed to ${IVwEnv#AddObjVec}
		HRESULT DisplayVec(
			[in] IVwEnv * pvwenv,
			[in] HVO hvo,
			[in] int tag,
			[in] int frag);

		// Display an arbitrary property in a client-defined way. When you call
		// ${IVwEnv#AddProp} the views system reads the property from the data source as a
		// variant and passes it to this method for you to create an ITsString that will be
		// used to display it.

		// Current data access objects can only read properties that are 4-byte or 7-byte
		// integers or simple (not multiple alternative) strings. This could pretty easily be
		// extended when necessary.

		// @H3{Warning} You should either make sure that editing is disabled when you call
		// AddProp, or else implement a version of UpdateProp that can deal with edits to
		// your string (handling the same fragment identifier).

		// @param pvwenv View environment. In this method you will not usually ask it to display
		// other properties, but you might want to retrieve information from it.
		// @param tag
		// @param frag Identifies the "fragment" to be displayed. This is
		// the value you passed to ${IVwEnv#AddProp}
		// @param pptss The string that should be displayed as the value of this property.
		HRESULT DisplayVariant(
			[in] IVwEnv * pvwenv,
			[in] int tag,
			[in] int frag,
			[out, retval] ITsString ** pptss);
		// Display the value val of property tag of object hvo, as requested by a call to
		// AddIntPropPic which passed the fragment identifier frag, by returning a picture
		// (which will be made into a picture box, taking on any properties such as margin or
		// borders that were set before the call to AddIntPropPic).
		HRESULT DisplayPicture(
			[in] IVwEnv * pvwenv,
			[in] int hvo,
			[in] int tag,
			[in] int val,
			[in] int frag,
			[out, retval] IPicture ** ppPict);

		// A property represented by a VC-generated string (returned from DisplayVariant)
		// has been edited by the user. Parse the string and update the property(s).
		// This is called when focus leaves a particular ${#DisplayVarient} property display.
		// Typically it parses ptssVal and attempts to update some prop of hvo in the psda.
		// If there is an
		// error in parsing, the client should notify the user. Afterwards, it may either
		// (1) return an error code, in which case the attempt to take focus away from the
		// property fails; or
		// (2) set pptssRepVal to a valid value which should replace ptssVal. Typically this
		// would be the original value of the property(s), used after the user made a "Cancel"
		// response to the error message.
		// pptssRepVal is used in non-error processing to indicate that normalization
		// has taken place. For example, the parser might be prepared to accept a wide range
		// of date formats, but when focus leaves the item, the display should change to the
		// standard date representation for this view. It may also be used (more rarely) in error
		// processing to indicate that the string should be changed before the user is allowed to
		// go on editing it. If no change is needed, set to null.
		// @param pvwsel the current selection in the root box.
		// @param hvo The current HVO being displayed when AddProp was called; the one whose
		// properties should be modified as a result of parsing the string.
		// @param tag The property identifier passed to AddProp.
		// @param  frag the fragment code passed to DisplayVariant.
		HRESULT UpdateProp(
			[in] IVwSelection * pvwsel,
			[in] HVO hvo,
			[in] int tag,
			[in] int frag,
			[in] ITsString * ptssVal,
			[out, retval] ITsString ** pptssRepVal);

		// This routine is used to estimate the height of an item. The item will be one of
		// those you have added to the environment using AddLazy... Note that the calling code
		// does NOT ensure that data for displaying the item in question has been loaded.
		// You are being asked to estimate how much vertical space is needed to display the item
		// indicated by hvo using the fragment given in the available width.

		// Note: in some cases, being passed an IVwEnv would make it possible to implement
		// this function more easily or accurately. However, we think most implementors would
		// not use it, and it is somewhat computationally expensive to provide it. For now we
		// have therefore decided not to.

		// Because this estimate can usually only be very rough, pixel-level precision is
		// not needed. We have therefore defined the result to be in points, so that it
		// is not dependent on the device resolution. dxAvailWidth is in layout pixels.
		// (Note that it is NOT millipoints, unlike most Views dimensions, as that precision
		// is not required (and also to minimise disruption of older code that expected
		// to return screen pixels at about 96 dpi.)

		// Note: currently this method is only called for the first item in any sequence,
		// and this estimate is applied to all items. So don't invest a lot of work in
		// trying to figure how big a particular item is!

		// Note: this method is included in the interface for use with lazy evaluation.
		// It is not be required unless you call
		// one of the IVwEnv methods that request lazy evaluation. Current view constructors
		// can safely leave it unimplemented and will continue to work.
		HRESULT EstimateHeight(
			[in] HVO hvo,
			[in] int frag,
			[in] int dxAvailWidth,
			[out, retval] int * pdyHeight);

		// Load data needed to display the specified objects using the specified fragment.
		// This is called before attempting to Display an item that has been listed for lazy display
		// using AddLazyItems. It may be used to load the necessary data into the DataAccess object.
		// If you are not using AddLazyItems this method may be left unimplemented.
		// If you pre-load all the data, it should trivially succeed (i.e., without doing anything).
		// @param pvwenv view environment in the state appropriat for the subsequent call to
		// Display for the first item
		// @param prghvo the items we want to display
		// @param chvo the items we want to display
		// @param tag the tag we are going to display
		// @param frag the fragment argument that will be passed to Display to show each of them
		// int ihvoMin the index of the first item in prghvo, in the overall property.

		HRESULT LoadDataFor(
			[in] IVwEnv * pvwenv,
			[in, size_is(chvo)] HVO * prghvo,
			[in] int chvo,
			[in] HVO hvoParent,
			[in] int tag,
			[in] int frag,
			[in] int ihvoMin);

		// In paragraphs created using ${IVwEnv#OpenMappedPara}
		// or ${IVwEnv#OpenMappedTaggedPara} if a string contains an
		// embedded object character (U+FFFC) which has associated with it a string property
		// ktptObjData, the first character of which is kodtNameGuidHot, the view subsystem
		// will replace the object character with a string obtained from this routine.
		// This is typically used to embed in a string a "hot link" to an object whose name
		// must be looked up.

		// You can leave this unimplemented if you don't use OpenMappedPara.
		// @param bstrGuid The GUID obtained from the remainder of the ktptObjData property.
		// This is ALWAYS exactly 8 wchar's long and contains a GUID in
		// binary form; in C++ use (GUID *) bstrGuid to get the GUID.
		// We don't pass a GUID * because we want this interface to be
		// implementable in Visual Basic.
		HRESULT GetStrForGuid(
			[in] BSTR bstrGuid,
			[out, retval] ITsString ** pptss);

		// In paragraphs created using ${IVwEnv#OpenMappedPara}
		// or ${IVwEnv#OpenMappedTaggedPara}, if a string contains an
		// embedded object character (U+FFFC) which has associated with it a string property
		// ktptObjData, the first character of which is kodtNameGuidHot, the view subsystem
		// will replace the object character with a string obtained from ${#GetStrForGuid}.
		// If the user clicks on this string, the system will call DoHotLinkAction to allow
		// you to perform whatever action is appropriate for activating the hot link.

		// @param bstrData The entire string of the ktptObjData property.
		// @param sda The data access for getting the external links folder.
		HRESULT DoHotLinkAction(
			[in] BSTR bstrData,
			[in] ISilDataAccess * psda);

		// Get the object ID that corresponds to this GUID. The default casts the SilDataAccess
		// to a VwOleDbDa and calls its GetIdFromGuid. Return zero if not found.
		HRESULT GetIdFromGuid(
			[in] ISilDataAccess * psda,
			[in] GUID * puid,
			[out, retval] HVO * phvo);

		// This method is called when paragraph layout encounters an ORC with ktptObjectData
		// of type kodtGuidMoveableObjDisp. The layout code first calls GetIdFromGuid to obtain
		// an HVO. It make this the current object of a new VwEnv (embeddinglevel = 0)
		// and calls this method, which may add anything it wishes.
		// The default implementation is planned to handle the case where the GUID identifies
		// a CmPicture, and will insert the picture and its caption.
		// Items inserted are arranged vertically (an inner pile) unless some other flow
		// object is created.
		HRESULT DisplayEmbeddedObject(
			[in] IVwEnv * pvwenv,
			[in] HVO hvo);

		// This method is used to update the text properties for the root box. This method is
		// called prior to the main display method. If multiple view constructors have been
		// passed to the root box, then this method is only called on the first one. If NULL
		// is returned, no changes are made to the text properties.
		HRESULT UpdateRootBoxTextProps(
			[in] ITsTextProps * pttp,
			[out, retval] ITsTextProps ** ppttp);
	}

	// Options for how a selection is scrolled (or made visible) in a view.
	typedef [v1_enum] enum VwScrollSelOpts
	{
		kssoDefault = 1,	// Scroll's a selection into view's nearest edge
							//		(what MakeSelectionVisible used to do).
		kssoNearTop = 2,	// Scroll's selection near top, even if it's visible
							//		(what ScrollSelectionNearTop used to do).
		kssoTop = 3,		// Make the top of the selection visible
// These are some more ideas of possible things to implement some day:
//		kssoBottom = 2, // Make the bottom visible
		kssoBoth = 4, // Make both visible (if possible...otherwise top and as much as possible)
//		kssoCenter = 8, // If scrolling is necessary at all, center sel on screen
	} VwScrollSelOpts;

	/*******************************************************************************************
		Interface IVwRootSite (previously IVwRootContainer)
		IVwRootSite abstracts the notion of the object that contains
		the view. The prototypical implementation is AfVwWnd. Usually the implementation will
		work on an OS-level Window of some sort. However, the view only knows about the
		capabilities here.
		Sometimes, a view may be displayed in more than one place, typically due to split
		windows. In that case, the question arises as to which of them should be regarded as
		the site. Typically, a "composite site" object will be created which is given to the
		root box and represents all the places where it is shown. In such a case, one site
		should be considered primary: typically the one which has the keyboard focus.
		Of the methods below, those without parameters should be sent only to the primary
		site. Of the others, InvalidateRect should definitely go to all. ReleaseGraphics
		should go only to the primary (it pairs with GetGraphics, a primary-only method).
		Tentatively, DoUpdates should go only to the primary (other displays of the root
		can wait to update until the computer is otherwise idle). SizeChanged definitely
		needs to go to all. PropChanged most likely only needs to go to the primary: try
		it that way until we are making enough use of it to tell.

		@h3{When to implement}
		Usually you should not; rather, make a window class that inherits from ${AfVwWnd}.
		${AfVwScrollWnd}, or ${AfVwSplitChild}. If you want to host a view and none of these
		classes is appropriate, implement the interface. You may still find it helpful
		to inherit from ${AfVwRootSite}.

		You may find it helpful to override some of the methods of the interface, particularly
		${#PropChanged}, ${#SizeChanged}, and ${#SelectionChanged}, to get information about
		events occurring within the view.

		@h3{When to use}
		You should not use this interface directly. It is a call-back interface to be used
		by the Views subsystem.

		@h3{How to obtain an instance}
		Create an appropriate Window class and instantiate it in the usual way.

		@h3{Hungarian vvrs}
	*******************************************************************************************/
	DeclareInterface(VwRootSite, Unknown, C999413C-28C8-481c-9543-B06C92B812D1)
	{
		// Request the containing window to arrange for painting of the specified area, which
		// has become invalid. The rectangle is relative to the top left corner of the root box.
		HRESULT InvalidateRect(
			[in] IVwRootBox * pRoot, //the sender
			[in] int xsLeft,
			[in] int ysTop,
			[in] int dxsWidth,
			[in] int dysHeight);
		// Get a graphics object in an appropriate state for drawing and measuring
		// in the view. Also get current coordinate transform rectangles, as passed to the
		// last call to {IVwRootBox@DisplayRoot}.

		// Call ${#ReleaseGraphics} when you are done with the Graphics object.

		// GetGraphics was originally the main way the view code asked for a VwGraphics
		// object and coordinate transformation, back in the days when there was only
		// one current transformation between layout coordinates and screen ones. With
		// the advent of Print Layout view, this is no longer true...a root box may be
		// showing on multiple pages, each involving a different transformation (since
		// there is no distance between the bottom of one page and the top of the next
		// in the view, but there is on the screen). This made the routine problematical,
		// and most View code now uses an alternative method.
		// This routine is now used only in the expansion of lazy boxes. What the client
		// returns therefore mainly impacts the notifications it gets about how things
		// moved as a result of expanding lazy boxes. Ordinary (RootSite and AfVwWnd)
		// sites return their one-and-only coordinate transformation, and their one-and-only
		// screen-resolution VwGraphics. They therefore get 'what changed' notifications
		// relative to the one-and-only screen position. Print Layout views typically pass
		// a printer-resolution VwGraphics (necessary since expanding lazy boxes involves
		// laying the real ones out at printer resolution), and a null coordinate
		// transformation, which results in notifications relative to the whole document
		// at printer resolution. Any other use of this method must be prepared for these
		// two cases.
		HRESULT GetGraphics(
			[in] IVwRootBox * pRoot, //the sender
			[out] IVwGraphics ** ppvg,
			[out] RECT * prcSrcRoot,
			[out] RECT * prcDstRoot);
		// Get a VwGraphics suitable for laying out the view. The correct device resolution
		// for doing layout should be set.
		[propget] HRESULT LayoutGraphics(
			[in] IVwRootBox * pRoot,
			[out, retval] IVwGraphics ** ppvg);
		// Return a Graphics suitable for measuring things on the screen, for example,
		// to get exact character positions as painted. Call ReleaseGraphics
		// when done with it.
		[propget] HRESULT ScreenGraphics(
			[in] IVwRootBox * pRoot,
			[out, retval] IVwGraphics ** ppvg);
		// Get the transform appropriate for the given point in destination coords
		// (typically, screen pixels relative to the top left of the client rectangle).
		HRESULT GetTransformAtDst(
			[in] IVwRootBox * pRoot, //the sender
			[in] POINT pt,
			[out] RECT * prcSrcRoot,
			[out] RECT * prcDstRoot);
		// Get the transform appropriate for the given point in source coords
		// (typically, printer pixels relative to the top left of the whole view).
		HRESULT GetTransformAtSrc(
			[in] IVwRootBox * pRoot, //the sender
			[in] POINT pt,
			[out] RECT * prcSrcRoot,
			[out] RECT * prcDstRoot);

		// Release any resource that were allocated in ${#GetGraphics}, e.g. HDC.
		// NOTE: The caller of ${#GetGraphics} is responsible to call Release on the
		// obtained IVwGraphics object, ReleaseGraphics() is NOT responsible to call
		// Release().
		// NOTE: This behavior is different from previous versions of this method!
		HRESULT ReleaseGraphics(
			[in] IVwRootBox * pRoot, //the sender
			[in] IVwGraphics * pvg);

		// Get the width available for laying things out in the view.

		// ENHANCE JohnT: should this be in the interface, or should the root box
		// just remember the last width passed to its Layout routine?
		HRESULT GetAvailWidth(
			[in] IVwRootBox * pRoot, //the sender
			[out, retval] int * ptwWidth);

		// Cause the immediate update of the display of the root box. This should cause all pending
		// paint operations to be done immediately, at least for the screen area occupied by the
		// root box. It is typically called after processing key strokes, to ensure that the updated
		// text is displayed before trying to process any subsequent keystrokes.
		HRESULT DoUpdates(
			[in] IVwRootBox * pRoot); //the sender

		// Notifies the site that the size of the root box changed; scroll ranges and/or
		// window size may need to be updated.
		HRESULT RootBoxSizeChanged(
			[in] IVwRootBox * pRoot); //the sender

		// This is rather similar to SizeChanged, but is used when the size changed
		// as a result of recomputing something that is invisible (typically about to become
		// visible, but not currently on screen). Thus, the scroll bar range and possibly
		// position need adjusting, but it isn't necessary to actually redraw anything except
		// the scroll bar--unless the scroll position is forced to change, because we were
		// in the process of scrolling to somewhere very close to the end, and the expansion
		// was smaller than predicted, and the total range is now less than the current
		// position.
		// @param dxdSize The change (positive means larger) in the overall size of the
		// root box
		// @param dxdPosition The position where the change happened. In general it may be
		// assumed that if this change is above the thumb position, everything that changed
		// is above it, and it needs to be increased by dydSize; otherwise, everything is below
		// the screen, and no change to the thumb position is needed.
		// @param pfForcedScroll true if there was a forced scroll. In this case, any drawing
		// in progress should be aborted, because a new invalidate of the whole window has
		// occurred.
		HRESULT AdjustScrollRange(
			[in] IVwRootBox * pRoot, //the sender
			[in] int dxdSize,
			[in] int dxdPosition,
			[in] int dydSize,
			[in] int dydPosition,
			[out, retval] ComBool * pfForcedScroll);

		// Notifies the site that something about the selection has changed.
		HRESULT SelectionChanged(
			[in] IVwRootBox * pRoot, //the sender
			[in] IVwSelection * pvwselNew);

		// Notifies the site that something changed about the overlays.
		HRESULT OverlayChanged(
			[in] IVwRootBox * pRoot, //the sender
			[in] IVwOverlay * pvo);

		// Does this kind of window use semi-tagging, ie, text can be highlighted with
		// tag colors and styles, but the tags themselves are not displayed.
		[propget] HRESULT SemiTagging(
			[in] IVwRootBox * pRoot, //the sender
			[out, retval] ComBool *pf);

		// Converts view output coords to absolute screen coordinates.
		HRESULT ScreenToClient(
			[in] IVwRootBox * pRoot, //the sender
			[in, out] POINT * ppnt);

		// Converts absolute screen coordinates to view output coords.
		HRESULT ClientToScreen(
			[in] IVwRootBox * pRoot, //the sender
			[in, out] POINT * ppnt);

		// If there is a pending writing system that should be applied to typing,
		// return it; also clear the state so that subsequent typing will not
		// have a pending writing system until something sets it again.
		// (This is mainly used so that keyboard-change commands can be applied
		// while the selection is a range.)
		HRESULT GetAndClearPendingWs(
			[in] IVwRootBox * pRoot, //the sender
			[out, retval] int * pws);

		// Answer whether boxes in the specified range of destination coordinates
		// may usefully be converted to lazy boxes. Should at least answer false
		// if any part of the range is visible. The default implementation avoids
		// converting stuff within about a screen's height of the visible part(s).
		HRESULT IsOkToMakeLazy(
			[in] IVwRootBox * pRoot, //the sender
			[in] int ydTop,
			[in] int ydBottom,
			[out, retval] ComBool * pfOK);

		// The user has attempted to delete something which the system does not
		// inherently know how to delete. The dpt argument indicates the type of
		// problem.
		// The implementation may choose not to implement this, in which case, a
		// default behavior occurs without reporting an error further up the call
		// chain. The implementation may also fail (e.g., if the selection is too
		// complex even for the root site implementation); again, this will fall
		// back to the default behavior without further error reporting.
		// The current default behavior described in the enumeration VwDelProbType.

		// When this function is called, the selection has already been hidden.
		// The view code will eventually display it again whatever this routine does.

		// The ideal behavior of OnProblemDeletion is to delete what is currently
		// selected, leaving the selection as an insertion point.

		// If OnProblemDeletion establishes a new current selection object, the editing
		// operation originally in progress continues using that selection. Note that,
		// if the new selection is also a problem, another call to OnProblemDeletion
		// could occur. Avoid creating new selections that might result in an infinite
		// loop!

		// See the descriptions of VwDelProbType and VwDelProbResponse for more details.
		HRESULT OnProblemDeletion(
			[in] IVwSelection * psel,
			[in] VwDelProbType dpt,
			[out, retval] VwDelProbResponse * pdpr);

		// This method is called when inserting (typically pasting) whole paragraphs of text into
		// an StText, specifically, when the paragraph-level properties of one of the paragraph(s) to be
		// inserted do not match those of the paragraph it is being inserted into.
		// The material to be pasted is presented as a sequence of paragraphs (each an ITsString
		// plus associated paragraph properties), plus any additional text to be pasted at the end.

		// The default implementation simply returns kidprDefault. This causes the View to go ahead
		// and insert the material as part of the current StText in the usual way (as in WorldPad
		// or Data Notebook).

		// The implementation may also return kidprFail, indicating that it has decided that this text
		// should not be pasted at this location. The implementation should itself handle reporting the
		// error. This causes ReplaceWithTsString to return E_FAIL, which in turn will typically cause
		// containing code to roll back whatever was in progress, including deleting any selected
		// range, which ReplaceWithTsString will have done before calling OnInsertDiffParas.

		// The implementation may also handle the paste itself, inserting the data whereever it ought to
		// go and creating any necessary new structure. In this case, it should create and install a new
		// selection, and return kidprDone.

		HRESULT OnInsertDiffParas(
			[in] IVwRootBox * pRoot, //the sender
			[in] ITsTextProps * pttpDest, // properties of destination paragraph
			[in] int cPara, // number of paragraphs inserted
			[in, size_is(cPara)] ITsTextProps ** prgpttpSrc, // props of each para inserted
			[in, size_is(cPara)] ITsString ** prgptssSrc, // text of each para inserted
			[in] ITsString * ptssTrailing, // Extra text, an incomplete paragraph to insert at end.
			[out, retval] VwInsertDiffParaResponse * pidpr);

		// Singular paragraph version of OnInsertDiffParas.

		HRESULT OnInsertDiffPara(
			[in] IVwRootBox * pRoot, //the sender
			[in] ITsTextProps * pttpDest, // properties of destination paragraph
			[in] ITsTextProps * prgpttpSrc, // props of para inserted
			[in] ITsString * prgptssSrc, // text of para inserted
			[in] ITsString * ptssTrailing, // Extra text, an incomplete paragraph to insert at end.
			[out, retval] VwInsertDiffParaResponse * pidpr);

		// This method is called when the views code is executing IVwSelection::GetSelectionString
		// and encounters an ORC character with properties indicating that it is a link to an 'owned'
		// object...that is, one that should be copied and a new object created if the text is pasted.
		// It requests the root site to create a string representation of the object indicated by
		// the GUID, one that can be passed to MakeObjFromText in order to obtain a copy of the
		// original object suitable for use in a new context to which the text is being copied (or moved).
		// Typically the root site creates an FDO object from the GUID and asks it to MakeTextRep().
		// The resulting string is attached to the ORC as a special property value in the TsString
		// returned by GetSelectionString.
		// The default implementation returns null, resulting in the omission of the ORC from the string
		// returned by GetSelectionString.
		[propget] HRESULT TextRepOfObj(
			[in] GUID * pguid,
			[out, retval] BSTR * pbstrRep);

		// The method is called when the implementation of IVwSelection::ReplaceWithTsString encounters
		// an ORC with the special property indicating an embedded object represented as a string for
		// copying purposes. The textual representation of the object is passed in bstrText, and the place
		// where it is to be inserted (which may influence the ownership of the created object).\
		// It returns the GUID of the newly created object which the ORC in the destination should point to.
		// If the GUID returned is null, the ORC is omitted from the inserted text.
		[propget] HRESULT MakeObjFromText(
			[in] BSTR bstrText,
			[in] IVwSelection * pselDst,
			[out] int * podt,
			[out, retval] GUID * pGuid);

		// Scrolls a selection (making it visible, if necessary) in a view. This should
		// replace the old MakeSelectionVisible and ScrollSelectionNearTop methods.
		HRESULT ScrollSelectionIntoView(
			[in] IVwSelection * psel,
			[in] VwScrollSelOpts ssoFlag,
			[out, retval] ComBool * pfRet);

		// Gets the (focused) rootbox for this rootsite
		[propget] HRESULT RootBox(
			[out, retval] IVwRootBox ** prootb);

		// Gets the (focused) HWND for this rootsite
		[propget] HRESULT Hwnd(
			[out, retval] DWORD * phwnd);

		// Request that a specified selection should be made when the current UOW is complete,
		// specifically, when all PropChanged calls have been made for the UOW.
		// The arguments are as for MakeTextSelection, except that we only include the ones
		// necessary to specify an insertion point, and of course don't return the selection,
		// which typically won't be made until later. The selection made is always installed.
		HRESULT RequestSelectionAtEndOfUow(
			[in] IVwRootBox * prootb,
			[in] int ihvoRoot,
			[in] int cvlsi,
			[in, size_is(cvlsi)] VwSelLevInfo * prgvsli,
			[in] int tagTextProp,
			[in] int cpropPrevious,
			[in] int ich,
			[in] int wsAlt,
			[in] ComBool fAssocPrev,
			[in] ITsTextProps * selProps);
	};

	// Options for how a concordance paragraph is laid out.
	typedef [v1_enum] enum VwConcParaOpts
	{
		kcpoBold = 1, // Make the key word bold
		kcpoAlign = 2, // Align the the key word with dmpAlign
		kcpoDefault = 3, // bold and align
		// ENHANCE JohnT: maybe implement other options, such as number of lines, centering
	} VwConcParaOpts;

	// Display properties overrides
	typedef struct DispPropOverride
	{
		LgCharRenderProps chrp;
		int ichMin;
		int ichLim;
	} DispPropOverride;


	/*******************************************************************************************
		Interface IVwEnv

		An instance of this interface is passed to many of the methods of ${IVwViewConstructor}
		to allow you to make call-backs to the view subsystem, sometimes for information, but
		more usually to tell the subsystem what to display and how to lay it out in order to
		make a particular view of a particular kind of object.

		The methods fall into several groupings. One group, whose names begin Open and Close
		(e.g., ${#OpenParagraph}, ${#CloseParagraph}), delimits "flow objects". That is, they
		tell the view subsystem where to start and end paragraphs, tables, rows, cells,
		Divisions (groups of paragraphs with similar properties), Spans (groups of strings
		with the same properties) and Inner piles (vertically aligned groups of lines within
		a paragraph, used for interlinear text).

		Another group have to do with the logical organization of the data. Typically they
		instruct the system to insert at the current position a certain type of display of a
		certain property of an object. Most of these methods begin with "Add" (e.g.,
		${AddStringProp}).

		Yet another group allow a view constructor to get information about the context where
		an object is displayed. For example, you can get the "data access" object being used
		by the view and read values of other properties; or find out what objects contain the
		one you are displaying, how deeply nested the display is, and so forth.

		@h3{When to implement}
		You should never implement this interface. It is exported by the View subsystem for this
		one particular purpose.

		@h3{When to use}
		Use this interface in the methods of ${IVwViewConstructor} to which it is passed, for
		the purposes outlined above.

		@h3{How to obtain an instance}
		The only way to get an instance of this class is to write an implementation of
		${IVwViewConstructor} and use it in a view. The IVwEnv is passed to you as an argument.

		@h3{Hungarian: vwenv}
	*******************************************************************************************/
	DeclareInterface(VwEnv, Unknown, 92B462E8-75D5-42c1-8B63-84878E8964C0)
	{
		// Display an (atomic) object prop. Calls ${IVwViewConstructor#Display} for the object
		// that is the value of the (atomic) object property. Passes 0 as the HVO of the
		// Display method if the property is empty.
		// @param tag Identifies the property; used to retrieve the value using
		// ${ISilDataAccess#get_ObjectProp}
		// @param pvwvc View constructor that will be sent the Display message to display the
		// object. Usually the caller is a view constructor and will pass 'this', but it
		// is possible for one view constructor to make use of another one.
		// @param frag A value to pass on to the Display method, indicating what kind of
		// display of the object is desired.
		HRESULT AddObjProp(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);
		// Display a vector property. Calls ${IVwViewConstructor#DisplayVec}, passing the
		// current HVO, the tag specified here, and the frag specied here, to the view
		// constructor specified here.
		HRESULT AddObjVec(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);
		// Display a vector property. Calls ${IVwViewConstructor#Display} for each item in
		// the vector, passing the HVO of each item (obtained by passing the HVO and tag to
		// ${ISilDataAccess#get_VecItem}) and the frag specied here, to the view
		// constructor specified here (usually the caller of the method).
		HRESULT AddObjVecItems(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// Display a vector property in reverse order. Calls ${IVwViewConstructor#Display} for
		// each item in the vector, passing the HVO of each item (obtained by passing the HVO
		// and tag to ${ISilDataAccess#get_VecItem}) and the frag specied here, to the view
		// constructor specified here (usually the caller of the method).
		HRESULT AddReversedObjVecItems(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// Display another object, not one of your own properties. Calls
		// ${IVwViewConstructor#Display}, passing the HVO and frag specified here, on the
		// view constructor specified here.

		// Consider using NoteDependency if this part of the display should change when
		// certain properties--e.g., those you used to find the object--change.
		HRESULT AddObj(
			[in] HVO hvo,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// Display a vector property using laziness.
		// Nothing is added to the display immediately, but at some point the views code will call the
		// ${IVwViewConstructor#EstimateHeight} method to find out how high one or more items are.
		// At that time or later, it may call your ${IVwViewConstructor#LoadData} method,
		// followed by the ${IVwViewConstructor#Display} method,
		// for one or more items in the property, as needed.

		// Note: the current flow object MUST be a Div (or the root).
		HRESULT AddLazyVecItems(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// Display a list of items using laziness. Typically, this is used to implement
		// DisplayVec, either of the complete property contents, or a filtered subset.
		// Nothing is added to the display immediately, but at some point the views code will call the
		// ${IVwViewConstructor#EstimateHeight} method to find out how high one or more items are.
		// At that time or later, it may call your ${IVwViewConstructor#LoadData} method,
		// followed by the ${IVwViewConstructor#Display} method,
		// for one or more items in the list, as needed.

		// Note: this method has not been tested and I suspect the implementation is incomplete.
		HRESULT AddLazyItems(
			[in, size_is(chvo)] HVO * prghvo,
			[in] int chvo,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		//:> Generic basic property displays, managed by the VC.

		// Display a property, with the client handling the process of formatting it as a
		// string. (Calls ${IVwViewConstructor#DisplayVariant}, and the resulting
		// string is inserted into the display.) If the user edits the data, then when focus leaves
		// the display of the property, the system calls its ${IViewConstructor#UpdateProp}
		// method. That method is responsible to make an appropriate change to the underlying
		// data, or veto it with an appropriate error message.

		// The variant is obtained by calling ${ISilDataAccess#get_Prop}. Current implementations
		// of ISilDataAcess can only provide variants for 4-byte and 8-byte integers and
		// simple string (ITsString, non-alternation) properties. This could fairly easily be
		// extended if needed.

		// This may eventually also be used for string alts. The Alternation object will get
		// passed as an IUnknown variant.

		// If pvwvc is not prepared to receive an UpdateProp call when the string is edited,
		// be sure to disable editing of this property.
		HRESULT AddProp(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);
		// This is similar to ${#AddProp}, but used where it is necessary to follow a path of
		// properties to get to the desired object/property. The first tag in prgtag
		// indicates an atomic object property of the current open object, the
		// next an atomic object property of the one obtained from the first property,
		// and so on until the last indicates the property that is represented by
		// the string. This last tag (and the corresponding object) is what gets
		// passed to UpdateProp(). If any of the attrs along the path is null, nothing gets added.
		// DisplayVariant is used to display the property (which must be basic).

		// @h3{Note} This method is not yet implemented.
		HRESULT AddDerivedProp(
			[in, size_is(ctag)] int * prgtag,
			[in] int ctag,
			[in] IVwViewConstructor * pvwvc,
			[in] int frag);

		// Inform the view of special dependencies. The current flow object (and anything else
		// that is part of the same object in the same higher level property) needs to be
		// regenerated if any of the listed properties changes.
		HRESULT NoteDependency(
			[in, size_is(chvo)] HVO * prghvo,
			[in, size_is(chvo)] PropTag * prgtag,
			[in] int chvo);

		// Inform the view of special dependencies. The current flow object (and anything else
		// that is part of the same object in the same higher level property) needs to be
		// regenerated if there is a change (from the time where this method is called)
		// in whether it is true that ptssVal is equal to the specified property.
		// It is a multilingual string property if ws is non-zero, otherwise a plain string.
		// Note that this can be VERY much more efficient than using NoteDependency for such
		// conditions, which will regenerate every time the property changes.
		HRESULT NoteStringValDependency(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ws,
			[in] ITsString * ptssVal);

		//:> Inserting basic object property displays into the view.

		// The view looks up the value of the indicated property on the current open
		// object and displays it. The property must be a (non alternation) string property.
		HRESULT AddStringProp(
			[in] int tag,
			[in] IVwViewConstructor * pvwvc);

		// Add a Unicode string property, as if it were a string in the specified WS.
		HRESULT AddUnicodeProp(
			[in] int tag,
			[in] int ws,
			[in] IVwViewConstructor * pvwvc);

		// The view looks up the value of the indicated property on the current open
		// object and displays it as a decimal string. The property must be an integer property.
		HRESULT AddIntProp(
			[in] int tag);

		// The view looks up the value of the indicated property in the current open
		// object and passes it to the view constructor's DisplayPicture method.
		// If nMax is greater than nMin, automatic cycling is performed: clicking on one
		// of the picutes will not make a selection, but will merely increment the
		// specified property (and rotate from nMax to nMin).
		HRESULT AddIntPropPic(
			[in] int tag,
			[in] IVwViewConstructor * pvc,
			[in] int frag,
			[in] int nMin,
			[in] int nMax);
		//:> ENHANCE JohnT: we should have individual methods and default formats
		//:> for more of the basic types.

		//:> String alternations.
		// Add a single, isolated alternative (of the indicated property of the open object).
		HRESULT AddStringAltMember(
			[in] int tag,
			[in] int ws,
			[in] IVwViewConstructor * pvwvc);

		// Add all the alternatives present in the indicated property of the current object,
		// in a default format labelled by writing system tag markers.

		// If the current flow object is a paragraph, the items are separated with a
		// space. If the current flow object is a pile (Div or InnerPile), each
		// alternative (with identifying tag) is a row.

		// ENHANCE JohnT: what controls the order of the encodings?  As found?
		// Alphabetical by enc? Numeric by enc? Need to resolve this before
		// implementing.

		// @h3{Note} This method is not yet implemented.
		HRESULT AddStringAlt(
			[in] int tag);

		// Display the indicated multi-alternative string property of the current object,
		// showing the alternaties specified by the given list of encodings, with ws tags.
		// An ws appears (as an empty string) even if the corresponding alternative is absent.

		// If the current flow object is a paragraph, the items are separated with a
		// space. If the current flow object is a pile (Div or InnerPile), each
		// alternative (with identifying tag) is a row.

		// @h3{Note} This method is not yet implemented.
		HRESULT AddStringAltSeq(
			[in] int tag,
			[in, size_is(cws)] int * prgenc,
			[in] int cws);

		// Add literal text that is not a property and not editable.
		HRESULT AddString(
			[in] ITsString * pss);

		// Add an SilTime property, formatted according to the default user locale.
		// The flags argument is currently interpreted as by
		// ::GetDateFormat, but we may decide to restrict the full range of these
		// options to achieve easier portability. Passing DATE_SHORTDATE
		// is safe.
		HRESULT AddTimeProp(
			[in] int tag,
			[in] DWORD flags);

		// Get the object currently being displayed. (This is the object whose properties
		// will be used by the various Add methods.) Compare ${#OpenObject}.
		HRESULT CurrentObject(
			[out, retval] HVO * phvo);

		// Current open object; null if VC has called AddObjVec and has not yet
		// called AddObj for any of the vector items. Compare ${#CurrentObject},
		// which gives the object owning the vector in that circumstance.
		[propget] HRESULT OpenObject(
			[out, retval] HVO * phvoRet);

		// Get the current embedding level: the number of layers of object we
		// are displaying. The number of outer objects (see ${#GetOuterObject}
		// is one less than this.
		[propget] HRESULT EmbeddingLevel(
			[out, retval] int * pchvo);
		// Get info about outer objects, inside whose display the display of the
		// current object is embedded.

		// The outermost object is returned at level 0. Whatever property of that
		// object the next object is embedded in is returned in *ptag.

		// The index of the next-level object in that property (if it is a vector
		// property) is returned in *pihvo; if not a vector property, that value
		// is always zero. The Level argument may range from 0 to EmbeddingLevel() - 1.

		// Level 0 is one of the top-level objects passed to SetRootObjects.
		HRESULT GetOuterObject(
			[in] int ichvoLevel,
			[out] HVO * phvo,
			[out] int * ptag,
			[out] int * pihvo);
		// Get the data access object in use. This allows the view constructor to get at
		// other properties of the object.
		[propget] HRESULT DataAccess(
			[out, retval] ISilDataAccess ** ppsda);

		// Add a display region whose contents are controlled by the client, which must
		// implement ${IVwEmbeddedWindow}. The mechanism is designed to allow either an
		// embedded window (which gets moves as the view is laid out) or just a region of
		// the larger window which the client draws into.

		// ENHANCE JohnT: can this be implemented reliably? What if the root box is displayed
		// in two places, so we can't just move the embedded Window? (Could we say that it
		// appears in the primary split? Which one is primary?)

		// @param dmpAscent Distance from top of embedded box to baseline for text alignment
		// @param fJustifyRight True if embedded box is last in para and should be right-aligned,
		// as we do with "..." buttons in data entry. (However, that facility is currently
		// implemented a different way).
		// @param fAutoShow True if true view will ensure visibility before drawing.

		// @h3{Note} This method is not yet implemented.
		HRESULT AddWindow(
			[in] IVwEmbeddedWindow * pew,
			[in] int dmpAscent,
			[in] ComBool fJustifyRight,
			[in] ComBool fAutoShow);
		// Add the special little grey box used to separate items in Data Entry lists.
		HRESULT AddSeparatorBar();
		// Insert a simple rectangular box with the specified color, height, and width.
		// @param dmpWidth desired box width, or -1 to fill the available space.
		// @param dmpBaselineOffset positive to raise the box; 0 aligns bottom with baseline
		HRESULT AddSimpleRect(
			[in] int rgb,
			[in] int dmpWidth,
			[in] int dmpHeight,
			[in] int dmpBaselineOffset);

		//:> Delimit layout flow objects

		// Start a group of paragraphs sharing properties.
		HRESULT OpenDiv();
		// End a group of paragraphs sharing properties.
		HRESULT CloseDiv();
		// Start a normal paragraph.
		HRESULT OpenParagraph();
		// Start a paragraph that supports display of tagging, if an overlay is installed in the
		// root box.
		HRESULT OpenTaggedPara();

		// Start a paragraph that supports certain kinds of one-the-fly text substitution.

		// Currently the only type supported is an embedded object character with text
		// property ktptObjData's first character set to kodtNameGuidHot. The system finds
		// a name for the specified object using ${IVwViewConstructor#GetStrForGuid}, and displays
		// that.
		HRESULT OpenMappedPara();

		// Start a paragraph that supports both tagging and mapping.
		HRESULT OpenMappedTaggedPara();

		// Start a paragraph that is intended to be a line in a concordance display.

		// A key word is identified, typically the item being concorded on, and its position is
		// indicated. Typically, the keyword is bold, and gets aligned with a specified position,
		// dmpAlign. Alignment will be left, center, or right, according to the alignment of the
		// paragraph as a whole.

		// (Non-left alignment is not yet implemented.)

		// @param ichMinItem Indicate the position of the item being concorded. Depending
		// on the flags, this item is typically made bold and aligned with dmpAlign
		// @param ichLimItem Indicate the position of the item being concorded. Depending
		// on the flags, this item is typically made bold and aligned with dmpAlign
		// @param cpoFlags indicates whether to bold the key word, and whether to align it.
		// Eventually other flag bits may be supported.
		// @param dmpAlign distance from left of paragraph to align keywords.
		HRESULT OpenConcPara(
			[in] int ichMinItem,
			[in] int ichLimItem,
			[in] VwConcParaOpts cpoFlags,
			[in] int dmpAlign);

		// Start a paragraph that supports overrides
		// @param cOverrideProperties Number of overriden properties
		// @param prgOverrideProperties Array of override properties
		HRESULT OpenOverridePara(
			[in] int cOverrideProperties,
			[in, size_is(cOverrideProperties)] DispPropOverride *prgOverrideProperties);

		// End a paragraph (of any type).
		HRESULT CloseParagraph();

		// Start a pile of paras embedded in another para, for interlinear.
		HRESULT OpenInnerPile();
		// End a pile of paras embedded in another para, for interlinear.
		HRESULT CloseInnerPile();
		// Start a group of sub-para objects sharing properties
		HRESULT OpenSpan();
		// End a group of sub-para objects sharing properties
		HRESULT CloseSpan();
		//:> ENHANCE JohnT: VwLength is used only in three places now. Would it be better to
		//:> just have an int plus a FwTextPropVar?

		// Start a table.
		// @param cCols The number of columns the table will have.
		// @param vlWidth The width of whole table. If the unit is percent, it is relative
		// to the available width for laying out the table.
		// @param mpBorder The thickness of the border drawn around the whole table.
		// This can be overridden by individual cells which explicitly set a border on the
		// relevant side.
		// @param vwalign Default alignment for text in the table (not implemented, I think)
		// @param frmpos Indicates which sides of the table to draw a border all around it.
		// @param vwrule Indicates where to draw lines between cells.
		// @param mpSpacing between cells
		// @param mpPadding between cell border and contents
		// @param fSelectOneCol true to keep the selection in one column, false to use normal
		// selections.
		HRESULT OpenTable(
			[in] int cCols,
			[in] VwLength vlWidth,
			[in] int mpBorder,
			[in] VwAlignment vwalign,
			[in] VwFramePosition frmpos,
			[in] VwRule vwrule,
			[in] int mpSpacing,
			[in] int mpPadding,
			[in] ComBool fSelectOneCol);
		// End a table.
		HRESULT CloseTable();
		// Start a row in a table.
		HRESULT OpenTableRow();
		// End a row in a table.
		HRESULT CloseTableRow();
		// Start a cell in a table.
		// @param nRowSpan Number of rows in the table occupied by the cell
		// @param nColSpan Number of columns in the table occupied by the cell.
		HRESULT OpenTableCell(
			[in] int nRowSpan,
			[in] int nColSpan);
		// End a cell in a table.
		HRESULT CloseTableCell();
		// Start a header cell in a table. Params as in ${#OpenCell}.
		HRESULT OpenTableHeaderCell(
			[in] int nRowSpan,
			[in] int nColSpan);
		// End a header cell in a table.
		HRESULT CloseTableHeaderCell();

		// Specify the width of columns in a table. Should be called after ${#OpenTable} and
		// before ${#OpenTableBody} or ${#OpenTableHeader}. Each call sets the width of a
		// specified number of columns. This should be called enough times (in combination
		// with MakeColumnGroup) to account for all the columns in the table.

		// @param nColSpan Number of columns which have this same width (NOT an index!).
		// @param vlWidth Percent of the overall space available for laying out the table.
		HRESULT MakeColumns(
			[in] int nColSpan,
			[in] VwLength vlWidth);
		// This is like ${#MakeColumns}, except that a "group" of columns ends after the
		// last one whose width is specified using this method. Groups are significant
		// for some options regarding drawing rules between cells; see the vwrule parameter
		// of ${#OpenTable}.
		HRESULT MakeColumnGroup( // width of # cols, group ends after last
			[in] int nColSpan,
			[in] VwLength vlWidth);
		// Start the header section of a table. This is like a body section except that
		// (eventually) in a long printout it will be repeated at the start of each new page.
		HRESULT OpenTableHeader();
		// End the header section of a table.
		HRESULT CloseTableHeader();
		// Start the footer section of a table. Note that this is specified before the body,
		// so that (eventually) we can repeat it at the bottom of each page in a long table,
		// which requires us to know what it is even before we have all the information
		// about the body.
		HRESULT OpenTableFooter();
		// End the footer section of a table.
		HRESULT CloseTableFooter();
		// Start a body section of a table. There may be multiple body sections; each defines
		// a "group" of rows. (Groups are significant
		// for some options regarding drawing rules between cells; see the vwrule parameter
		// of ${#OpenTable}).
		HRESULT OpenTableBody();
		// End a body section of a table.
		HRESULT CloseTableBody();

		// Specify an integer style property to be applied to the next flow object opened.
		//
		// Ignored if a close flow object operation precedes the next open.
		// Adding anything basic (such as a string or int object property, string literal,
		// string alternation, or string generated using AddProp/DisplayVariant)
		// means the property applies as if to a span containing just that text.
		// @param tpt A value from the FwTextPropType enumeration, identifying the property
		// to be set. It should be a property identified as having an integer value.

		// Note: to allow for forwards compatibility, we unrecognized properties are simply
		// ignored.
		// @param tpv A value from the FwTextPropVar enumeration, indicating how to
		// interpret the value. For example, it may be a member of another enumeration,
		// a length in millipoints, a percent of some other distance, a color, etc.
		[propput] HRESULT IntProperty(
			[in] int tpt, // A value from VwStyleProperty denoting property to set.
			[in] int tpv,
			[in] int nValue);

		// Specify a string style property to be applied to the next flow object opened.
		//
		// Ignored if a close flow object operation precedes the next open.
		// Adding anything basic (such as a string or int object property, string literal,
		// string alternation, or string generated using AddProp/DisplayVariant)
		// means the property applies as if to a span containing just that text.
		[propput] HRESULT StringProperty(
			[in] int sp, // A value from VwStyleProperty denoting property to set.
			[in] BSTR bstrValue);

		// Specify a group of properties to be applied to the next flow object opened.
		// All the properties in the TsTextProps are applied in one operation.
		// This is considerably more efficient than ${#put_IntProperty} or
		// ${#put_StringProperty}, especially if the same set of values is used repeatedly.
		//
		// Ignored if a close flow object operation precedes the next open.
		// Adding anything basic (such as a string or int object property, string literal,
		// string alternation, or string generated using AddProp/DisplayVariant)
		// means the property applies as if to a span containing just that text.
		[propput] HRESULT Props(
			[in] ITsTextProps * pttp);

		//:> More informative routines to help with fancy layouts.

		// Gives the height and width required to lay out the given string,
		// using current display properties plus those produced by pttp (which
		// may be null). In other words, this is the amount of space that would
		// be occupied if one currently called putref_Props(pttp); AddString(ptss);
		// (assuming infinite available width).
		// EberhardB: This used to be [propget] and named without get_. However, this results
		// in a TLBIMP warning because we don't specify a [retval], so I renamed it.
		HRESULT get_StringWidth(
			[in] ITsString * ptss,
			[in] ITsTextProps * pttp,
			[out] int * dmpx,
			[out] int * dmpy);

		// Insert a picture along with the specified ws alternative of the caption.
		// Mark it as if it came from the property tag, though we don't actually read data from
		// there (the caller can pass any value that might be useful later to identify something
		// about the picture the user clicked). If the tag argument is not useful, pass ktagNotAnAttr.
		// It is planned that a positive dxmpHeight is a maximum height, negative is an exact
		// height, and 0 means don't specify height (use natural height or determine from
		// width and aspect ratio). Similarly for width.
		// Currently only max height is implemented. Always pass zero for width.
		HRESULT AddPictureWithCaption(
			[in] IPicture * ppict,
			[in] PropTag tag,
			[in] ITsTextProps * pttpCaption,
			[in] HVO hvoCmFile,
			[in] int ws,
			[in] int dxmpWidth,
			[in] int dympHeight,
			[in] IVwViewConstructor * pvwvc);

		// Insert a picture, optionally limiting the height and width.
		// Mark it as if it came from the property tag, though we don't actually read data from
		// there (the caller can pass any value that might be useful later to identify something
		// about the picture the user clicked). If the tag argument is not useful, pass ktagNotAnAttr.
		// It is planned that a positive dxmpHeight is a maximum height, negative is an exact
		// height, and 0 means don't specify height (use natural height or determine from
		// width and aspect ratio). Similarly for width.
		// Currently only max height is implemented. Always pass zero for width.
		HRESULT AddPicture(
			[in] IPicture * ppict,
			[in] PropTag tag,
			[in] int dxmpWidth,
			[in] int dympHeight);

		// Setting a Unicode character that indicates a boundary (e.g. for a paragraph or section).
		HRESULT SetParagraphMark(
			[in] VwBoundaryMark boundaryMark);
		// Called while a paragraph is open, this controls how the view will behave if no
		// content is added to the paragraph before it is closed.
		// Currently the argument must be 1; the only reason to have the argument at
		// all is in the interests of forward compatibility if we think of more behaviors.
		// The default behavior is that the paragraph behaves as if it contained a read-only
		// empty string.
		// The behavior when this method is called (with argument 1) is to make the
		// empty paragraph as nearly as possible invisible.
		HRESULT EmptyParagraphBehavior(
			[in] int behavior);
	};


	/*******************************************************************************************
		Interface IVwEmbeddedWindow
		This interface is designed to allow a client to take control of an area of the display
		within a view. Support for doing this is not yet implemented, however.

		Two approaches are intended to be supported. In one approach, the embedded screen area
		is a full host-system window, which receives independent window events and so forth.
		In this case, when the view code would normally draw the contents of this screen area,
		it instead just sends a message to make sure the host window is in the expected place.
		An unsolved problem with this approach is that the view may be in a split window, in
		which case the embedded window needs to be drawn in two places. A tentative solution
		is to really put the window in the pane that has focus, and add to this interface a
		requirement for the embedded window to be able to draw itself in an inactive state in
		the other pane.

		In the second approach, the embedded area is drawn on the view's own window. In this
		case the ${#DrawWindow} method is called to draw the contents of the client-controlled
		area. The problem with this approach is that there is currently not much scope for the
		client-controlled area to revceive event notifications.

		@h3{When to implement}
		Implement this interface (once there is support for it) when you want to put something
		of your own, not supported natively by the view subsystem, within a view.

		@h3{When to use}
		Pass an instance of this interface to {IVwEnv#AddWindow} to produce this sort of
		embedding.

		@h3{How to obtain an instance}
		The only way to get an instance of this class is to write an implementation of
		${IVwViewConstructor} and use it in a view. The IVwEnv is passed to you as an argument.

		@h3{Hungarian: vwenv}
	*******************************************************************************************/
	DeclareInterface(VwEmbeddedWindow, Unknown, f6d10646-c00c-11d2-8078-0000c0fb81b5)
	{
		// This message is sent when the Views subsystem is drawing its contents. (You might
		// rather expect it to be sent when the View subsystem is laying itself out, but
		// events such as scrolling move the window contents without requiring a new layout.)
		// Lightweight clients should save the position. Those with a host window should
		// move it to the indicated location, which is in the coordinate system used to draw
		// in the IVwGraphics.
		HRESULT MoveWindow(
			[in] IVwGraphics* pvg,
			[in] int xdLeft,
			[in] int ydTop,
			[in] int dxdWidth,
			[in] int dydHeight);

		// Lightweight components should answer true. Heavyweight ones should answer true if
		// the host window is currently visible. (This does not necessarily mean that it is at
		// a scroll position that would make it actually visible, just that it is in the
		// visible state.)
		[propget] HRESULT IsWindowVisible(
			[out, retval] ComBool* pfRet);
		// Lightweight components ignore. Heavyweight components should do whatever is needed
		// to set the visibility state to true. ${#IsWindowVisible} should henceforth answer
		// true.
		HRESULT ShowWindow();
		// Heavyweight components should ignore this message. Lightweight ones should draw
		// themselves (using the rectangle previously transmitted using MoveWindow).

		// ENHANCE JohnT: should we instead pass the coordinates to this message?
		HRESULT DrawWindow(
			[in] IVwGraphics* pvg);
		// Get the width that the component needs in order to draw itself.

		// ENHANCE JohnT: should we support embedded windows which can adjust their size
		// to an available width?
		[propget] HRESULT Width(
			[out, retval] int* pnTwips);
		// Get the height that the component needs in order to draw itself.
		[propget] HRESULT Height(
			[out, retval] int* pnTwips);
	};

	/*******************************************************************************************
		Interface IVwSelection
		Represents a selection of something within the view.

		@h3{Note} I have attempted to make this a dual interface, as it seemed the kind of
		information that might be useful to macro languages. However, many of the methods have
		arguments that are not compatible with the OleAutomation property. I have marked these
		methods local; despite this, MIDL generates a warning message which I have not been
		able to prevent.

		@h3{Warning} These objects must not be retained or used after anything in the view is
		changed. Doing so could lead to program crashes.

		@h3{When to implement}
		Don't. Only the implementation in the view subsystem itself is useful.

		@h3{When to use}
		When you want information about what is selected.

		@h3{How to obtain an instance}
		Use the ${IVwRootBox#get_Selection} method.

		@h3{Hungarian: vwsel}
	*******************************************************************************************/
	DeclareInterface(VwSelection, Unknown, 4F8B678D-C5BA-4a2f-B9B3-2780956E3616)
	{
		// Answer true if the selection is a range (as opposed to an insertion point).
		[propget] HRESULT IsRange(
			[out, retval] ComBool* pfRet);
		// Get a sequence of TsTextProps, one for each range in the current selection.
		// If the current selection is an insertion point return one text props,
		// the one that will currently be used for an inserted character.
		// If the selection is not a text selection at all return 0 objects.
		// Also get a sequence of VwPropertyStores, which can be used to determine the
		// actual property values that will be used.

		// @h3{Note} The caller gets a reference count on EACH ttp and vps
		// object. You should normally call once with zero cttpMax to get the size,
		// then again with a ComVector<ITsTextProps>. For example,

		//	int cttp;
		//	ComVector<ITsTextProps> vqttp;
		//	ComVector<IVwPropertyStore> vqvps;
		//	CheckHr((*ppvwsel)->GetSelectionProps(0, NULL, NULL, &cttp));
		//	vqttp.Resize(*pcttp);
		//	vqvps.Resize(*pcttp);
		//	CheckHr((*ppvwsel)->GetSelectionProps(*pcttp, (ITsTextProps **)vqttp.Begin(),
		//		(IVwPropertyStore **)vqvps.Begin(), &cttp));

		// The TsTextProps returned for each run is the one actually stored in the string.
		// Hence, it doesn't reflect the properties actually used to display the text,
		// but only the writing system/ows information plus any "hard formatting" overrides.
		// It is intended to indicate the starting point for any modifications to be made
		// to the run.
		// The VwPropertyStore returned for each run IS the one actually used to
		// display it, and thus reflects the net effect of defaults, styles,
		// any formatting explicitly set by the view constructor, AND the hard
		// formatting overrides. It is intended to be used to find out things like
		// "is this text actually displayed in bold, after combining all the things
		// that might influence that".
		// ENHANCE JT: investigate whether there is a safe way to call this from VB, getting
		// the ref counts right.
		HRESULT GetSelectionProps(
			[in] int cttpMax,
			[in, out, size_is(cttpMax)] ITsTextProps ** prgpttp,
			[in, out, size_is(cttpMax)] IVwPropertyStore ** prgpvps,
			[out] int * pcttp);

		// Like GetSelectionProps, except that the prgpvpsSoft items include all formatting
		// MINUS the hard formatting in the text properties (ie, those derived by the
		// view constructor and styles).
		HRESULT GetHardAndSoftCharProps(
			[in] int cttpMax,
			[in, out, size_is(cttpMax)] ITsTextProps ** prgpttpSel,
			[in, out, size_is(cttpMax)] IVwPropertyStore ** prgpvpsSoft,
			[out] int * pcttp);


		// Get the paragraph-level properties of the selected paragraph(s).
		// Note that, unlike character level properties, we can only read the actual state
		// of the paragraphs (IVwPropertyStore), not the TsTextProps that produced them.
		// In fact, it is only in StText or something similar that each paragraph has an
		// associated TsTextProps. However, we can get the actual properties.
		// The paragraph properties are gotten by running through the root sequence until
		// we have gotten the properties for each paragraph.
		// ENHANCE (JohnT):we could possibly give this method an argument, or add another interface
		// method, or even change the default meaning, so that it will refuse to look for
		// paragraphs nested inside other paragraphs, or something like that. I have a feeling
		// that might actually be more useful than our current proposed behavior if we were
		// using this in a context of embedded paragraphs. But it will then be tricky to define
		// what it should do if one or both endpoints is in an embedded paragraph. At present
		// I can't think what it should do in such a case if embedded paragraphs are not allowed,
		// so I don't think we should attempt this restriction yet.

		// The caller DOES get a reference count on each property store.
		HRESULT GetParaProps(
			[in] int cttpMax,
			[in, out, size_is(cttpMax)] IVwPropertyStore ** prgpvps,
			[out] int * pcttp);

		// Review (SharonC): This method is probably not needed as an interface method,
		// because it doesn't use anything internal to the implementation of the property
		// store.
		// EberhardB: Answer: We need it to be able to apply styles.
		HRESULT GetHardAndSoftParaProps(
			[in] int cttpMax,
			[in, size_is(cttpMax)] ITsTextProps ** prgpttpPara,
			[in, out, size_is(cttpMax)] ITsTextProps ** prgpttpHard,
			[in, out, size_is(cttpMax)] IVwPropertyStore ** prgpvpsSoft,
			[out] int * pcttp);

		// Update the properties of the selected text.

		// An item is typically passed in for each TsTextProps previously returned by a
		// call to GetSelectionProps. A null in the array passed here means do not
		// change the properties for that range. A Ttp means change properties to that.
		// The size of the array should exactly match that returned by GetSelectionProps.
		HRESULT SetSelectionProps(
			[in] int cttp,
			[in, size_is(cttp)] ITsTextProps ** prgpttp);

		// Get information about one end of a selection. See fw\doc\guides\Views_User_Guide.htm
		// section 6 for a discussion of selections and the kinds of information available
		// about them.

		// @param fEndPoint Pass true to get info about end point, false for anchor.
		// @param pptss The string containing the indicated selection end
		// @param pich The offset into string
		// @param pfAssocPrev  indicates whether a selection is considered to be
		// before or after the indicated end point. Thus, for a range, it is false
		// at the start of the range and true at the end. For an insertion point,
		// it is the same for anchor and end point, and indicates whether the selection
		// is primarily considered to come after the preceding character (true) or before
		// the following one (false). This is important in deciding things like which
		// character properties apply.
		// @param phvoObj The object to which the string belongs (or 0 if none)
		// @param ptag The tag of the property to which the string belongs
		// @param pws Identifies which alternative, if prop is an alternation.
		HRESULT TextSelInfo(
			[in] ComBool fEndPoint,
			[out] ITsString ** pptss,
			[out] int * pich,
			[out] ComBool * pfAssocPrev,
			[out] HVO * phvoObj,
			[out] PropTag * ptag,
			[out] int * pws);

		// Indicate how many levels of nesting of (object, property) contain the selection,
		// including the basic property that terminates the chain.
		HRESULT CLevels(
			[in] ComBool fEndPoint, // true for end point, false for anchor
			[out, retval] int * pclev);

		// Returns info about nth level. Level 0 returns the same hvoObj and ptag as
		// ${#TextSelInfo}. Level 1 is the object/prop that contains hvoObj[0].
		// Level 2 is the object/prop that contains hvoObj[1]. And so forth.
		// The ihvo returned for level n is the zero-based index of hvoObj[n-1] in prop
		// tag[n] of hvoObj[n]. It is always 0 for index 0.

		// The pcpropPrevious argument is sometimes useful in the rare cases where,
		// within a display of a certain object, the same property is displayed more
		// than once. For example, within the display of a book, we might display the
		// sections once using a view that shows titles to produce a table of contents,
		// then again to produce the main body of the book. cpropPrevious indicates
		// how many previous occurrences of property tag there are in the display of hvoObj,
		// before the one which contains the indicated end point.

		// The pvps is the display properties used by default for everything in this
		// property.
		// @param fEndPoint Pass true to get info about end point, false for anchor.
		HRESULT PropInfo(
			[in] ComBool fEndPoint,
			[in] int ilev,
			[out] HVO * phvoObj,
			[out] PropTag * ptag,
			[out] int * pihvo,
			[out] int * pcpropPrevious,
			[out] IVwPropertyStore ** ppvps);

		// This obtains all the information needed to re-create a text selection.
		// The exact nature of the information is documented in the
		// $IVwRootBox#MakeTextSelection} method.

		// Although MakeTextSelection cannot (yet) create a picture selection, we can retrieve some
		// information about picture selections using this method.
		// If the selection is not in any kind of text (say a picture), it is still in some property
		// (indicated by tagTextProp and cpropPrevious) of the object indicated by ihvoRoot and
		// the VwSelLevInfo objects in prgvsli. In this case, ichAnchor and ichEnd are set to -1,
		// ws is 0, fAssocPrevious is (arbitrarily) true, ihvoEnd is -1.

		// Note that the number of VwSelLevInfo objects created here is one less
		// than the number returned by #{@CLevels}, since the latter includes the
		// terminating string property.
		HRESULT AllTextSelInfo(
			[out] int * pihvoRoot,
			[in] int cvlsi,
			[out, size_is(cvlsi)] VwSelLevInfo * prgvsli,
			[out] PropTag * ptagTextProp,
			[out] int * pcpropPrevious,
			[out] int * pichAnchor,
			[out] int * pichEnd,
			[out] int * pws,
			[out] ComBool * pfAssocPrev,
			[out] int * pihvoEnd,
			[out] ITsTextProps ** ppttp);

		// Like AllTextSelInfo, but used to obtain information about one endpoint of an
		// arbitrary selection that is not necessarily within a single text field.
		// ppttp is the same as from AllTextSelInfo if the selection is an IP.
		// If it is a range, it is the props of the selected character closest to the
		// indicated end of the selection (e.g., the first character if fEndPoint is
		// false and the anchor is before the end point).
		// In pathological cases where the selection is not an IP, but no characters
		// are selected (e.g., from end of one paragraph to start of next), *ppttp
		// is set to null. (These are the same cases where GetSelectionProps returns
		// an empty array of properties.)
		HRESULT AllSelEndInfo(
			[in] ComBool fEndPoint,
			[out] int * pihvoRoot,
			[in] int cvlsi,
			[out, size_is(cvlsi)] VwSelLevInfo * prgvsli,
			[out] PropTag * ptagTextProp,
			[out] int * pcpropPrevious,
			[out] int * pich,
			[out] int * pws,
			[out] ComBool * pfAssocPrev,
			[out] ITsTextProps ** ppttp);

		// This is like Commit, it completes any edits in progress on the selected string
		// and writes them to the database (if any).
		// However, unlike Commit, it does NOT broadcast PropChanged notifications.
		// Instead, it returns to the client the information about the needed notification.
		// Typically the client will send the notification later.
		HRESULT CompleteEdits(
			[out] VwChangeInfo * pci,
			[out, retval] ComBool * pfOk);

		// Extend the selection to include the entire range of the string or strings.
		HRESULT ExtendToStringBoundaries();

		// Indicate whether the anchor is at the bottom/right (or left if RtoL) of the selection
		[propget] HRESULT EndBeforeAnchor(
			[out, retval] ComBool * pfRet);

		// Given the same first three arguments as used to draw the root box, indicate where the
		// selection is drawn. prdPrimary will be set to a rectangle in destination coords
		// that bounds the selection as closely as possible; if there is a split cursor,
		// prdSecondary gives the place where the secondary is drawn, and pfSplit is true.
		// pfEndBeforeAnchor is true if the anchor is at the bottom/right of the selection.
		HRESULT Location(
			[in] IVwGraphics * pvg,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[out] RECT * prdPrimary,
			[out] RECT * prdSecondary,
			[out] ComBool * pfSplit,
			[out] ComBool * pfEndBeforeAnchor);

		// If the selection is part of one or more paragraphs, return a rectangle that
		// contains those paragraphs. Otherwise fail.

		// The rectangle is in the drawing coordinates appropriate for
		// a VwGraphics obtained by calling the selection's root box's
		// site's ${IVwRootSite#GetScreenGraphics} method, corrected for
		// the coordinate transformation obtained from GetGraphicsAtSrc(),
		// passing the top left of the first paragraph. In other words, for a multi-page
		// selection, it is the space the paragraph would occupy if the page containing
		// its top left corner were infinitely long.

		// Enhance: possibly for a multi-page selection, we would get a more useful
		// result by converting the top left corner and bottom right corner to screen
		// coordinates, using for each the conversion for the page it is on. However,
		// nothing in Print Layout currently uses this method.

		HRESULT GetParaLocation(
			[out] RECT * prdLoc);

		// Replace what is selected with a TsString.
		// If the string contains newlines, the properties associated with the Newline become
		// the paragraph properties, if it is possible to make new paragraphs at the current
		// selection. Otherwise, newlines are stripped out.
		HRESULT ReplaceWithTsString(
			[in] ITsString * ptss);

		// Get a copy of the selection as a TsString. The separator argument indicates that
		// text to insert for non-text items.
		HRESULT GetSelectionString(
			[out] ITsString ** pptss,
			[in] BSTR bstrSep );

		// Get a copy of the first paragraph of selected text as a TsString. The separator
		// argument indicates that text to insert for non-text items.
		// Return a boolean indicating whether we got the whole selection.
		HRESULT GetFirstParaString(
			[out] ITsString ** pptss,
			[in] BSTR bstrSep,
			[out] ComBool * pfGotItAll );

		// Move the selection to the indicated location if it is an insertion point.
		HRESULT SetIPLocation(
			[in] ComBool fTopLine,
			[in] int xdPos);

		// Determine whether the Format Paragraph command can be applied to the current
		// selection. Currently requires that it be in an StTxtPara object.
		[propget] HRESULT CanFormatPara(
			[out, retval] ComBool * pfRet);
		// Determine whether the Format Characters command can be applied to the current
		// selection. Requires it to be editable text.
		[propget] HRESULT CanFormatChar(
			[out, retval] ComBool * pfRet);
		// Determine whether the Format Overlay command can be applied to the current
		// selection. Requires it to be editable text in a paragraph displaying overlays.
		[propget] HRESULT CanFormatOverlay(
			[out, retval] ComBool * pfRet);
		// Install yourself as the active selection in your root box.
		HRESULT Install();
		// Answer true if this selection follows (comes after in the view) the argument.
		// False if they are exactly the same position.
		[propget] HRESULT Follows(
			[in] IVwSelection * psel,
			[out, retval] ComBool * pfFollows);
		// Return true if selection is still valid. Any editing or data changes that affect
		// properties in the root box might change this; check if in doubt.
		[propget] HRESULT IsValid(
			[out, retval] ComBool * pfValid);
		// Get the character offset of the anchor (if fEndPoint is false) or the end point
		// (if fEndPoint is true) in whatever paragraph each occurs.
		// Note that this is relative to the paragraph as a whole, not the particular
		// string property.
		[propget] HRESULT ParagraphOffset(
			[in] ComBool fEndPoint,
			[out, retval] int * pich);
		// Get whether this selection is associated with the previous character (only valid for text selections which are insertion points).
		[propget] HRESULT AssocPrev(
			[out, retval] ComBool * pfValue);
		// Set whether this selection is associated with the previous character (only valid for text selections which are insertion points).
		// This also clears any cached selection props. This is primarily needed to allow an application to associate the selection in the
		// non-default selection in certain circumstances when notified of a new selection via SelectionChanged, so this method will *not*
		// issue a SelectionChanged event.
		[propput] HRESULT AssocPrev(
			[in] ComBool fValue);
		// Get the selection type.
		[propget] HRESULT SelType(
			[out, retval] VwSelType * piType);
		// Get the root box that this selection belongs to.
		[propget] HRESULT RootBox(
			[out, retval] IVwRootBox ** pprootb);
		// Get a selection equivalent to this but grown to a whole word.
		// Currently does nothing if selection is not an IP. May enhance to
		// grow to nearest boundary. Will not grow beyond confines of one
		// string property.
		HRESULT GrowToWord(
			[out, retval] IVwSelection ** ppsel);
		// Get a selection equivalent to the anchor or end point of the current selection.
		HRESULT EndPoint(
			[in] ComBool fEndPoint,
			[out, retval] IVwSelection ** ppsel);
		// Arrange that subsequent typing (as long as it occurs before the selection is moved)
		// will create text with the specified properties. (This is no longer limited to an
		// insertion point.) This method will *not* issue a SelectionChanged event.
		HRESULT SetTypingProps(
			[in] ITsTextProps * pttp);

		// Get the depth of box embedding in the layout for either the anchor or end point.
		[propget] HRESULT BoxDepth(
			[in] ComBool fEndPoint,
			[out, retval] int * pcDepth);

		// Get the index of the selection's box at the given depth, for either the anchor or
		// the end point.
		[propget] HRESULT BoxIndex(
			[in] ComBool fEndPoint,
			[in] int iLevel,
			[out, retval] int * piAtLevel);

		// Get the number of boxes in the layout at the given depth.
		[propget] HRESULT BoxCount(
			[in] ComBool fEndPoint,
			[in] int iLevel,
			[out, retval] int * pcAtLevel);

		// Get the type of the selection's box at the given depth, for either the anchor or
		// the end point.
		[propget] HRESULT BoxType(
			[in] ComBool fEndPoint,
			[in] int iLevel,
			[out, retval] VwBoxType * pvbt);

		// Answer whether it is possible to edit at (the anchor of) the selection, specifically,
		// whether typing would be able to insert a character at an IP at the anchor.
		[propget] HRESULT IsEditable(
			[out, retval] ComBool * pfEditable);

		// Return true if selection is enabled, otherwise false. Being enabled depends on the
		// selection state and wether it's a range selection or not (see ${VwSelectionState}).
		[propget] HRESULT IsEnabled(
			[out, retval] ComBool * pfEnabled);
	};

	// A style may be one of two possible style types - Paragraph or Character.
	typedef [v1_enum] enum StyleType
	{
		kstParagraph = 0,
		kstCharacter,
		kstLim
	} StyleType;


	/*******************************************************************************************
		Interface IVwStylesheet
		Represents a style sheet expressed as a collection of named TsTextProps objects.

		@h3{When to implement}
		Usually you will use a standard implementation. It may be useful to make your own
		subclass of ${AfStyleSheet}, with a custom data source. Or, you could make your own if
		you want a completely different way of managing styles.

		@h3{When to use}
		The main use is to pass as an argument to ${IVwRootBox#SetRootObjects}, thus specifying
		what named styles mean within a particular view.

		@h3{How to obtain an instance}
		Use NewObj on ${AfStyleSheet} (or a subclass). A common case is to create an
		${AfDbStylesheet} and initialize it with the information in the database about the
		stylesheet for a particular language project.

		@h3{Hungarian: vss}
	*******************************************************************************************/
	DeclareInterface(VwStylesheet, Unknown, D77C0DBC-C7BC-441d-9587-1E3664E1BCD3)
	{
		// Gets the name of the default paragraph style to use as the base for new styles
		// (Usually "Normal")
		HRESULT GetDefaultBasedOnStyleName(
			[out, retval] BSTR * pbstrNormal);

		// Gets the style name that is the default style to use for the given context
		HRESULT GetDefaultStyleForContext(
			[in] int nContext,
			[in] ComBool fCharStyle,
			[out, retval] BSTR * pbstrStyleName);

		// Put the DEFINITION of a style--that is, the properties that are explicitly set
		// for this style, excluding inherited items.
		HRESULT PutStyle(
			[in] BSTR bstrName,
			[in] BSTR bstrUsage,
			[in] HVO hvoStyle,
			[in] HVO hvoBasedOn,
			[in] HVO hvoNext,
			[in] int nType,
			[in] ComBool fBuiltIn,
			[in] ComBool fModified,
			[in] ITsTextProps * pttp);
		//:> ENHANCE EberhardB: Add parameter for usage

		// Retrieve the EFFECT of a style--that is, the net effect of the named style
		// and everything it inherits from. (That is, all the modifications they make
		// to the overall system defaults--it does not have to include every possible property.)
		// If there is no such name recored, set ppttp to NULL and return S_FALSE.
		// Comparisons are case sensitive (A != a).
		HRESULT GetStyleRgch(
			[in] int cch,
			[in, size_is(cch)] OLECHAR * prgchName,
			[out, retval] ITsTextProps ** ppttp);

		// Retrieve the name of the style that should be applied to the next paragraph,
		// if Enter is pressed when the selection is an IP at the end of a paragraph
		// that has the named paragraph style bstrName.
		// @error E_INVALIDARG if the name is not the name of a valid style.
		HRESULT GetNextStyle(
			[in] BSTR bstrName,
			[out, retval] BSTR * pbstrNext);
		// Retrieve the name of the style on which bstrName is based.
		// @error E_INVALIDARG if the name is not the name of a valid style.
		HRESULT GetBasedOn(
			[in] BSTR bstrName,
			[out, retval] BSTR * pbstrBasedOn);
		// Retrieve information about whether bstrName is a character or paragraph style.
		// The result is a member of the ${StyleType} enumeration (this should probably
		// be moved to this IDH file?), that is, kstParagraph or kstCharacter.
		// We could have used a boolean, but were not entirely sure we would never have
		// more types. Also,the enumeration makes it clear what each means.
		// @error E_INVALIDARG if the name is not the name of a valid style.
		HRESULT GetType(
			[in] BSTR bstrName,
			[out, retval] int * pnType);

		// Retrieve the "context" of the style.
		// The result is a context, the meaning of whose value is application-specific.
		// Context 0 means general, or undefined.
		// @error E_INVALIDARG if the name is not the name of a valid style.
		HRESULT GetContext(
			[in] BSTR bstrName,
			[out, retval] int * pnContext);

		// Sets the pfBuiltIn parameter to true if the style is a predefined style
		// @error E_INVALIDARG if the name is not the name of a valid style.
		HRESULT IsBuiltIn(
			[in] BSTR bstrName,
			[out, retval] ComBool * pfBuiltIn);

		// Sets the pfModified parameter to true if the (built-in) style was modified by the user
		// @error E_INVALIDARG if the name is not the name of a valid style.
		HRESULT IsModified(
			[in] BSTR bstrName,
			[out, retval] ComBool * pfModified);

		// ENHANCE EberhardB: Add method for usage

		// Return the associated Data Access object in which the style definitions are stored.
		// ENHANCE JohnT: get rid of this! It is currently needed in practice, but has no good
		// place in this interface. An IVwStyleSheet does not HAVE to be stored in an ISilDataAccess.
		[propget] HRESULT DataAccess(
			[out, retval] ISilDataAccess ** ppsda);

		// Return an HVO for a newly created style.
		HRESULT MakeNewStyle(
			[out, retval] HVO * phvoNewStyle);

		// Remove style.
		HRESULT Delete(
			[in] HVO hvoStyle);
		// Get the total number of styles in the style sheet.
		[propget] HRESULT CStyles(
			[out, retval] int * pcttp);
		// Get the HVO of the Nth style (in an arbitrary order).
		[propget] HRESULT NthStyle(
			[in] int ihvo,
			[out, retval] HVO * phvo);

		// Get the Name of the Nth style (in an arbitrary order).
		[propget] HRESULT NthStyleName(
			[in] int ihvo,
			[out, retval] BSTR * pbstrStyleName);

		// A special style that contains only the parts of "Normal" that relate to the Font tab.
		// This is automatically maintained as "Normal" is edited.  If there is no "Normal" style,
		// sets *ppttp to NULL. This is not currently considered an error.
		[propget] HRESULT NormalFontStyle(
			[out, retval] ITsTextProps ** ppttp);

		// Return true if the given style is one that is protected within the style sheet.
		[propget] HRESULT IsStyleProtected(
			[in] BSTR bstrName,
			[out, retval] ComBool * pfProtected);

		// Cache a new value for the properties of the specified style, without writing it
		// out anywhere or marking the style as 'dirty'. This is typically used when making
		// explicit the implicit default values of 'Normal', which should not lead to an
		// undoable action.
		HRESULT CacheProps(
			[in] int cch,
			[in, size_is(cch)] OLECHAR * prgchName,
			[in] HVO hvoStyle,
			[in] ITsTextProps * pttp);


		// ENHANCE JohnT: add the following:
#if 0
		// ENHANCE JohnT: we probably also need a method to retrieve a style defn.

		// Put the DEFINITION of a style--that is, the properties that are explicitly set
		// for this style, excluding inherited items.
		[propput] HRESULT Style(
			[in] BSTR bstrName,
			[in] ITsTextProps * pttp);
		// Retrieve the EFFECT of a style--that is, the net effect of the named style
		// and everything it inherits from. (That is, all the modifications they make
		// to the overall system defaults--it does not have to include every possible property.)
		[propget] HRESULT Style(
			[in] BSTR bstrName,
			[out, retval] ITsTextProps ** ppttp);
		// Retrieve all styles
		HRESULT GetStyle(
			[in] int ittp,
			[out] BSTR * pbstrName,
			[out] ITsTextProps ** ppttp);
		// Remove style
		HRESULT Delete(
			[in] BSTR bstrName);
#endif
	};
#ifndef NO_COCLASSES
	DeclareCoClass(VwStylesheet, CCE2A7ED-464C-4ec7-A0B0-E3C1F6B94C5A)
	{
		interface IVwStylesheet;
	};
#endif

	/*******************************************************************************************
		Interface IVwPropertyStore
		This interface provides some information about the actual values of properties used
		to render text.

		There is a lot more functionality in this class, but for now I am only exposing what is
		needed for the format dialogs.

		@h3{When to implement}
		Don't even think about it! The built in implementation has lots of hidden stuff you
		can't duplicate.

		@h3{When to use}
		Pass to style dialogs so they can correctly indicate the value that a property actually
		has in the current selection, even if the text properties object doesn't specify
		a value.

		@h3{How to obtain an instance}
		The usual way is from ${IVwSelection#GetSelectionProps}.

		You can also make one with CoCreateInstance, using CLSID_VwPropertyStore. This will
		have all the default property values, and can also be used with ${#ChrpFor} to figure
		what properties a particular ${TsTextProps} will produce.

		@h3{Hungarian: vps}
	*******************************************************************************************/
	DeclareInterface(VwPropertyStore, Unknown, 3D4847FE-EA2D-4255-A496-770059A134CC)
	{
		// This gets the actual, working value of a property as used in rendering etc.
		// No variation code is supplied or returned; it uses the most basic variation.
		// For example, all measurements are in millipoints; colors are RGB values;
		// things that are typically enumerations, are.
		// Some special cases:
		//	bold will be one of the absolute values, 100-900.
		[propget] HRESULT IntProperty(
			[in] int nID,
			[out, retval] int * pnValue);
		// Get the actual, working value of some string-valued property.
		[propget] HRESULT StringProperty(
			[in] int sp,
			[out, retval] BSTR * bstrValue);
		// Get the LgCharRenderProps that this property store would produce for the
		// specified pttp. The pttp should specify the writing system and ows that the properties
		// are wanted for.
		[propget] HRESULT ChrpFor(
			[in] ITsTextProps * pttp,
			[out, retval] LgCharRenderProps * pchrp);
		// Set the style sheet that this property store will use to interpret
		[propputref] HRESULT Stylesheet(
			[in] IVwStylesheet * pvps);

		// Set the writing system factory that this property store uses.
		[propputref] HRESULT WritingSystemFactory(
			[in] ILgWritingSystemFactory * pwsf);

		// Get the property store that this one was derived from.
		[propget] HRESULT ParentStore([out, retval]IVwPropertyStore ** ppvps);

		// Gets an ${ITsTextProps} interface pointer on an ITsTextProps object whose properties are
		// those currently in the store. In particular, if the current VwPropertyStore has just
		// been created and not changed, the properties will be the system default properties.
		[propget] HRESULT TextProps([out,retval] ITsTextProps ** ppttp);

		// Get the actual, working value of some string-valued property.
		[propget] HRESULT DerivedPropertiesForTtp(
			[in] ITsTextProps * pttp,
			[out, retval] IVwPropertyStore ** ppvps);

	};

	#ifndef NO_COCLASSES
	DeclareCoClass(VwPropertyStore, CB59916A-C532-4a57-8CB4-6E1508B4DEC1)
	{
		interface IVwPropertyStore;
	};
	#endif // !NO_COCLASSES

	// Enumerates the possible variations in how overlay tags are displayed.
	typedef [v1_enum] enum VwOverlayFlags
	{
		kfofTagsUseAttribs = 1, // True to make tag appearance match text
		kfofLeadBracket = 2, // True to show bracket above text at start of run
		kfofLeadTag = 4, // True to show tag above text at start of run
		kfofTrailBracket = 8, // True to show closing bracket below text at end of run
		kfofTrailTag = 16,	// True to show tag below text at end of run.

		kgrfofTagAbove = 6, // Mask to query whether anything is shown above.
		kgrfofTagBelow = 24, // Mask to query whether anything is shown below.
		kgrfofTagAnywhere = 30, // Mask to query whether any visible tags.
		kgrfofBracketAnywhere = 10, // Mask for bracket above or below or both

		kgrfofDefault = 31, // Combination of non-mask enum values.
	} VwOverlayFlags; // Hungarian fof

	// The number of (wide) characters that a GUID occupies, as stored in the tags string property of
	// a ${TsTextProps}. Currently this is just a memcpy image of a GUID. We may decide at some
	// point that we need a representation that is not dependent on byte ordering, and
	// need more characters.
	typedef [v1_enum] enum VwConst1 // kludgy way to define a constant that C++ can see
	{
		kcchGuidRepLength  = 8,
	} VwConst1;
	#define GUID_REP_LENGTH 8 // For use here in IDL

	// Used in ${IVwOverlay#SetTagInfo} to specify which of the arguments actually contain new
	// values that should replace the current settings. This allows the one method to change
	// several properties in a single call, without requiring the caller to supply correct
	// values for unchanged items. Combine the desired flags. The different names correspond
	// to arguments of SetTagInfo.
	typedef [v1_enum] enum FwOverlaySetMask
	{
		kosmAbbr =      0x01,
		kosmName =      0x02,
		kosmClrFore =   0x04,
		kosmClrBack =   0x08,
		kosmClrUnder =  0x10,
		kosmUnderType = 0x20,
		kosmHidden =    0x40,

		kosmAll =       0x7F,
	} FwOverlaySetMask;

	/*******************************************************************************************
		Interface IVwOverlay
		This interface stores specifications of how an overlay should be displayed.

		For a paragraph to be displayed with overlay tagging, first, it must be set up by
		calling ${IVwEnv#OpenTaggedPara} (or OpenMappedPara). Then, an overlay must be assigned
		to the view by calling ${IVwRootBox#putref_Overlay}. Finally, the string must have
		runs that are tagged, which is done by setting the string property ktptTags to contain
		one of more GUIDs. (Assign them 8 wide characters each, and just copy the GUID into
		the character array using memcpy. At least this works on Windows. A big-endian
		computer might need a different strategy. We'd have to look into the whole path the
		GUID takes from the database to being compared with the IVwOverlay info.

		@h3{When to implement}
		Don't. The one built into the view subsystem should suffice.

		@h3{When to use}
		Pass to ${IVwRootBox#putref_Overlay} to set up the overlay tagging that you want
		displayed in that view.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwOverlay (CreateInstance on a smart pointer).

		@h3{Hungarian: vo}
	*******************************************************************************************/
	DeclareInterface(VwOverlay, Unknown, 7D9089C1-3BB9-11d4-8078-0000C0FB81B5)
	{
		// Get the name of the overlay itself.
		[propget] HRESULT Name(
			[out, retval] BSTR * pbstr);
		// Set the name of the overlay itself.
		[propput] HRESULT Name(
			[in] BSTR bstr);

		// Get a guid that identifies the overlay
		// ENHANCE JohnT: why does an overlay have a GUID? We don't use it or set it anywhere
		// that I can find.
		[propget] HRESULT Guid(
			[out, size_is(GUID_REP_LENGTH), retval] OLECHAR * prgchGuid);
		// Set a guid that identifies the overlay
		[propput] HRESULT Guid(
			[in, size_is(GUID_REP_LENGTH)] OLECHAR * prgchGuid);

		// Get the ID that identifies the possibility list from which tags in this overlay
		// are taken.
		[propget] HRESULT PossListId(
			[out, retval] HVO * ppsslId);
		// Set the ID that identifies the possibility list from which tags in this overlay
		// are taken.
		[propput] HRESULT PossListId(
			[in] HVO psslId);

		// Get the flags that control how overlays should be displayed. See ${VwOverlayFlags}
		// for the list of options.
		[propget] HRESULT Flags(
			[out, retval] VwOverlayFlags * pvof);
		// Set the flags that control how overlays should be displayed. See ${VwOverlayFlags}
		// for the list of options.
		[propput] HRESULT Flags(
			[in] VwOverlayFlags vof);

		// Get the name and point size of the font to use to display tags.
		[propget] HRESULT FontName(
			[out, retval] BSTR * pbstr);
		// Set the name and point size of the font to use to display tags.
		[propput] HRESULT FontName(
			[in] BSTR bstr);

		// Get a font name, up to 32 characters.
		HRESULT FontNameRgch(
			[out, size_is(32)] OLECHAR * prgch);
		// Get the point size to use to display tags.
		[propget] HRESULT FontSize(
			[out, retval] int * pmp);
		// Set the point size to use to display tags.
		[propput] HRESULT FontSize(
			[in] int mp);

		// Get the number of tags (max) to show at one boundary position
		[propget] HRESULT MaxShowTags(
			[out, retval] int * pctag); // millipoints
		// Set the number of tags (max) to show at one boundary position
		[propput] HRESULT MaxShowTags(
			[in] int ctag);

		// Get the number of tags in overlay (that is, the number of distinct GUIDS
		// that this overlay has information about displaying).
		[propget] HRESULT CTags(
			[out, retval] int * pctag);

		// Get all the info about nth tag, all that is needed to make a column in the database
		// (Actually, the GUID is not strictly needed, but returning it as well is
		// convenient for merging.)
		// @param itag Index into list of tags
		// @param phvo Record ID in database of CmPossibility
		// @param pclrFore Color of main text
		// @param pclrBack Color of background
		// @param pclrUnder Color of underline
		// @param punt Type of underline, from FwUnderlineType
		// @param pfHidden True to suppress display of tag
		// @param prgchGuid GUID that occurs in ktptTags property of run that has this tag.
		HRESULT GetDbTagInfo(
			[in] int itag,
			[out] HVO * phvo, // record ID in database of CmPossibility
			[out] COLORREF * pclrFore,
			[out] COLORREF * pclrBack,
			[out] COLORREF * pclrUnder,
			[out] int * punt, // FwUnderlineType
			[out] ComBool * pfHidden,
			[out, size_is(GUID_REP_LENGTH)] OLECHAR * prgchGuid);

		// Add (or replace) the information about the specified GUID.
		// @param prgchGuid GUID that occurs in ktptTags property of run that has this tag.
		// @param hvo Record ID in database of CmPossibility
		// @param grfosm Combination of bits from FwOverlaySetMask, indicating which of the
		// following arguments contain info.
		// @param bstrAbbr The abbrevation to show in interlinear tagging
		// @param bstrName The full name of the possibility item (for hovering)
		// @param clrFore Color of main text
		// @param clrBack Color of background
		// @param clrUnder Color of underline
		// @param unt Type of underline, from FwUnderlineType
		// @param fHidden True to suppress display of tag
		HRESULT SetTagInfo(
			[in, size_is(GUID_REP_LENGTH)] OLECHAR * prgchGuid,
			[in] HVO hvo, // record ID in database of CmPossibility
			[in] int grfosm, // FwOverlaySetMask
			[in] BSTR bstrAbbr,
			[in] BSTR bstrName,
			[in] COLORREF clrFore,
			[in] COLORREF clrBack,
			[in] COLORREF clrUnder,
			[in] int unt,  // FwUnderlineType
			[in] ComBool fHidden);

		// Get all the info about a particular tag. This is used in merging.
		// Return S_FAIL if no info about this GUID. However, this is a normal usage.
		// @param prgchGuid GUID that occurs in ktptTags property of run that has this tag.
		// @param phvo Record ID in database of CmPossibility
		// @param pbstrAbbr The abbrevation to show in interlinear tagging
		// @param pbstrName The full name of the possibility item (for hovering)
		// @param pclrFore Color of main text
		// @param pclrBack Color of background
		// @param pclrUnder Color of underline
		// @param punt Type of underline, from FwUnderlineType
		// @param pfHidden True to suppress display of tag
		HRESULT GetTagInfo(
			[in, size_is(GUID_REP_LENGTH)] OLECHAR * prgchGuid,
			[out] HVO * phvo, // record ID in database of CmPossibility
			[out] BSTR * pbstrAbbr,
			[out] BSTR * pbstrName,
			[out] COLORREF * pclrFore,
			[out] COLORREF * pclrBack,
			[out] COLORREF * pclrUnder,
			[out] int * punt,  // FwUnderlineType
			[out] ComBool * pfHidden);

		// Get the info that is relevant for displaying the tag in a dialog.
		// @param itag Index into list of tags
		// @param pfHidden True to suppress display of tag
		// @param pclrFore Color of main text
		// @param pclrBack Color of background
		// @param pclrUnder Color of underline
		// @param punt Type of underline, from FwUnderlineType
		// @param pbstrAbbr The abbrevation to show in interlinear tagging
		// @param pbstrName The full name of the possibility item (for hovering)
		HRESULT GetDlgTagInfo(
			[in] int itag,
			[out] ComBool * pfHidden,
			[out] COLORREF * pclrFore,
			[out] COLORREF * pclrBack,
			[out] COLORREF * pclrUnder,
			[out] int * punt, // FwUnderlineType
			[out] BSTR * pbstrAbbr,
			[out] BSTR * pbstrName);

		// Get the info that the view code wants for actual display.
		// If nothing is known about the GUID, it is treated as hidden; the
		// call succeeds. As with fields that are really hidden, the name is returned
		// as an empty string, and all other return results are knNinch.
		// If the array for the tag is not big enough, put whatever fits.
		// @param prgchGuid GUID that occurs in ktptTags property of run that has this tag.
		// @param pfHidden True to suppress display of tag
		// @param pclrFore Color of main text
		// @param pclrBack Color of background
		// @param pclrUnder Color of underline
		// @param punt Type of underline, from FwUnderlineType
		// @param prgchAbbr The abbrevation to show in interlinear tagging
		// @param cchMaxAbbr The abbrevation to show in interlinear tagging
		// @param pcchAbbr The abbrevation to show in interlinear tagging
		// @param prgchName(etc) The full name of the possibility item (for hovering)
		HRESULT GetDispTagInfo(
			[in, size_is(GUID_REP_LENGTH)] OLECHAR * prgchGuid,
			[out] ComBool * pfHidden,
			[out] COLORREF * pclrFore,
			[out] COLORREF * pclrBack,
			[out] COLORREF * pclrUnder,
			[out] int * punt, // FwUnderlineType
			[out, size_is (cchMaxAbbr)] OLECHAR * prgchAbbr,
			[in] int cchMaxAbbr,
			[out] int * pcchAbbr,
			[out, size_is (cchMaxName)] OLECHAR * prgchName,
			[in] int cchMaxName,
			[out] int * pcchName);

		// Remove the selected tag from the overlay.
		// If nothing is known about the GUID, the call succeeds (without removing anything).
		// @param prgchGuid GUID that occurs in ktptTags property of run that has this tag.
		HRESULT RemoveTag(
			[in, size_is(GUID_REP_LENGTH)] OLECHAR * prgchGuid);

		// Sort the tags, with the most recently used at the start ordered by how
		// recently used, the rest alphabetical by abbr or name.
		HRESULT Sort(
			[in] ComBool fByAbbr); // otherwise by name

		// Obtain a new overlay, formed by merging the recipient and the argument.
		// - Any GUID present in either input should be in the result.
		// - An error (E_FAIL) occurs if any GUID occurs in both with differing abbr or name
		// - If a GUID occurs in both overlays, the other properties are merged:
		//   - If either overlay has a property set to knNinch, the value from the other is used.
		//   - Conflicting colors are resolved as DARK GRAY for text and underline and LIGHT
		//		GRAY for background, except that underline color is ignored in an overlay
		//		which specifies underline as kuntNone (or knNinch).
		//   - Conflicting underline requests (except kuntNone/Ninch) result in kuntDouble.
		// The new overlay is typically only temporary, and does not initially have a name.
		// Other global properties, such as font and point size, are just copied from the
		// recipient.
		HRESULT Merge(
			[in] IVwOverlay * pvo,
			[out, retval] IVwOverlay ** ppvoMerged);
	};
	#ifndef NO_COCLASSES
	DeclareCoClass(VwOverlay, 73F5DB01-3D2A-11d4-8078-0000C0FB81B5)
	{
		interface IVwOverlay;
	};
	#endif // !NO_COCLASSES

	// Positions on page where header portions may be printed.
	// Generally, choices should be made from Left, Right, and Center,
	// or Outside, Inside, and Center, but not both.
	typedef [v1_enum] enum VwHeaderPositions
	{
		kvhpLeft = 1,
		kvhpRight = 2,
		kvhpOutside = 4,
		kvhpInside = 8,
		kvhpCenter = 16,
		kvhpOdd = 32,
		kvhpEven = 64,
		kvhpTop = 128,
		kvhpBottom = 256,
		kvhpFirst = 512,  // True only for first page
		kgrfvhpNormal = 915, // top+bottom+left+right+center+first; no mirroring or odd/even.
	} VwHeaderPositions; // Hungarian vhp


	/*******************************************************************************************
		Interface IVwPrintContext
		This interface is the main argument passed to printing routines. It is used by them
		to work out details like what pages to print, what headings to print, and also to
		obtain an ${IVwGraphics} on which the actual drawing takes place.

		In many ways you can think of this as an enhanced IVwGraphics, providing the extra
		information needed in printing. We chose not to force it to be the same object so as
		to provide more flexibility in implementation.

		@h3{When to implement}
		Generally the one built into the view subsystem should suffice. If you want to
		have a more complex arrangement of page headings you might do your own implementation.
		In such a case please consider adding your implementation to the View subsystem.

		@h3{When to use}
		Pass to ${IVwRootBox#Print} to actually get a view printed.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwPrintContextWin32 (or CreateInstance on a smart pointer).

		@h3{Hungarian: vpc}
	*******************************************************************************************/
	DeclareInterface(VwPrintContext, Unknown, FF2E1DC2-95A8-41c6-85F4-FFCA3A64216A)
	{
		// Get a VwGraphics on which to actually draw (or measure things).
		[propget] HRESULT Graphics(
			[out, retval] IVwGraphics ** ppvg);
		// Get the number that should be assigned to the first page of the layout.
		// (Not necessarily the first page printed...it would be the first page printed
		// if you printed everything.)
		[propget] HRESULT FirstPageNumber(
			[out, retval] int * pn);
		// Return true if the specified page is in the range(s) to be printed.

		// Page numbers are relative to the first page number specified with
		// FirstPageNumber() above; for example, if the first page is numbered 7,
		// then IsPageWanted(8...) requests info on whether to print the second page.
		[propget] HRESULT IsPageWanted(
			[in] int nPageNo,
			[out, retval] ComBool * pfWanted);
		// Return true if more pages are wanted after page number specified.

		// This is asked only when isPageWanted returns false.

		// If AreMorePagesWanted also returns false, printing stops. (or loops to print
		// the next collated copy)
		[propget] HRESULT AreMorePagesWanted(
			[in] int nPageNo,
			[out, retval] ComBool * pfWanted);
		// Answer true if the print process should be aborted (e.g., because the
		// end user cancelled). Print code will endeavor to call this as often as possible.
		[propget] HRESULT Aborted(
			[out, retval] ComBool * pfAborted);

		// The number of copies to print.

		// If the output device is set up to produce multiple copies with acceptable
		// collating, without a need for the view to issue drawing commands repeatedly,
		// just answer 1 copy.
		[propget] HRESULT Copies(
			[out, retval] int * pnCopies);

		// Whether to collate multiple copies. If ${get_Copies} returns 1, this
		// information is not used.
		[propget] HRESULT Collate(
			[out, retval] ComBool * pfCollate);

		// Return the header that should be printed on page #pn in the postion indicated
		// by vhp. Each relevant bit in vhp is turned on; for example, on an odd-numbered
		// page the top right header has bits right, outside, odd, and top.
		// The intent is that the callee can maintain a list of header strings, each
		// with a group of flags indicating where it should be printed. For example,
		// a particular string might be marked top, left. The callee masks out unwanted
		// bits in vhp (e.g., outside and inside, odd and even, if doing simple left/right
		// printing), then looks for an exact match on the remaining bits.
		// For mirrored pages, mask out left, right, odd, and even.
		// For distinct odd/even headers, mask out left, right, inside, and outside.
		[propget] HRESULT HeaderString(
			[in] VwHeaderPositions grfvhp,
			[in] int pn,
			[out, retval] ITsString ** pptss);
		// Get margins, relative to the printable part of the page, in device units
		// @param pdypHeader Top of print rect to top of header
		// @param pdypTop Top of print rect to top of main document
		// @param pdypBottom Bottom of print rect to bottom of document
		// @param pdypFooter Bottom of print rect to bottom of footer
		HRESULT GetMargins(
			[out] int * pdxpLeft,
			[out] int * pdxpRight,
			[out] int * pdypHeader,
			[out] int * pdypTop,
			[out] int * pdypBottom,
			[out] int * pdypFooter);
		// Open a page. This is called only for pages that are actually to be printed
		// (that is, ${#IsPageWanted} returned true).
		HRESULT OpenPage();
		// Called at the end of printing each page for which OpenPage was called.
		HRESULT ClosePage();
		// Called before the first OpenPage call (only if there is at least one
		// page which is wanted). Once for the whole print job, not once per copy.
		HRESULT OpenDoc();
		// Called after the last ClosePage call.
		HRESULT CloseDoc();
		// This returns the last page number requested using IsPageWanted.
		// To find out the total number of pages in a document, arrange that
		// the first page wanted is some very large number, print the document,
		// (nothing is output), then call this method.

		// If you are making your own implementation of the interface, you can leave
		// this out. The View subsystem never calls it.
		[propget] HRESULT LastPageNo(
			[out, retval] int * pnPageNo);

		// Set the header mask. Bits masked out do not have to match, in finding
		// a header appropriate to a particular page. This also clears all previously
		// established headers.

		// This and similar methods are currently used by clients that use the default
		// implementation of IVwPrintContext provided by the view subsystem itself.
		// In the future they might be used in other ways; for example, we could create
		// a "SectionBox" which occupies no space but can reset the header information,
		// margins, and so forth, for subsequent pages when "printed".
		[propput] HRESULT HeaderMask(
			[in] VwHeaderPositions grfvhp);
		// Set the header string that will be printed in the locations indicated by the
		// bit map. This header will be used for pages whose positions map matches
		// grfvhp exactly, after masking out the bits indicated by ${#put_HeaderMask}.
		HRESULT SetHeaderString(
			[in] VwHeaderPositions grfvhp,
			[in] ITsString * ptss);
		// Set the margins to be used in printing.

		// Note that, unlike GetMargins, these distances are relative to the page,
		// not the printable rectangle.

		// The reason for this distinction is necessity. If the view needs to set new
		// margins, they will be values specified by the user, and are certain to be
		// relative to the page. On the other hand, to do the printing, the view needs
		// distances relative to the rectangle it is drawing into.
		// @param dypHeader Top of page to top of header
		// @param dypTop Top of page to top of main document
		// @param dypBottom Bottom of page to bottom of document
		// @param dypFooter Bottom of page to bottom of footer
		HRESULT SetMargins(
			[in] int dxpLeft,
			[in] int dxpRight,
			[in] int dypHeader,
			[in] int dypTop,
			[in] int dypBottom,
			[in] int dypFooter);
		// This method will never be called in the course of printing and need not be
		// implemented by a callee doing its own implementation. It is provided to
		// allow initialization of the default implementation.
		// ENHANCE JohnT: should we make this a separate interface?
		// It provides
		// only a single range of page numbers, which is enough to implement the
		// standard Windows print dialog (pre-W2000).
		HRESULT SetPagePrintInfo(
			[in] int nFirstPageNo, // returned by FirstPageNumber()
			[in] int nFirstPrintPage, // relative to FirstPageNo
			[in] int nLastPrintPage,
			[in] int nCopies, // returned by Copies()
			[in] ComBool fCollate); // returned by Collate()
		// This method is used only to set up the default print context.
		// The print context currently built into the Win32 views subsystem must be
		// initialized with a VwGraphics obtained using CoCreateInstance
		// on CLSID_VwGraphicsWin32, and then initialized with an appropriate
		// print HDC.

		// ENHANCE JohnT: should we put this in a separate interface, perhaps
		// with ${#SetPagePrintInfo}?
		HRESULT SetGraphics(
			[in] IVwGraphics * pvg);
		// Call this to cancel the print job as soon as possible (e.g., when the user
		// clicks cancel).

		// This will never be called by the Views code; it is called by your code
		// when you need to abort a print job being done using the standard implementation.
		HRESULT RequestAbort();
		// This is called instead of EndDoc (and possibly replacing a ClosePage call, too)
		// when the view code responds to a RequestAbort and actually aborts printing.
		// No more calls may be made to the print context after AbortDoc, nor should any
		// more drawing be done on the associated IVwGraphics.
		HRESULT AbortDoc();
	};
	#ifndef NO_COCLASSES
	DeclareCoClass(VwPrintContextWin32, 5E9FB977-66AE-4c16-A036-1D40E7713573)
	{
		interface IVwPrintContext;
	};
	#endif // !NO_COCLASSES


	/*******************************************************************************************
		Interface IVwPattern.

		This interface represents the information used in the process of searching for a text
		string or pattern. It stores the actual string searched for, and can be used to search
		for its target from a particular position in a view, or from the start of it.

		@h3{When to implement}
		Only the implementation built into the View subsystem can be used.

		@h3{When to use}
		Use this interface when performing search and replace operations in view data.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwPattern

		@h3{Hungarian: xpat}
	*******************************************************************************************/
	DeclareInterface(VwPattern, Unknown, EFEBBD00-D418-4157-A730-C648BFFF3D8D)
	{
		// Get the pattern to be searched for.
		[propget] HRESULT Pattern(
			[out, retval] ITsString ** pptssPattern);
		// Set the pattern to be searched for. Text alone may be significant, or some of the
		// character properties may be, depending on other flags, such as writing system,
		// style, and tags. If the pattern has no chars, it matches any text that has the
		// right values of the currently significant properties.
		[propputref] HRESULT Pattern(
			[in] ITsString * ptssPattern);

		// Get the pattern to be searched for.
		[propget] HRESULT Overlay(
			[out, retval] IVwOverlay ** ppvo);
		// Set the overlay to search for.
		[propputref] HRESULT Overlay(
			[in] IVwOverlay * pvo);

		// Get whether to match case exactly. Default is to ignore case.
		[propget] HRESULT MatchCase(
			[out, retval] ComBool * pfMatch);
		// Set whether to match case exactly. Default is to ignore case.
		[propput] HRESULT MatchCase(
			[in] ComBool fMatch);

		// Get whether to match diacritics exactly. Default is to ignore diacritics.
		[propget] HRESULT MatchDiacritics(
			[out, retval] ComBool * pfMatch);
		// Set whether to match diacritics exactly. Default is to ignore diacritics.
		[propput] HRESULT MatchDiacritics(
			[in] ComBool fMatch);

		// Get whether to match whole words only (that is, there must be a word boundary
		// before and after the pattern). Default is false.
		[propget] HRESULT MatchWholeWord(
			[out, retval] ComBool * pfMatch);
		// Set whether to match whole words only (that is, there must be a word boundary
		// before and after the pattern). Default is false.
		[propput] HRESULT MatchWholeWord(
			[in] ComBool fMatch);

		// Get whether to match old writing system (that is, corresponding characters in
		// input and output must have same writing system and ows). Default is false.
		[propget] HRESULT MatchOldWritingSystem(
			[out, retval] ComBool * pfMatch);
		// Set whether to match old writing system (that is, corresponding characters in
		// input and output must have same writing system and ows). Default is false.
		[propput] HRESULT MatchOldWritingSystem(
			[in] ComBool fMatch);

		// Set whether to treat character sequences that are canonically equivalent
		// as defined by Unicode as being identical. An exact match means that
		// canonically equivalent characters are not treated as the same. Default is false.

		// Get whether to treat character sequences that are canonically equivalent
		// as defined by Unicode as being identical. An exact match means that
		// canonically equivalent characters are not treated as the same. Default is false.
		[propget] HRESULT MatchExactly(
			[out, retval] ComBool * pfMatch);
		// Not currently implemented. Current code behaves as if this were set true.
		// ENHANCE JohnT: should this imply turning all the others on also?
		[propput] HRESULT MatchExactly(
			[in] ComBool fMatch);

		// Get whether to treat character sequences that are equivalent
		// as defined by Unicode compatibility decompositions as being identical.
		// Default is false.
		// Not currently implemented.
		[propget] HRESULT MatchCompatibility(
			[out, retval] ComBool * pfMatch);
		// Set whether to treat character sequences that are equivalent
		// as defined by Unicode compatibility decompositions as being identical.
		// Default is false.
		// Not currently implemented.
		[propput] HRESULT MatchCompatibility(
			[in] ComBool fMatch);

		//:> Someday we probably want to add stuff to turn pattern matching on and off,
		//:> and to help figure the language-dependent meaning of some character classes.

		// Find the first (or last) match of the pattern in the root box.
		// Return S_FALSE if not found.
		HRESULT Find(
			[in] IVwRootBox * prootb,
			[in] ComBool fForward,
			[in] IVwSearchKiller * pxserkl);
		// Find the next (or previous) match of the pattern, starting from the specified
		// selection.
		// Return S_FALSE if not found.
		HRESULT FindFrom(
			[in] IVwSelection * psel,
			[in] ComBool fForward,
			[in] IVwSearchKiller * pxserkl);
		// Find the next (or previous) match of the pattern, starting from a position
		// determined by a previous search.
		// Return S_FALSE if not found.
		HRESULT FindNext(
			[in] ComBool fForward,
			[in] IVwSearchKiller * pxserkl);
		// This allows patterns to be used in searching stuff other than views.
		// The text to be searched must be presented as an IVwTextSource.
		// The search begins at ichStart in the text source, and proceeds in the
		// specified direction. *pichFound is set to -1 if there is no match,
		// otherwise it points to the start of the match. *pichLimFound indicates the
		// other end of the range.
		//
		// If searching forward, *pichMinFound must be at least ichStart; if searching
		// backwards, *pichLimFound must be at most ichStart.

		// If searching forward, *pichMinFound must be at most ichEnd; if searching
		// backwards, *pichLimFound must be at least ichEnd.

		// Note that this ALWAYS sets StoppedAtLimit to false.
		// It is too low level to detect stopping at the limit. The trouble is, it can't do it
		// reliably, because it doesn't know whether the text source it is searching is the
		// limit paragraph.

		// NOTE: All character indices inputs/outputs are logical!
		HRESULT FindIn(
			[in] IVwTextSource * pts,
			[in] int ichStartLog,
			[in] int ichEndLog,
			[in] ComBool fForward,
			[out] int * pichMinFoundLog,
			[out] int * pichLimFoundLog,
			[in] IVwSearchKiller * pxserkl);

		// Install the current Find result as the active selection.
		HRESULT Install();

		// Another way to find out whether a match was found. Returns false when the object
		// is first created and until a search succeeds, then true until an unsuccessful
		// search occurs.
		[propget] HRESULT Found(
			[out, retval] ComBool * pfFound);

		// Create a selection equivalent to the position found, and (optionally) install it
		// @error E_UNEXPECTED if the Found() returns false.
		HRESULT GetSelection(
			[in] ComBool fInstall,
			[out, retval] IVwSelection ** ppsel);

		// Indicate how many levels of nesting of (object, property) contain the selection,
		// including the basic property that terminates the chain.
		HRESULT CLevels(
			[out] int * pclev);

		// Get the same info as would be obtained by calling GetSelection, then
		// sending this same message to it. This may be considerably more efficient, though.
		//
		// (Note that the last 3 arguments of the VwSelection version is omitted, as no special
		// character properties can be associated with a new selection, it is always a range,
		// and it is always within one paragraph.)
		HRESULT AllTextSelInfo(
			[out] int * pihvoRoot,
			[in] int cvlsi,
			[out, size_is(cvlsi)] VwSelLevInfo * prgvsli,
			[out] PropTag * ptagTextProp,
			[out] int * pcpropPrevious,
			[out] int * pichAnchor,
			[out] int * pichEnd,
			[out] int * pws);

		// Return true if the contents of the selection matches the pattern.
		HRESULT MatchWhole(
			[in] IVwSelection * psel,
			[out, retval] ComBool * pfMatch);

		// Get the selection that will function as a limit for the search. This should always
		// be an insertion point. Find will stop and fail if it reaches this point.
		[propget] HRESULT Limit(
			[out, retval] IVwSelection ** ppsel);
		// Set a selection that will function as a limit for the search. The actual limit
		// is the start of the selection, if searching backwards, and the end, if searching
		// forwards. Find will stop and fail if it reaches this point.
		[propputref] HRESULT Limit(
			[in] IVwSelection * psel);
// OK after here
		// Retrieve a selection that is, conceptually, the starting point for the current
		// sequence of searches. This is in the interface as a convenience for the client,
		// so that all the necessary information about the nature of the current search can
		// be saved in the VwPattern. The pattern never modifies it except through the
		// putref_StartingPoint method.
		[propget] HRESULT StartingPoint(
			[out, retval] IVwSelection ** ppsel);
		// Store a selection that is, conceptually, the starting point for the current
		// sequence of searches. This is in the interface as a convenience for the client,
		// so that all the necessary information about the nature of the current search can
		// be saved in the VwPattern. It has no influence on the behavior of the pattern.
		[propputref] HRESULT StartingPoint(
			[in] IVwSelection * psel);

		// Get a handle to the window being searched. This just retrieves what has been
		// set by put_SearchWindow (or 0, if SearchWindow has not been called).
		[propget] HRESULT SearchWindow(
			[out, retval] DWORD * phwnd);
		// Store a handle to the window being searched. This has no influence on the
		// behavior of the pattern, but is part of allowing the state of a sequence of
		// searches to be saved. (The pattern does not care whether this is really an HWND.)
		[propput] HRESULT SearchWindow(
			[in] DWORD hwnd);

		// This allows us to find out whether the search terminated at the limit or
		// at the start/end of the view. It is false in all circumstances except
		// when the most recent search attempt failed because it reached the ${#Limit}.
		[propget] HRESULT StoppedAtLimit(
			[out, retval] ComBool * pfAtLimit);

		// This allows us to set whether the search terminated at the limit or
		// at the start/end of the view. It is normally only used by code internal
		// to the View subsystem, but external code using FindIn directly may need
		// to set the flag.
		[propput] HRESULT StoppedAtLimit(
			[in] ComBool fAtLimit);

		// Retrieve the direction of the last search. False if there has not been one.
		[propget] HRESULT LastDirection(
			[out, retval] ComBool * pfForward);

		// Get the replace with string.
		[propget] HRESULT ReplaceWith(
			[out, retval] ITsString ** pptssPattern);
		// Set the replace with string. Currently this is just a sequence of chars
		// to match. Later we may add options for regular expression patterns.
		// This is currently unused by the Pattern code, it is just convenient to allow
		// clients to store this here.
		[propputref] HRESULT ReplaceWith(
			[in] ITsString * ptssPattern);

		// Get a flag indicating whether the "More"
		// controls in the dialog should be enabled. Not used internally.
		[propget] HRESULT ShowMore(
			[out, retval] ComBool * pfMore);
		// Set a flag indicating whether the "More"
		// controls in the dialog should be enabled. Not used internally.
		[propput] HRESULT ShowMore(
			[in] ComBool fMore);

		// Get the ICU Locale to be used in comparing strings and determining word breaks.
		// This is a name intended to be used to create an ICU Locale using createFromName().
		[propget] HRESULT IcuLocale(
			[out, retval] BSTR * pbstrLocale);
		// Set the ICU Locale to be used in comparing strings and determining word breaks.
		[propput] HRESULT IcuLocale(
			[in] BSTR bstrLocale);

		// Get the collating rules (as used in creating an ICU RuleBasedCollater) to use
		// in comparing strings. If empty, the default collater for the ICU Locale is used.
		[propget] HRESULT IcuCollatingRules(
			[out, retval] BSTR * pbstrRules);
		// Set the collating rules (as used in creating an ICU RuleBasedCollater) to use
		// in comparing strings. If empty, the default collater for the ICU Locale is used.
		[propput] HRESULT IcuCollatingRules(
			[in] BSTR bstrRules);

		// Get whether using regular expressions. Default is false.
		[propget] HRESULT UseRegularExpressions(
			[out, retval] ComBool * pfMatch);
		// Set whether to use regular expression pattern-matching.
		[propput] HRESULT UseRegularExpressions(
			[in] ComBool fMatch);

		// Check this (should be null) to obtain any error message, especially from regular
		// expression operations.
		[propget] HRESULT ErrorMessage(
			[out, retval] BSTR * pbstrMsg);

		// By default this answers the same as ReplaceWith(). However, if a find has recently
		// occurred involving a regular expression, this computes the replacement text,
		// taking account of any uses of saved groups in the replace with string.
		[propget] HRESULT ReplacementText(
			[out, retval] ITsString ** pptssText);
		// If a regular expression has just been searched successfully, this returns the
		// text of the indicated group. 0 answers the whole matched string, 1 the text of the
		// substring matched by the first () group, 2, the text of the second, and so forth.
		// Returns an empty string (in the ws of the first character of the match) for index out of range.
		// Returns E_UNEXPECTED if there has not been a previous regular expression match.
		[propget] HRESULT Group(
			[in] int iGroup,
			[out, retval] ITsString ** pptssGroup);

		//:> We may want to add a method for returning the text of the paragraph,
		//:> to help display concordances.
	};
	#ifndef NO_COCLASSES
	DeclareCoClass(VwPattern, 6C659C76-3991-48dd-93F7-DA65847D4863)
	{
		interface IVwPattern;
	};
	#endif // !NO_COCLASSES


	/*******************************************************************************************
		Interface IVwTxtSrcInit2

		This interface is used to to set the contents of a simple text source used for Find
		operations.

		@h3{When to implement}
		The standard implementation must be used.

		@h3{When to use}
		Mainly useful to pass to IVwPattern::FindIn.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwTxtSrcInit2 or CreateInstance() on a smart pointer.

		@h3{Hungarian: tsinit2}
	*******************************************************************************************/
	DeclareInterface(VwTxtSrcInit2, Unknown, 8E3EFDB9-4721-4f17-AA50-48DF65078680)
	{
		// Sets the string to be a text source for.
		HRESULT SetString(
			[in] ITsString * ptss,
			[in] IVwViewConstructor * pvc,
			[in] ILgWritingSystemFactory * pwsf);
	}
	#ifndef NO_COCLASSES
	DeclareCoClass(VwMappedTxtSrc, 01D1C8A7-1222-49c9-BFE6-30A84CE76A40)
	{
		interface IVwTxtSrcInit2;
		interface IVwTextSource;
	};
	#endif // !NO_COCLASSES


	/*******************************************************************************************
		Interface IVwTxtSrcInit

		This interface is used to to set the contents of a simple text source used for Find
		operations.

		@h3{When to implement}
		The standard implementation must be used.

		@h3{When to use}
		Mainly useful to pass to IVwPattern::FindIn.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwTxtSrcInit or CreateInstance() on a smart pointer.

		@h3{Hungarian: tsinit}
	*******************************************************************************************/
	DeclareInterface(VwTxtSrcInit, Unknown, 1AB3C970-3EC1-4d97-A7B8-122642AF6333)
	{
		// Sets the string to be a text source for.
		HRESULT SetString(
			[in] ITsString * ptss);
	}
	#ifndef NO_COCLASSES
	DeclareCoClass(VwStringTextSource, DAF01E81-3026-4480-8783-EEA04CD2EC80)
	{
		interface IVwTxtSrcInit;
		interface IVwTextSource;
	};
	#endif // !NO_COCLASSES

	/*******************************************************************************************
		Interface VwSearchKiller

		This interface is used to allow Windows messages to be processed during a search
		operation, and thus to determine if the user has requested to abort the search.

		@h3{When to implement}
		The standard implementation, ${VwSearchKiller} should be used.

		@h3{When to use}
		The search and replace dialog can create an instance, and pass it on into the search
		routines.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwSearchKiller or CreateInstance() on a smart pointer.

		@h3{Hungarian: xserkl}
	*******************************************************************************************/
	DeclareInterface(VwSearchKiller, Unknown, FF1B39DE-20D3-4cdd-A134-DCBE3BE23F3E)
	{
		// Tells object which window to filter messages for
		// @param hwnd Handle of window.
		[propput] HRESULT Window([in] int hwnd);

		// Processes waiting Windows messages, and removes them from the queue.
		HRESULT FlushMessages();

		// Reports on whether the user has requested an abort.
		// @param pfAbort True if user has requested abort.
		[propget] HRESULT AbortRequest([out, retval] ComBool * pfAbort);

		// Sets flag to request an abort.
		// @param pfAbort True if abort is required.
		[propput] HRESULT AbortRequest([in] ComBool fAbort);
	};
	#ifndef NO_COCLASSES
	DeclareCoClass(VwSearchKiller, 4ADA9157-67F8-499b-88CE-D63DF918DF83)
	{
		interface IVwSearchKiller;
	};
	#endif // !NO_COCLASSES

	/*******************************************************************************************
		Interface VwDrawRootBuffered

		This interface is used to draw a root box using double buffering.

		@h3{When to implement}
		The standard implementation, should be used.

		@h3{When to use}
		Useful in C#, which has trouble creating a bitmap that works properly.

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwDrawRootBuffered.

		@h3{Hungarian: xserkl}
	*******************************************************************************************/
	DeclareInterface(VwDrawRootBuffered, Unknown, D9E9D65F-E81F-439e-8010-5B22BAEBB92D)
	{
		// This is a drawing routine for a normal rootsite. It handles double buffering
		// as well as the calls to PrepareToDraw to handle laziness, then actually blasts
		// the new content onto the hdc. (In rare circumstances, when expanding lazy boxes
		// moves the scroll position, it doesn't draw anything...in this case, it
		// invalidates the window to force a further paint.)
		HRESULT DrawTheRoot(
			[in] IVwRootBox * prootb,
			[in] HDC hdc,
			[in] RECT rcpDraw,
			[in] COLORREF bkclr,
			[in] ComBool fDrawSel,
			[in] IVwRootSite * pvrs);

		// This is a drawing routine for a normal rootsite. This must ONLY be used following
		// a successful call to DrawTheRoot. It is intended for redrawing the exact same
		// content as the previous call (for situations when data may be in flux but it is
		// expedient to keep the view looking nice even though it isn't "live" data.
		HRESULT ReDrawLastDraw(
			[in] HDC hdc,
			[in] RECT rcpDraw);

		// This is a drawing routine for print layout views. It handles double buffering
		// but assumes that lazy boxes in the drawing area have already been dealt with.
		HRESULT DrawTheRootAt(
			[in] IVwRootBox * prootb,
			[in] HDC hdc,
			[in] RECT rcpDraw,
			[in] COLORREF bkclr,
			[in] ComBool fDrawSel,
			[in] IVwGraphics * pvg,
			[in] RECT rcSrc,
			[in] RECT rcDst,
			[in] int ysTop, // of the area we want to draw as originally measured.
			[in] int dysHeight); // of the area we want to draw as originally measured.

		// This is a drawing routine for a rotated rootsite. It handles double buffering
		// as well as rotation.
		// The nHow parameter currently supports only one option and must be 1,
		// signifying a rotation of plus 90 degrees.
		// For example: suppose we are asked to draw a rectangle at (10, 20) of extent (40, 80).
		// The part of the overall view contents to be drawn is a rectangle at (20, 10) of extent (80, 40)
		// with whatever further coordinate transformation is specified by calling GetGraphics.
		// To get the desired effect, GetGraphics must adjust the vertical coordinate of the 'destination' rectangle
		// by the HORIZONTAL scroll distance, and vice versa. Also, the 'available width' information must reflect the
		// HEIGHT of the window, and mouse coordinates and the like must also be adjusted.
		// Currently, this routine does not support laziness, and will not call PrepareToDraw().
		HRESULT DrawTheRootRotated(
			[in] IVwRootBox * prootb,
			[in] HDC hdc,
			[in] RECT rcpDraw, // The UNROTATED area to draw
			[in] COLORREF bkclr,
			[in] ComBool fDrawSel,
			[in] IVwRootSite * pvrs,
			[in] int nHow);
	};
	#ifndef NO_COCLASSES
	DeclareCoClass(VwDrawRootBuffered, 97199458-10C7-49da-B3AE-EA922EA64859)
	{
		interface IVwDrawRootBuffered;
	};
	#endif // !NO_COCLASSES

	/*******************************************************************************************
		Interface VwSynchronizer

		This interface is used to synchronize two or more root boxes, making the displays of
		corresponding objects the same height. If the two views contain the same objects in the
		same order (down to some desired level of granularity), this aligns corresponding
		objects in the views.

		@h3{When to implement}
		The standard implementation should be used.

		@h3{When to use}
		When aligned objects are wanted in two distinct views (usually controlled by a common
		scroll bar).

		@h3{How to obtain an instance}
		Use CoCreateInstance with CLSID_VwSynchronizer.

		@h3{Hungarian: sync}
	*******************************************************************************************/
	DeclareInterface(VwSynchronizer, Unknown, C5C1E9DC-5880-4ee3-B3CD-EBDD132A6294)
	{
		// Add a root box to the synchronization set.
		HRESULT AddRoot(
			[in] IVwRootBox * prootb);
		// Informs other synchronized roots that the source one has determined a new natural
		// height for one of the objects it is displaying. dypNaturalHeight is the height that
		// the source root box would make the display of the object in the absence of
		// synchronization. Returns the height that the display of the object should actually
		// be in view of synchronization.
		// Does not need to be in the interface.
		//HRESULT SyncNaturalTopToTop(
		//	[in] IVwRootBox * prootbSrc,
		//	[in] HVO hvoObj,
		//	[in] int dypNaturalHeight,
		//	[out, retval] int * pdypActualHeight);

		// Returns true if we're in the middle of expanding lazy items
		[propget] HRESULT IsExpandingLazyItems(
			[out, retval] ComBool * fAlreadyExpandingItems);
	};
	#ifndef NO_COCLASSES
	DeclareCoClass(VwSynchronizer, 5E149A49-CAEE-4823-97F7-BB9DED2A62BC)
	{
		interface IVwSynchronizer;
	};
	#endif // !NO_COCLASSES

// The following two interface logically belong in CommonCOMDlgs/CmnFwDlgs.idh, but putting them
// there results in multiply defined interface errors in C#.

/*******************************************************************************************
	Interface VwLayoutStream.
	This is a secondary interface which may be requested from an IVwRootBox when it
	is to be displayed in a page layout view. It contains the extra functionality
	needed for interacting with the page layout code and with other views that may have
	to share the page. As part of a page layout, it represents one 'stream' of data,
	that is, one of possibly several chunks in which independent selections may occur.

	@h3{When to implement}
	Don't even think about it. Use the standard implementation in Views.dll.

	@h3{When to use}
	Use this interface when creating one or more views to be laid out on a page.

	@h3{How to obtain an instance}
	Create one directly using CLSID_VwLayoutStream (and QueryInterface to get at
	the associated IVwRootBox interface).

	@H3{Hungarian: lay}
*******************************************************************************************/
DeclareInterface(VwLayoutStream, Unknown, 5DB26616-2741-4688-BC53-24C2A13ACB9A)
{
	// Set the Manager that callbacks will be made to during the layout process.
	HRESULT SetManager(
		[in] IVwLayoutManager * plm);
	// A (dependent) stream is requested by this method to lay out the specified object
	// for display using the specified graphics object on the specified page.
	// The object to be expanded is indicated using the ihvoRoot, cvsli, and prgvsli,
	// in the same manner as MakeTextSelInObj indicates the first object to be selected.
	// Typically ihvoRoot is 0, and there is just one cvsli giving the property and index
	// of the desired object. But the design makes it possible to have more structure.
	// This call also makes hPage an 'active' page; editing on the page will result
	// in callbacks if something changes that might require the page boundary to move.
	HRESULT LayoutObj(
		[in] IVwGraphics * pvg,
		[in] int dxsAvailWidth,
		[in] int ihvoRoot,
		[in] int cvsli,
		[in, size_is(cvsli)] VwSelLevInfo * prgvsli,
		[in] int hPage);
	// Perform the layout operation on a primary root site.
	// The root is to be laid out for drawing using the specified Graphics object.
	// pysStartThisPageBoundary indicates where the page is to start. If this is not a valid
	// page break position (e.g., in the middle of a line or text or table), it will
	// be adjusted (by decreasing) until it is. Note that a page 'boundary' is not
	// necessarily exactly the top of a page, though it is exactly the bottom of one.
	// Specifically, the page boundary is where we can draw an imaginary line, and say that
	// any box whose bottom is at or above the line is drawn on the previous page.
	// Any box whose bottom is below the line is drawn on the following page. Some boxes
	// thus drawn on the following page may extend above the line, requiring the top of
	// the page to be above its start page boundary, and causing the pages to overlap somewhat.
	// This call also makes hPage an 'active' page; editing on the page will result
	// in callbacks if something changes that might require the page boundary to move.
	// This may result in actual internal layout, if some material on the page has
	// not been laid out already (e.g., because of laziness).
	// It also results in call-backs being made using the hPage for all object refs
	// on the page.
	// After adding pages with LayoutObj, a page should either be rolled back or committed
	// before adding objects to other pages.
	// @param dxsAvailWidth indicates the width available for layout.
	// @param dysAvailHeight indicates the height available on the page.
	// @param hPage is a 'handle' to the page, passed to various other methods.
	// It can be any arbitrary value, but the same value should not be used for two
	// pages at the same time.
	// @param nColumns indicates the number of columns to be laid out on the page
	// @param pdysUsedHeight Returns the amount of space used by the material fitted on the page.
	// This is always the amount of space used for one column.
	// @param pysStartNextPageBoundary Returns a y position indicating where to start the next page.
	HRESULT LayoutPage(
		[in] IVwGraphics * pvg,
		[in] int dxsAvailWidth,
		[in] int dysAvailHeight,
		[in, out] int * pysStartThisPageBoundary,
		[in] int hPage,
		[in] int nColumns,
		[out] int * pdysUsedHeight,
		[out] int * pysStartNextPageBoundary);
	// Notifies the Layout Stream that notifications are no longer required for changes
	// affecting the specified page.
	HRESULT DiscardPage(
		[in] int hPage);
	// Return an IVwSelection that indicates the position of one of the ends of the specified
	// page.
	// If the page break is within a paragraph, the end of the previous page and start of
	// the next differ only by fAssocPrevious (always points to a character on the page).
	// If the page break is at a paragraph boundary, the selection will be at the end of
	// the last para on the page or the start of the first.
	// If the boundary is at higher-level break, the IP is at the end of the last, lowest
	// level paragraph at the end of the page, or the start of the first.
	// Will fail if called for a page that is 'broken' and has not been redone.
	HRESULT PageBoundary(
		[in] int hPage,
		[in] ComBool fEnd,
		[out, retval] IVwSelection ** ppsel);
	// Return the total height of the material on the specified page.
	// The page may have been established for this root site either by calling LayoutPage,
	// or by one or more calls to LayoutObj. In the latter case, the height is everything
	// from the first object laid out on this page to the last. (Anything not already
	// laid out between the two will automatically be laid out during the call.)
	HRESULT PageHeight(
		[in] int hPage,
		[out, retval] int * pdysHeight);
	// Return the absolute position of the top of the specified page. This is a distance
	// from the top of the document to the top of what is displayed on the page
	// (inside any top margins). Note that subsequent expansion of lazy boxes above
	// this could change this position.
	HRESULT PagePostion(
		[in] int hPage,
		[out, retval] int * pysPosition);

	// Revert the collections of objects on the given page to its previously-committed state.
	// If nothing on this page has yet been committed the page may be discarded.
	// After adding pages with LayoutObj, a page should either be rolled back or committed.
	// In the meantime the objects are treated as part of the page; in particular,
	// the PageHeight DOES include them.
	HRESULT RollbackLayoutObjects(
		[in] int hPage);
	// Confirm the objects added to the page with LayoutObj. Marks a position that
	// RollbackLayoutObjects will return to after subsequent LayoutObj calls until
	// the next Commit.
	HRESULT CommitLayoutObjects(
		[in] int hPage);

	// Get the height of column iColumn.
	// If this method is called before the page is layed out, E_FAIL will be returned.
	// It is valid only for the page most recently laid out.
	HRESULT ColumnHeight(
		[in] int iColumn,					// the desired column (0-based index)
		[out, retval] int * pdysHeight);	// the height of the column
	// Get the amount by which this column overlaps the previous page element,
	// because of unaligned lines in tables. See comment on PageElement.OffsetToTopPageBoundary.
	// If this method is called before the page is layed out, E_FAIL will be returned.
	// It is valid only for the page most recently laid out.
	HRESULT ColumnOverlapWithPrevious(
		[in] int iColumn,					// the desired column (0-based index)
		[out, retval] int * pdysHeight);	// the height of the overlap
	// Answer true if the specified point (in source coordinates, that is, relative to
	// the top left of the whole layout area)
	// is on a page ending at or above ysBottomOfPage.
	// This is true if the point is in a paragraph line or other box
	// whose bottom is <= the given coordinate.
	// If the return value is true, return the x range of
	// the line the point is part of.
	// Note that this does NOT ensure that a neighboring point is on the
	// page below, just that it is determined by a different line.
	// If it returns false, but there is a line in the overlap region
	// which IS on the previous page, return the left and right of the last such line.
	// If the relevant part of the display is lazy, it just compares ys with ysBottomOfPage,
	// and pxsLeft/pxsRight will always be zero.
	HRESULT IsInPageAbove(
		[in] int xs,
		[in] int ys,
		[in] int ysBottomOfPage,
		[in] IVwGraphics * pvg,
		[out] int * pxsLeft,
		[out] int * pxsRight,
		[out, retval] ComBool * pfInLineAbove);
};

#ifndef NO_COCLASSES
DeclareCoClass(VwLayoutStream, 1CD09E06-6978-4969-A1FC-462723587C32)
{
	interface IVwLayoutStream;
};
#endif // !NO_COCLASSES

/*******************************************************************************************
	Interface IVwLayoutManager.
	This is a secondary interface which the client site implements (in addition to
	IVwRootSite) in order to handle page layout.

	@h3{When to implement}
	When you want to do page layout...consider however the implementation provided as
	part of the FieldWorks RootSites project.

	@h3{When to use}
	Usually you will not use this interface yourself. The views code will call your
	implementation when you request page layout functions. You would use the LayoutManager
	class when you want a page layout view in your window.

	@h3{How to obtain an instance}
	Create it directly (it is part of your code) and pass to IVwLayoutStream::SetManager().

	@h3{Hungarian: lm}
*******************************************************************************************/
DeclareInterface(VwLayoutManager, Unknown, 13F3A421-4915-455b-B57F-AFD4073CFFA0)
{
	// A layout manager is informed by this method that the (primary) layout stream 'lay'
	// has determined that references to the objects prgguidObj occur on the page.
	// The input value of *pdysAvailHeight indicates how much of the height allocated
	// to 'lay' for this page will remain available if the text containing these
	// references is added to the page AND if adding them does not reduce the space
	// available for 'lay'.
	// The layout manager should take whatever action is needed to determine whether
	// these objects should be displayed in any dependent stream(s) on the same page, and if so,
	// how fitting them on the page alters the height available to the sending layout stream,
	// and return the modified available height.
	// If the available height would become negative (typically because the objects
	// must share space with 'lay' and they don't fit in the available height),
	// normally the layout manager will set *pfFailed to true.
	// If this is not acceptable, typically because it would result in an empty page
	// (that is, nothing at all from the 'lay' stream will fit on the page without
	// including these objects), fAllowFail is passed as false. In this case, the
	// layout manager must somehow accept the objects, perhaps by splitting a note
	// across pages or truncating or omitting some, or something comparably drastic.

	// Note that it is the layout manager's responsibility to determine which dependent
	// stream(s) (if any) will display this object, and how that will impact the primary.
	// The most common example is footnotes, where the space they occupy must be subtracted
	// from the space available for the primrary document, unless perhaps the foonote
	// fits in another column that is not yet being filled. Another example, however, could
	// be a column of cross-references, where the space available for the primary is
	// not changed unless the cross-reference column overflows, in which case the root site
	// just indicates that this block of object refs won't fit.
	HRESULT AddDependentObjects(
		[in] IVwLayoutStream * play,
		[in] IVwGraphics * pvg,
		[in] int hPage,
		[in] int cguid,
		[in, size_is(cguid)] GUID * prgguidObj,
		[in] ComBool fAllowFail,
		[out] ComBool * pfFailed,
		[in, out] int * pdysAvailHeight);
	// Informs the layout manager that the specified page is broken. This is the most
	// drastic of several notifications, sent when the View code cannot determine
	// a more specific way to describe what has happened. For example, it may be that
	// there has been a change drastic enough to completely replace the paragraph at one
	// of the page boundaries. Or, material containing object references may have
	// been inserted or deleted.
	// Note that it is possible subsequent pages are also broken. The notification is
	// sent for all pages known to be broken, but the view code will not necessarily
	// know of all problems; for example, if the change on the first page causes
	// a footnote to move to the next page, this will not be detected. The layout manager
	// is responsible to figure out which other pages are broken.
	HRESULT PageBroken(
		[in] IVwLayoutStream * play,
		[in] int hPage);
	// Informs the layout manager that the page boundary at the end of the specified
	// page moved, without changing the size of the paragraph. This call is made
	// when editing occurs in the first part of a paragraph that is split across two pages,
	// and material is moved from one page to the other as a result, but the material
	// moved does not include any object references. (If it does include object refs,
	// PageBroken is called instead.)
	// Note that this change also affects the following page, if that has been
	// constructed. A notification about that would be redundant, so is not sent.
	// Note that the old character position within the affected paragraph is sent.
	// Information about the current page break position can be obtained by calling
	// methods of the layout stream.
	HRESULT PageBoundaryMoved(
		[in] IVwLayoutStream * play,
		[in] int hPage,
		[in] int ichOld);
	// Requests the layout manager for a current best estimate of the total height of the data,
	// given the specified width in pixels. When all pages have been laid out at the given width,
	// this should return the actual height.
	HRESULT EstimateHeight(
		[in] int dxpWidth,
		[out, retval] int * pdxpHeight);
};

/*******************************************************************************************
	Interface IIMEKeyboardSwitcher
	This interface is designed to allow changing the current IME keyboard in Linux from C++ code.
*******************************************************************************************/
DeclareInterface(IMEKeyboardSwitcher, Unknown, 4D2BC310-DADF-11DE-9E3A-0019DBF4566E)
{
	// Gets the name of the IMEKeyboard for the focued input context
	[propget] HRESULT IMEKeyboard(
		[out, retval] BSTR * pbstr);

	// Sets IMEKeyboard for the focused input context
	[propput] HRESULT IMEKeyboard(
		[in] BSTR pbstr);

	[propget] HRESULT IMEKeyboardsCount(
			[out, retval] int * pdCount);

	HRESULT GetKeyboardName(
			[in] int index,
			[out, retval] BSTR * pbstr);

	HRESULT Close();
}

	/*******************************************************************************************
		Interface IPictureFactory
		Allows creating a IPicture.
	*******************************************************************************************/
	DeclareInterface(PictureFactory, Unknown, 110B7E88-2968-11E0-B493-0019DBF4566E)
	{
		// Create an IPicture from a byte array.
		HRESULT ImageFromBytes(
			[in, size_is(cbData)] byte * pbData,
			[in] int cbData,
			[out,retval] IPicture ** pppic);
	}
#ifndef NO_COCLASSES
	DeclareCoClass(PictureFactory, 17A2E876-2968-11E0-8046-0019DBF4566E)
	{
		interface IPictureFactory;
	};
#endif // !NO_COCLASSES

	/*******************************************************************************************
		Interface IVwVirtualHandler
		This interface is implemented by objects that are used to define the meaning of a
		'virtual' property in a FieldWorks data cache, and to load the data required for the
		implementation of a virtual property.

		Virtual property behavior is currently implemented for atomic and sequence object
		properties, string, multistringalt, unicode, int, int64, and time properties.

		@h3{When to implement}
		Implement this interface when you have need to define a virtual property in a unique
		way. There are (planned to be!) existing implementations useful when the property is
		implemented by
		(a) Executing some SQL that returns a sequence of object IDs;
		(b) Sorting a collection (including backreference) property;
		(c) Reading/writing an FDO property.

		@h3{When to use}
		You may use this interface in the process of initializing a virtual handler; also,
		you may use the method that pre-loads the property data for an object sequence.
		Normally, the methods are mainly used by the data cache internally.

		@h3{How to obtain an instance}
		Create one of the standard implementations using CoCreateInstance or CreateInstance
		on a smart pointer (or new FwViewsLib.WhateverClass). Create your own implementations
		in the usual way.

		@h3{Hungarian: vnc}
	*******************************************************************************************/
	DeclareInterface(VwVirtualHandler, Unknown, 581E3FE0-F0C0-42A7-96C7-76B23B8BE580)
	{
		// Gets the name of the class that this is a virtual property of.
		[propget] HRESULT ClassName(
			[out, retval] BSTR * pbstr);
		// Sets the name of the class that this is a virtual property of. Normally set by
		// whatever creates the handler. The cache does not call this, so it may be
		// left unimplemented if there is a more convenient way to initialize the
		// property.
		[propput] HRESULT ClassName(
			[in] BSTR bstr);
		// Gets the name of the field that this is a virtual property of.
		[propget] HRESULT FieldName(
			[out, retval] BSTR * pbstr);
		// Sets the name of the field that this is a virtual property of.
		// The cache does not call this, so it may be left unimplemented if there is a more
		// convenient way to initialize the property.
		[propput] HRESULT FieldName(
			[in] BSTR bstr);
		// Gets the identifier of the property (the value passed as tag to various methods
		// of ISilDataAccess and IVwCacheDa).
		[propget] HRESULT Tag(
			[out, retval] PropTag * ptag);
		// Sets the identifier of the property (the value passed as tag to various methods
		// of ISilDataAccess and IVwCacheDa). This is normally called by the cache when
		// the handler is installed.
		[propput] HRESULT Tag(
			[in] PropTag tag);
		// Gets the type of the property.
		[propget] HRESULT Type(
			[out, retval] int * pcpt);
		// Sets the type (from the CmTypes enumeration) of data stored in this virtual
		// property. (NOT the type plus kcptVirtual.)
		[propput] HRESULT Type(
			[in] int cpt);
		// Gets the whether the property can accept a write request.
		[propget] HRESULT Writeable(
			[out, retval] ComBool * pf);
		// Sets the whether the handler can accept a request to write the property. Normally set by
		// whatever creates the handler. The cache does not call this, so it may be left
		// unimplemented if there is some other way to initialize it (for example, it may be
		// inherent in a particular implementation; the SQL reader implementation is never
		// writeable.)
		[propput] HRESULT Writeable(
			[in] ComBool f);
		// Gets the whether the property should be computed every time it is needed.
		[propget] HRESULT ComputeEveryTime(
			[out, retval] ComBool * pf);
		// Sets the whether the handler should be invoked every time the property value is
		// wanted. This is useful for properties that are cheap to compute and change frequently.
		// For properties that are expensive to compute and change less often, the plan is that
		// the value returned will be cached, and the user will issue a refresh request when
		// the UI appears to be out of date.
		// The cache does not call this, so it may be left unimplemented if there is a more
		// convenient way to initialize the property.
		[propput] HRESULT ComputeEveryTime(
			[in] ComBool f);
		// Requests that the data for the property for a particular object should be loaded
		// into the cache. The cache may be presumed to also implement ISilDataAccess;
		// if the property is known to be a database one, it may further be presumed to
		// implement IVwOleDbDa.
		// Note that, if ComputeEveryTime is true, the cache will remove the property value
		// from the cache after reading it, to ensure that Load is called again next time.
		HRESULT Load(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ws,
			[in] IVwCacheDa * pcda);
		// Requests that the given object property be modified by replacing the objects
		// from ihvoMin to ihvoLim with the chvo objects in prghvo.
		// This is used for both atomic and sequence properties; for atomic ones, chvo is
		// either zero or one, ihvoMin is zero, and ihvoLim is zero or one.
		// If ComputeEveryTime is false, the cache will also write this value to itself,
		// AFTER calling this method. (Thus, to obtain the old value, you can read it from
		// the sda.)
		// For atomic properties, ihvoMin and ihvoLim are either both zero (if no value
		// was previously cached, or the value cached was zero, or ComputeEveryTime is true),
		// or 0 and 1 (if a non-zero value was previously cached). Note that this may not
		// be formally accurate: Load is not used to obtain the 'old' value of the property
		// before calling this method, so it is possible to get arguments of (0,0) when
		// reading the property would produce a non-zero value.
		HRESULT Replace(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ihvoMin,
			[in] int ihvoLim,
			[in, size_is(chvo)] HVO * prghvo,
			[in] int chvo,
			[in] ISilDataAccess * psda);
		// Requests that the given object be written as the new value of the property.
		// This is currently used for string and MultiString properties (ws is zero for
		// string ones), but may eventually be used for other types, so the argument
		// type has been kept general.
		// If ComputeEveryTime is false, the cache will also write this value to itself,
		// AFTER calling this method. (Thus, to obtain the old value, you can read it from
		// the sda.)
		HRESULT WriteObj(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] int ws,
			[in] IUnknown * punk,
			[in] ISilDataAccess * psda);
		// Requests that the given Integer be written as the new value of the property.
		// This is used for all kinds of integer property, including regular ints and times.
		// If ComputeEveryTime is false, the cache will also write this value to itself,
		// AFTER calling this method. (Thus, to obtain the old value, you can read it from
		// the sda.)
		HRESULT WriteInt64(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] __int64 val,
			[in] ISilDataAccess * psda);
		// Requests that the given bstr be written as the new value of the property.
		// This is used for Unicode properties, and may eventually be used (with an
		// exact 8-character value) for GUID ones, and possibly for binary ones also.
		// If ComputeEveryTime is false, the cache will also write this value to itself,
		// AFTER calling this method. (Thus, to obtain the old value, you can read it from
		// the sda.)
		HRESULT WriteUnicode(
			[in] HVO hvo,
			[in] PropTag tag,
			[in] BSTR bstr,
			[in] ISilDataAccess * psda);
		// This requests that data should be loaded into the cached so that this property may
		// be efficiently computed for all the objects in the array.
		// The main purpose of this is so that a single SQL query may be used to load the data
		// for a longs sequence of objects, which can be much faster than issuing a separate
		// query for each one.
		// The method may actually load the cache with a value for property Tag for each object
		// in prghvo. If this is done, Load() will never be called for any of these objects
		// (possibly even if, pathologically in such a case, ComputeEveryTime is true).
		// It may also do nothing, in which case, Load() will be called for every object when
		// the value is (first) needed. This is fine if Load() works correctly and no
		// performance problems result.
		// It may also load other data (typically data on which the computation of property
		// Tag is based) without actually setting a value for property Tag. In this case,
		// Load will be called normally, but hopefully will work more efficiently because
		// the other data is preloaded.
		HRESULT PreLoad(
			[in] int chvo,
			[in, size_is(chvo)] HVO * prghvo,
			[in] PropTag tag,
			[in] int ws,
			[in] IVwCacheDa * pcda);
		// This method is not called by the cache and may be left unimplemented. Its use, if any,
		// is up to a particular implementation. It is included in the interface so that standard
		// implementations may be initialized without defining an additional interface.
		HRESULT Initialize(
			[in] BSTR bstrData);

		// This method may be implemented to inform callers that the results computed by
		// a virtual handler are affected by a property change. (Many implementers do not
		// implement this comprehensively and just return false.)
		HRESULT DoesResultDependOnProp(
			[in] HVO hvoObj, // object having the virtual property
			[in] HVO hvoChange, // object that changed.
			[in] PropTag tag, // property that changed.
			[in] int ws, // writing system that changed (if relevant)
			[out, retval] ComBool * pfDepends);

		// When fLoadAll is true, the virtual handler may try to preload all of its data on the
		// first subsequent call to Load even if ComputeEveryTime is true.  When fLoadAll is
		// false, the virtual handler will unload all data loaded as a result of a prior call
		// with fLoadAll set to true.  (Note that if ComputeEveryTime is true, the Views code
		// will still remove the value from the cache after using it. Therefore the handler must
		// retain its own copy of the preloaded data until the call to
		// SetLoadForAllOfClass(false).
		// Typically, therefore, data is put into the actual cache only one property at a time;
		// but it may be loaded into some private memory of the handler in advance, often with
		// significant time savings. If ComputeEveryTime is false, the first Load call may
		// simply load the data into the main cache for all objects.)  A handler may also simply
		// ignore this setting, if it will not benefit by preloading data for all objects.
		HRESULT SetLoadForAllOfClass(
			[in] ComBool fLoadAll);
	};

	// Specifies the source of the field in the MetaDataCache.
	// @h3{Hungarian fs}
	typedef [v1_enum] enum FieldSource
	{
		kModel = 0, // Comes for the UML model
		kCustom = 1, // Added by the user
		kVirtual = 2, // Added by program
	} FieldSource;

	/*******************************************************************************************
		Interface IVwWindow
		COM interface that wraps a Window handle/HWND
		Allows cross platform querying of Window properties
	*******************************************************************************************/
	DeclareInterface(VwWindow, Unknown, 8856396c-63a9-4bc7-ad47-87ec8b6ef5a4)
	{
		[propput] HRESULT Window([in] DWORD * hwnd);

		HRESULT GetClientRectangle(
			[out] RECT * prcClientRectangle);
	}

	#ifndef NO_COCLASSES
	DeclareCoClass(VwWindow, 3fb0fcd2-ac55-42a8-b580-73b89a2b6215)
	{
		interface IVwWindow;
	};
	#endif // !NO_COCLASSES


typedef [v1_enum] enum VwMouseEvent
{
	// Mouse event types that we can identify from info passed to us.
	kmeDown, // no shift, main button
	kmeDblClick, // assume no shift, main button
	kmeMoveDrag, // mouse move, main button down, assume no modifiers
	kmeExtend, // main click, shift down
	kmeUp, // main button up.
} VwMouseEvent; // Hungarian me

/*******************************************************************************************
	Interface IViewInputMgr

	Allows interacting with input methods/keyboards in a cross-platform compatible way.
*******************************************************************************************/
DeclareInterface(ViewInputMgr, Unknown, e41668f7-d506-4c8a-a5d7-feae5630797e)
{
	HRESULT Init(
		[in] IVwRootBox * prootb);

	HRESULT Close();

	// End all active compositions.
	HRESULT TerminateAllCompositions();

	// Activate the input method by setting the focus.
	HRESULT SetFocus();

	// Deactivate the input method when the focus moves elsewhere.
	HRESULT KillFocus();

	// Returns true while a composition window is active.
	[propget] HRESULT IsCompositionActive(
		[out, retval] ComBool * pfCompositionActive);

	// Returns true while the input method is in the process of closing a composition
	// window.
	[propget] HRESULT IsEndingComposition(
		[out, retval] ComBool * pfEnding);

	// Called before a property gets updated. If this method returns true the property
	// should be updated without normalization (i.e. not updated in the database) in order
	// to avoid messing up compositions.
	HRESULT OnUpdateProp(
		[out, retval] ComBool * pfProcessed);

	// Called when the a mouse event happened.
	HRESULT OnMouseEvent(
		[in] int xd,
		[in] int yd,
		[in] RECT rcSrc,
		[in] RECT rcDst,
		[in] VwMouseEvent me,
		[out, retval] ComBool * pfProcessed);

	// Called when the layout (on-screen representation) of the document changes.
	HRESULT OnLayoutChange();

	// Called when the selection within the document changes.
	HRESULT OnSelectionChange(
		[in] int nHow);

	// Called when the text of a document changes.
	HRESULT OnTextChange();

	// VwRootBox will need to do these
	// HRESULT AddToKeepList(li)
	// HRESULT ClearPointersTo(VwParagraphBox)
}
