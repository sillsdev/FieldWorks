<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
   <xsl:output method="text" version="1.0" encoding="UTF-8" indent="yes"/>
   <!--
================================================================
M3 to XAmple Word Grammar File mapper for Stage 1.
  Input:    XML output from M3ParserSvr which has been passed through CleanFWDump.xslt
  Output: XAmple Word Grammar file

Note: the comments which contain a section number (e.g. 3.1.2) refer to the design
document for this mapping.
================================================================
Revision History is at the end of this file.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Preamble
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->

	<xsl:variable name="root" select="/M3Dump"/>
	<xsl:variable name="compRules" select="$root/CompoundRules"/>
	<xsl:variable name="lexicon" select="$root/Lexicon"/>
	<xsl:variable name="allos" select="$lexicon/Allomorphs"/>
	<xsl:variable name="analyses" select="$lexicon/MorphoSyntaxAnalyses"/>
	<xsl:variable name="entries" select="$lexicon/Entries"/>
	<xsl:variable name="LexEntries" select="$entries/LexEntry"/>
   <xsl:variable name="lexEntryInflTypes" select="$root/LexEntryInflTypes/LexEntryInflType"/>

   <!-- Using keys instead of IDs (so no DTD or XSD required) -->
   <xsl:key name="FSID" match="FS" use="@Id"/><!-- this looks like a mistake, but Andy will have to fix it. -->
   <xsl:key name="InflClassID" match="MoInflClass" use="@Id"/>
   <xsl:key name="POSID" match="PartOfSpeech" use="@Id"/>
   <xsl:key name="SlotsID" match="MoInflAffixSlot" use="@Id"/>
   <xsl:key name="StemMsaID" match="MoStemMsa" use="@Id"/>
   <xsl:key name="StemNameID" match="MoStemName" use="@Id"/>
   <xsl:key name="AnyId" match="*" use="@id"/>
   <!-- included stylesheets (i.e. things common to other style sheets) -->
   <xsl:include href="XAmpleTemplateVariables.xsl"/>
   <xsl:include href="CalculateStemNamesUsedInLexicalEntries.xsl"/>
	<xsl:include href="FxtM3ParserCommon.xsl"/>
	<xsl:variable name="sAffixAlloWithFeaturesLogicalConstraint">
	  <xsl:call-template name="AffixAlloWithFeaturesLogicalConstraint"/>
   </xsl:variable>
	<xsl:variable name="affixAllosWithFeatures" select="$allos/MoAffixAllomorph/MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]"/>
   <!--
	  TO DO: refactor so it is not just one long item
   -->
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Main template
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template match="/">
	  <!-- 3.1.1	Initial Comment -->
| DO NOT EDIT THIS FILE DIRECTLY!
|
<!-- 3.1.2	Top-level Word -->
| ------------------------------------------------------------
|                TOP-LEVEL WORD
| ------------------------------------------------------------
rule {Top-level cliticless word}
  OrthographicWord = Word
								| percolation
		&lt;OrthographicWord synCat&gt;       = &lt;Word synCat&gt;
		&lt;OrthographicWord morphoSyntax&gt; = &lt;Word morphoSyntax&gt;

rule {Top-level word with one or more proclitics and enclitics}
  OrthographicWord = Proclitics Word Enclitics
								| percolation
		&lt;OrthographicWord synCat&gt;       = &lt;Word synCat&gt;
		&lt;OrthographicWord morphoSyntax&gt; = &lt;Word morphoSyntax&gt;
		&lt;OrthographicWord proclitics morphoSyntax&gt; = &lt;Proclitics morphoSyntax&gt;
		&lt;OrthographicWord enclitics morphoSyntax&gt; = &lt;Enclitics morphoSyntax&gt;
								| drip (pass down)
		&lt;Word synCat&gt;       = &lt;Proclitics synCat&gt;
		&lt;Word synCat&gt;       = &lt;Enclitics synCat&gt;

rule {Top-level word with one or more proclitics}
  OrthographicWord = Proclitics Word
								| percolation
		&lt;OrthographicWord synCat&gt;       = &lt;Word synCat&gt;
		&lt;OrthographicWord morphoSyntax&gt; = &lt;Word morphoSyntax&gt;
		&lt;OrthographicWord proclitics morphoSyntax&gt; = &lt;Proclitics morphoSyntax&gt;
								| drip (pass down)
		&lt;Word synCat&gt;       = &lt;Proclitics synCat&gt;

rule {Top-level word with one or more enclitics}
  OrthographicWord =            Word Enclitics
								| percolation
		&lt;OrthographicWord synCat&gt;       = &lt;Word synCat&gt;
		&lt;OrthographicWord morphoSyntax&gt; = &lt;Word morphoSyntax&gt;
		&lt;OrthographicWord enclitics morphoSyntax&gt; = &lt;Enclitics morphoSyntax&gt;
								| drip (pass down)
		&lt;Word synCat&gt;       = &lt;Enclitics synCat&gt;

<!-- 3.1.3	Clitics -->
| ------------------------------------------------------------
|                CLITICS
| ------------------------------------------------------------
rule {One or more proclitics}
  Proclitics_1 = proclitic (Proclitics_2)
								| percolation
		&lt;Proclitics_1 morphoSyntax&gt; = &lt;proclitic morphoSyntax&gt;
								| drip (pass down)
		&lt;Proclitics_1 synCat&gt;       = &lt;Proclitics_2 synCat&gt;
								| constraints
		&lt;Proclitics_2 morphoSyntax&gt; = &lt;proclitic morphoSyntax&gt;
		&lt;Proclitics_1 synCat&gt;       = &lt;proclitic fromCat&gt;

rule {One or more enclitics}
  Enclitics_1  = (Enclitics_2) enclitic
								| percolation
		&lt;Enclitics_1 morphoSyntax&gt; = &lt;enclitic morphoSyntax&gt;
								| drip (pass down)
		&lt;Enclitics_1 synCat&gt;       = &lt;Enclitics_2 synCat&gt;
								| constraints
		&lt;Enclitics_2 morphoSyntax&gt; = &lt;enclitic morphoSyntax&gt;
		&lt;Enclitics_1 synCat&gt;       = &lt;enclitic fromCat&gt;

<!-- 3.1.4	Word -->
| ------------------------------------------------------------
|                WORD
| ------------------------------------------------------------
rule {clitic word}
  Word = clitic
								| percolation
		&lt;Word synCat&gt;       = &lt;clitic rootCat&gt;
		&lt;Word morphoSyntax&gt; = &lt;clitic morphoSyntax&gt;

rule {Fully analyzed word}
  Word = Full
								| percolation
		&lt;Word synCat&gt;       = &lt;Full synCat&gt;
		&lt;Word morphoSyntax&gt; = &lt;Full morphoSyntax&gt;
		&lt;Full&gt; == [requiresInflection : -] /  | doesn't require inflection or
				  [inflected : +]             | is inflected

rule {Partially analyzed word}
  Word = Partial
								| percolation
		&lt;Word synCat&gt;       = &lt;Partial synCat&gt;
		&lt;Word morphoSyntax&gt; = &lt;Partial morphoSyntax&gt;
<!-- 3.1.5	Fully Analyzed Word Portion -->
| ------------------------------------------------------------
|                FULLY ANALYZED WORD PORTION
| ------------------------------------------------------------
<!-- 3.1.5.1	Non-inflected, Fully Analyzed Stem -->
	  <xsl:if test="$PartsOfSpeech/AffixTemplates[not(MoInflAffixTemplate)]">
rule {Fully analyzed stem with no inflectional template}
  Full = Stem
								| percolation
		&lt;Full synCat&gt;       = &lt;Stem synCat&gt;
		&lt;Full morphoSyntax&gt; = &lt;Stem morphoSyntax&gt;
		&lt;Full stratum&gt;      = &lt;Stem stratum&gt;
		&lt;Full requiresInflection&gt; = &lt;Stem requiresInflection&gt;
						  | constraint
		&lt;Full inflected&gt;    = -  | this Full word category is not inflected
		&lt;Stem blocksInflection&gt; = - | prevent a non-final template from immediately being inflected without any intervening derivation or compounding
</xsl:if>
	  <!-- 3.1.5.2	Inflected, Fully Analyzed Stem -->
	  <xsl:for-each select="$PartsOfSpeech">
		 <xsl:variable name="posID" select="@Id"/>
		 <xsl:for-each select="AffixTemplates/MoInflAffixTemplate[@Final='true']">
			<xsl:if test="count(PrefixSlots | SuffixSlots)>0">
rule {Fully analyzed stem with a final inflectional template <xsl:value-of select="@Id"/>}
  Full = <xsl:variable name="sAllSlotsOptional">
				  <xsl:for-each select="PrefixSlots | SuffixSlots">
					 <xsl:if test="key('SlotsID',@dst)/@Optional='false'">N</xsl:if>
				  </xsl:for-each>
			   </xsl:variable>
			   <xsl:call-template name="AffixTemplateSlotsPSR">
				  <xsl:with-param name="Slots" select="PrefixSlots"/>
				  <xsl:with-param name="sAllSlotsOptional" select="$sAllSlotsOptional"/>
				  <xsl:with-param name="bPrefix">Y</xsl:with-param>
				  <xsl:with-param name="sType">F</xsl:with-param>
			   </xsl:call-template> Stem<xsl:call-template name="AffixTemplateSlotsPSR">
				  <xsl:with-param name="Slots" select="SuffixSlots"/>
				  <xsl:with-param name="sAllSlotsOptional" select="$sAllSlotsOptional"/>
				  <xsl:with-param name="bPrefix">N</xsl:with-param>
				  <xsl:with-param name="sType">F</xsl:with-param>
			   </xsl:call-template>
														 | percolation
  &lt;Full synCat&gt;       = &lt;Stem synCat&gt;
  &lt;Full morphoSyntax&gt; = &lt;Stem morphoSyntax&gt;
  &lt;Full inflected&gt;    = +
  &lt;Full requiresInflection&gt; = -
						  | constraints
  &lt;Stem blocksInflection&gt; = - | prevent a non-final template from immediately being inflected without any intervening derivation or compounding
<xsl:variable name="NestedPOS" select="../../SubPossibilities"/>
			   <xsl:if test="count($NestedPOS)>0">{
  &lt;Stem  synCat&gt;       = <xsl:value-of select="../../@Id"/>
				  <xsl:call-template name="NestedPOSids">
					 <xsl:with-param name="pos" select="../../@Id"/>
					 <xsl:with-param name="sType" select="'Full'"/>
				  </xsl:call-template>
}</xsl:if>
			   <xsl:if test="count($NestedPOS)=0">  &lt;Stem  synCat&gt;       = <xsl:value-of select="../../@Id"/>
			   </xsl:if>
			   <xsl:call-template name="AffixTemplateSlotsConstraints">
				  <xsl:with-param name="Slots" select="PrefixSlots"/>
				  <xsl:with-param name="bPrefix">Y</xsl:with-param>
				  <xsl:with-param name="bFull">Y</xsl:with-param>
			   </xsl:call-template>
			   <xsl:call-template name="AffixTemplateSlotsConstraints">
				  <xsl:with-param name="Slots" select="SuffixSlots"/>
				  <xsl:with-param name="bPrefix">N</xsl:with-param>
				  <xsl:with-param name="bFull">Y</xsl:with-param>
			   </xsl:call-template>
			   <xsl:call-template name="StemNameConstraints">
				  <xsl:with-param name="posID" select="$posID"/>
			   </xsl:call-template>
			   <xsl:call-template name="AffixAlloWithFeaturesConstraints">
				  <xsl:with-param name="sNonTerm" select="'Full'"/>
			   </xsl:call-template>
			   <!-- determine default feature values for this PartOfSpeech and every PartOfSpeech for which it is a subpossibility -->
			   <!-- later...
<xsl:for-each select="../../PartOfSpeech | PartOfSpeech[SubPossibilities/@dst=../../@Id]">
<xsl:text>
						  | default values
</xsl:text>
<xsl:for-each select="DefaultFeatures">

</xsl:for-each>
</xsl:for-each>
-->
			</xsl:if>
		 </xsl:for-each>
		 <xsl:for-each select="AffixTemplates/MoInflAffixTemplate[@Final='false']">
			<xsl:if test="count(PrefixSlots | SuffixSlots)>0">
rule {Fully analyzed stem with a non-final inflectional template <xsl:value-of select="@Id"/>}
  Stem_1 = <xsl:variable name="sAllSlotsOptional">
				  <xsl:for-each select="PrefixSlots | SuffixSlots">
					 <xsl:if test="key('SlotsID',@dst)/@Optional='false'">N</xsl:if>
				  </xsl:for-each>
			   </xsl:variable>
			   <xsl:call-template name="AffixTemplateSlotsPSR">
				  <xsl:with-param name="Slots" select="PrefixSlots"/>
				  <xsl:with-param name="sAllSlotsOptional" select="$sAllSlotsOptional"/>
				  <xsl:with-param name="bPrefix">Y</xsl:with-param>
				  <xsl:with-param name="sType">S</xsl:with-param>
			   </xsl:call-template> Stem_2<xsl:call-template name="AffixTemplateSlotsPSR">
				  <xsl:with-param name="Slots" select="SuffixSlots"/>
				  <xsl:with-param name="sAllSlotsOptional" select="$sAllSlotsOptional"/>
				  <xsl:with-param name="bPrefix">N</xsl:with-param>
				  <xsl:with-param name="sType">S</xsl:with-param>
			   </xsl:call-template>
														 | percolation
  &lt;Stem_1 synCat&gt;       = &lt;Stem_2 synCat&gt;
  &lt;Stem_1 morphoSyntax&gt; = &lt;Stem_2 morphoSyntax&gt;
  &lt;Stem_1 inflected&gt;    = -
  &lt;Stem_1 requiresInflection&gt; = &lt;Stem_2 requiresInflection&gt;
  &lt;Stem_1 inflectionClass&gt; = &lt;Stem_2 inflectionClass&gt;
  &lt;Stem_1 blocksInflection&gt; = + | prevent a non-final template from immediately being inflected without any intervening derivation or compounding
						  | constraints
  &lt;Stem_2 blocksInflection&gt; = - | prevent a non-final template from immediately being inflected without any intervening derivation or compounding
<xsl:variable name="NestedPOS" select="../../SubPossibilities"/>
			   <xsl:if test="count($NestedPOS)>0">{
  &lt;Stem_1  synCat&gt;       = <xsl:value-of select="../../@Id"/>
				  <xsl:call-template name="NestedPOSids">
					 <xsl:with-param name="pos" select="../../@Id"/>
					 <xsl:with-param name="sType" select="'Stem_1'"/>
				  </xsl:call-template>
}</xsl:if>
			   <xsl:if test="count($NestedPOS)=0">  &lt;Stem_1  synCat&gt;       = <xsl:value-of select="../../@Id"/>
			   </xsl:if>
			   <xsl:call-template name="AffixTemplateSlotsConstraints">
				  <xsl:with-param name="Slots" select="PrefixSlots"/>
				  <xsl:with-param name="bPrefix">Y</xsl:with-param>
				  <xsl:with-param name="bFull">Y</xsl:with-param>
				  <xsl:with-param name="bStem">N</xsl:with-param>
				  <xsl:with-param name="sNonTerm" select="'Stem_1'"/>
			   </xsl:call-template>
			   <xsl:call-template name="AffixTemplateSlotsConstraints">
				  <xsl:with-param name="Slots" select="SuffixSlots"/>
				  <xsl:with-param name="bPrefix">N</xsl:with-param>
				  <xsl:with-param name="bFull">Y</xsl:with-param>
				  <xsl:with-param name="bStem">N</xsl:with-param>
				  <xsl:with-param name="sNonTerm" select="'Stem_1'"/>
			   </xsl:call-template>
			   <xsl:call-template name="StemNameConstraints">
				  <xsl:with-param name="posID" select="$posID"/>
				  <xsl:with-param name="leftNT" select="'Stem_1'"/>
				  <xsl:with-param name="rightNT" select="'Stem_2'"/>
			   </xsl:call-template>
			   <xsl:call-template name="AffixAlloWithFeaturesConstraints">
				  <xsl:with-param name="sNonTerm" select="'Stem_1'"/>
			   </xsl:call-template>
			   <!-- determine default feature values for this PartOfSpeech and every PartOfSpeech for which it is a subpossibility -->
			   <!-- later...
<xsl:for-each select="../../PartOfSpeech | PartOfSpeech[SubPossibilities/@dst=../../@Id]">
<xsl:text>
						  | default values
</xsl:text>
<xsl:for-each select="DefaultFeatures">

</xsl:for-each>
</xsl:for-each>
-->
			</xsl:if>
		 </xsl:for-each>
	  </xsl:for-each>
	  <!-- 3.1.5.3	Fully Analyzed Stems -->
| ------------------------------------------------------------
|                STEM
| ------------------------------------------------------------
<!-- 3.1.5.3.1	Stem as a Root -->
rule {Stem consisting of a single root}
  Stem = root
					| percolation
		&lt;Stem synCat&gt;          = &lt;root rootCat&gt;
		&lt;Stem morphoSyntax&gt;    = &lt;root morphoSyntax&gt;
		&lt;Stem inflectionClass&gt; = &lt;root inflectionClass&gt;
		&lt;Stem stratum&gt;         = &lt;root stratum&gt;
		&lt;Stem requiresInflection&gt; = &lt;root requiresInflection&gt;
		&lt;Stem stemName&gt;   = &lt;root stemName&gt;
		&lt;Stem exception&gt;       = &lt;root exception&gt;
		&lt;root&gt; == ~[rootCat : unknown]  | root category has to be overt

<!-- 3.1.5.3.2	Stem with Derivational Affixes -->
	  <!-- (Note: only using at most one stratum for this stage.) -->
	  <xsl:text>
rule {Stem with a derivational prefix}
  Stem_1 = derivPfx Stem_2
								| percolation
		&lt;Stem_1 synCat&gt;           = &lt;Stem_2 synCat&gt; | default to Stem 2 (in case deriv prefix has no category)
		&lt;Stem_1 synCat&gt;           &lt;= &lt;derivPfx toCat&gt; | use priority union to override anything in Stem_2
		&lt;Stem_1 morphoSyntax&gt;     = &lt;Stem_2 morphoSyntax&gt;
		&lt;Stem_1 stratum&gt;          = &lt;derivPfx stratum&gt;
		&lt;Stem_1 requiresInflection&gt; = &lt;Stem_2 requiresInflection&gt; | default to stem 2 (in case deriv prefix has no to category)
		&lt;Stem_1 requiresInflection&gt; &lt;= &lt;derivPfx requiresInflection&gt; | use deriv prefix when it has a category
		&lt;Stem_1 exception&gt;        = &lt;Stem_2 exception&gt;
		&lt;Stem_1 stemName&gt;         = &lt;Stem_2 stemName&gt;
		&lt;Stem_1 morphoSyntax&gt;    &lt;= &lt;derivPfx toMorphoSyntax&gt;
		&lt;Stem_1 inflectionClass&gt; = &lt;Stem_2 inflectionClass&gt;
		&lt;Stem_1 inflectionClass&gt; &lt;= &lt;derivPfx toInflectionClass&gt;
		&lt;Stem_1 exception&gt;       &lt;= &lt;derivPfx toException&gt;
		&lt;Stem_1 blocksInflection&gt; = - | This stem can now be inflected
								| constraints
		&lt;Stem_2 morphoSyntax&gt;     = &lt;derivPfx fromMorphoSyntax&gt;
		&lt;Stem_2 inflectionClass&gt;  = &lt;derivPfx fromInflectionClass&gt;
		&lt;Stem_2 stemName&gt;         = &lt;derivPfx stemName&gt;
		&lt;Stem_2 exception&gt;        = &lt;derivPfx fromException&gt;</xsl:text>
		{
		<xsl:call-template
		 name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivPfx</xsl:with-param>
	  </xsl:call-template>
	  }<xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
		 <xsl:with-param name="sAffixNode" select="'derivPfx'"/>
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:call-template name="AffixAlloWithFeaturesConstraints">
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:text>

rule {Stem with a derivational suffix}
  Stem_1 =          Stem_2 derivSfx
								| percolation
		&lt;Stem_1 synCat&gt;           = &lt;Stem_2 synCat&gt; | default to Stem 2 (in case deriv suffix has no to category)
		&lt;Stem_1 synCat&gt;           &lt;= &lt;derivSfx toCat&gt; | use priority union to override anything in Stem_2
		&lt;Stem_1 morphoSyntax&gt;     = &lt;Stem_2 morphoSyntax&gt;
		&lt;Stem_1 stratum&gt;          = &lt;derivSfx stratum&gt;
		&lt;Stem_1 requiresInflection&gt; = &lt;Stem_2 requiresInflection&gt; | default to stem 2 (in case deriv suffix has no to category)
		&lt;Stem_1 requiresInflection&gt; &lt;= &lt;derivSfx requiresInflection&gt; | use deriv suffix when it has a category
		&lt;Stem_1 exception&gt;        = &lt;Stem_2 exception&gt;
		&lt;Stem_1 stemName&gt;         = &lt;Stem_2 stemName&gt;
		&lt;Stem_1 morphoSyntax&gt;    &lt;= &lt;derivSfx toMorphoSyntax&gt;
		&lt;Stem_1 inflectionClass&gt; = &lt;Stem_2 inflectionClass&gt;
		&lt;Stem_1 inflectionClass&gt; &lt;= &lt;derivSfx toInflectionClass&gt;
		&lt;Stem_1 exception&gt;       &lt;= &lt;derivSfx toException&gt;
		&lt;Stem_1 blocksInflection&gt; = - | This stem can now be inflected
								| constraints
		&lt;Stem_2 morphoSyntax&gt;     = &lt;derivSfx fromMorphoSyntax&gt;
		&lt;Stem_2 inflectionClass&gt;  = &lt;derivSfx fromInflectionClass&gt;
		&lt;Stem_2 stemName&gt;         = &lt;derivSfx stemName&gt;
		&lt;Stem_2 exception&gt;        = &lt;derivSfx fromException&gt;</xsl:text>
		{
		<xsl:call-template
		 name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivSfx</xsl:with-param>
	  </xsl:call-template>
	  }<xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
		 <xsl:with-param name="sAffixNode" select="'derivSfx'"/>
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:call-template name="AffixAlloWithFeaturesConstraints">
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:text>
rule {Stem with a derivational circumfix}
		 Stem_1 = derivCircumPfx Stem_2 derivCircumSfx
		 | percolation
		 &lt;Stem_1 synCat&gt;           = &lt;Stem_2 synCat&gt; | default to Stem 2 (in case deriv circumfixes have no to category)
		 &lt;Stem_1 synCat&gt;           &lt;= &lt;derivCircumPfx toCat&gt; | use priority union to override anything in Stem_2
		 &lt;Stem_1 synCat&gt;           &lt;= &lt;derivCircumSfx toCat&gt;
		 &lt;Stem_1 morphoSyntax&gt;     = &lt;Stem_2 morphoSyntax&gt;
		 &lt;Stem_1 stratum&gt;          = &lt;derivCircumPfx stratum&gt;
		 &lt;Stem_1 stratum&gt;          = &lt;derivCircumSfx stratum&gt;
		 &lt;Stem_1 requiresInflection&gt; = &lt;Stem_2 requiresInflection&gt; | default to stem 2 (in case deriv prefix has no category)
		 &lt;Stem_1 requiresInflection&gt; &lt;= &lt;derivCircumPfx requiresInflection&gt; | use deriv prefix when it has a category
		 &lt;Stem_1 requiresInflection&gt; &lt;= &lt;derivCircumSfx requiresInflection&gt; | use deriv suffix when it has a category
		 &lt;Stem_1 exception&gt;        = &lt;Stem_2 exception&gt;
		 &lt;Stem_1 stemName&gt;         = &lt;Stem_2 stemName&gt;
		 &lt;Stem_1 morphoSyntax&gt;    &lt;= &lt;derivCircumPfx toMorphoSyntax&gt;
		 &lt;Stem_1 morphoSyntax&gt;    &lt;= &lt;derivCircumSfx toMorphoSyntax&gt;
		 &lt;Stem_1 inflectionClass&gt; = &lt;Stem_2 inflectionClass&gt;
		 &lt;Stem_1 inflectionClass&gt; &lt;= &lt;derivCircumPfx toInflectionClass&gt;
		 &lt;Stem_1 inflectionClass&gt; &lt;= &lt;derivCircumSfx toInflectionClass&gt;
		 &lt;Stem_1 exception&gt;       &lt;= &lt;derivCircumPfx toException&gt;
		 &lt;Stem_1 exception&gt;       &lt;= &lt;derivCircumSfx toException&gt;
		 &lt;Stem_1 blocksInflection&gt; = - | This stem can now be inflected
		 | constraints
		 &lt;Stem_2 morphoSyntax&gt;     = &lt;derivCircumPfx fromMorphoSyntax&gt;
		 &lt;Stem_2 morphoSyntax&gt;     = &lt;derivCircumSfx fromMorphoSyntax&gt;
		 &lt;Stem_2 inflectionClass&gt;  = &lt;derivCircumPfx fromInflectionClass&gt;
		 &lt;Stem_2 inflectionClass&gt;  = &lt;derivCircumSfx fromInflectionClass&gt;
		 &lt;Stem_2 stemName&gt;         = &lt;derivCircumPfx stemName&gt;
		 &lt;Stem_2 stemName&gt;         = &lt;derivCircumSfx stemName&gt;
		 &lt;Stem_2 exception&gt;        = &lt;derivCircumPfx fromException&gt;
		 &lt;Stem_2 exception&gt;        = &lt;derivCircumSfx fromException&gt;</xsl:text>
	  {
	  <xsl:call-template
		 name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivCircumPfx</xsl:with-param>
		 <xsl:with-param name="sSecondNode">derivCircumSfx</xsl:with-param>
	  </xsl:call-template>
	  }
	  <xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
		 <xsl:with-param name="sAffixNode" select="'derivCircumPfx'"/>
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
		 <xsl:with-param name="sAffixNode" select="'derivCircumSfx'"/>
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:call-template name="AffixAlloWithFeaturesConstraints">
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:text>
rule {Stem with a derivational circumfix where the rightmost part is an infix (and so may end up as a prefix}
		 Stem_1 = derivCircumPfx_1 derivCircumPfx_2 Stem_2
		 | percolation
		 &lt;Stem_1 synCat&gt;           = &lt;Stem_2 synCat&gt; | default to Stem 2 (in case deriv circumfixes have no to category)
		 &lt;Stem_1 synCat&gt;           &lt;= &lt;derivCircumPfx_1 toCat&gt; | use priority union to override anything in Stem_2
		 &lt;Stem_1 synCat&gt;           &lt;= &lt;derivCircumPfx_2 toCat&gt;
		 &lt;Stem_1 morphoSyntax&gt;     = &lt;Stem_2 morphoSyntax&gt;
		 &lt;Stem_1 stratum&gt;          = &lt;derivCircumPfx_1 stratum&gt;
		 &lt;Stem_1 stratum&gt;          = &lt;derivCircumPfx_2 stratum&gt;
		 &lt;Stem_1 requiresInflection&gt; = &lt;Stem_2 requiresInflection&gt; | default to stem 2 (in case deriv prefix has no category)
		 &lt;Stem_1 requiresInflection&gt; &lt;= &lt;derivCircumPfx_1 requiresInflection&gt; | use deriv prefix when it has a category
		 &lt;Stem_1 requiresInflection&gt; &lt;= &lt;derivCircumPfx_2 requiresInflection&gt; | use deriv suffix when it has a category
		 &lt;Stem_1 exception&gt;        = &lt;Stem_2 exception&gt;
		 &lt;Stem_1 stemName&gt;         = &lt;Stem_2 stemName&gt;
		 &lt;Stem_1 morphoSyntax&gt;    &lt;= &lt;derivCircumPfx_1 toMorphoSyntax&gt;
		 &lt;Stem_1 morphoSyntax&gt;    &lt;= &lt;derivCircumPfx_2 toMorphoSyntax&gt;
		 &lt;Stem_1 inflectionClass&gt; = &lt;Stem_2 inflectionClass&gt;
		 &lt;Stem_1 inflectionClass&gt; &lt;= &lt;derivCircumPfx_1 toInflectionClass&gt;
		 &lt;Stem_1 inflectionClass&gt; &lt;= &lt;derivCircumPfx_2 toInflectionClass&gt;
		 &lt;Stem_1 exception&gt;       &lt;= &lt;derivCircumPfx_1 toException&gt;
		 &lt;Stem_1 exception&gt;       &lt;= &lt;derivCircumPfx_2 toException&gt;
		 &lt;Stem_1 blocksInflection&gt; = - | This stem can now be inflected
		 | constraints
		 &lt;Stem_2 morphoSyntax&gt;     = &lt;derivCircumPfx_1 fromMorphoSyntax&gt;
		 &lt;Stem_2 morphoSyntax&gt;     = &lt;derivCircumPfx_2 fromMorphoSyntax&gt;
		 &lt;Stem_2 inflectionClass&gt;  = &lt;derivCircumPfx_1 fromInflectionClass&gt;
		 &lt;Stem_2 inflectionClass&gt;  = &lt;derivCircumPfx_2 fromInflectionClass&gt;
		 &lt;Stem_2 stemName&gt;         = &lt;derivCircumPfx_1 stemName&gt;
		 &lt;Stem_2 stemName&gt;         = &lt;derivCircumPfx_2 stemName&gt;
		 &lt;Stem_2 exception&gt;        = &lt;derivCircumPfx_1 fromException&gt;
		 &lt;Stem_2 exception&gt;        = &lt;derivCircumPfx_2 fromException&gt;
		 | rightmost "prefix" must be an infix
		 &lt;derivCircumPfx_2&gt; == [morphType : infix]</xsl:text>
	  {
	  <xsl:call-template
		 name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivCircumPfx_1</xsl:with-param>
		 <xsl:with-param name="sSecondNode">derivCircumPfx_2</xsl:with-param>
	  </xsl:call-template>
	  }
	  <xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
		 <xsl:with-param name="sAffixNode" select="'derivCircumPfx_1'"/>
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
		 <xsl:with-param name="sAffixNode" select="'derivCircumPfx_2'"/>
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <xsl:call-template name="AffixAlloWithFeaturesConstraints">
		 <xsl:with-param name="sNonTerm" select="'Stem_2'"/>
	  </xsl:call-template>
	  <!-- 3.1.5.3.3	Compound Stems -->
	  <xsl:for-each select="$compRules/MoEndoCompound | $compRules/MoExoCompound">
		 <xsl:variable name="LeftMsa" select="key('StemMsaID',LeftMsa/@dst)"/>
		 <xsl:variable name="RightMsa" select="key('StemMsaID',RightMsa/@dst)"/>
		 <xsl:variable name="ToMsa" select="key('StemMsaID',ToMsa/@dst)"/>
		 <xsl:variable name="LeftPartOfSpeech" select="$LeftMsa/@PartOfSpeech"/>
		 <xsl:variable name="RightPartOfSpeech" select="$RightMsa/@PartOfSpeech"/>
		 <xsl:variable name="ToPartOfSpeech" select="$ToMsa/@PartOfSpeech"/>
		 <xsl:variable name="ToInflectionClass" select="$ToMsa/@InflectionClass"/>
		 <xsl:variable name="LeftNestedPOS" select="key('POSID', $LeftPartOfSpeech)/SubPossibilities"/>
		 <xsl:variable name="RightNestedPOS" select="key('POSID', $RightPartOfSpeech)/SubPossibilities"/>
		 <xsl:variable name="LeftMsFS" select="$LeftMsa/MsFeatures/@dst"/>
		 <xsl:variable name="RightMsFS" select="$RightMsa/MsFeatures/@dst"/>
		 <xsl:variable name="LeftExcepFS" select="$LeftMsa/ExceptionFeatures/@dst"/>
		 <xsl:variable name="RightExcepFS" select="$RightMsa/ExceptionFeatures/@dst"/>
rule {Stem via compound rule <xsl:value-of select="@Id"/>}
  Stem_1 = Stem_2 <xsl:if test="Linker/@dst!='0'">Linker </xsl:if>Stem_3
<xsl:choose>
			<xsl:when test="name()='MoEndoCompound'">
			   <!-- 3.1.5.3.3.1	Endocentric compounds -->
			   <xsl:choose>
				  <xsl:when test="@HeadLast='1'">
					 <xsl:text>                                | percolation
		&lt;Stem_1 morphoSyntax&gt; = &lt;Stem_3 morphoSyntax&gt;
		&lt;Stem_1 synCat&gt; = &lt;Stem_3 synCat&gt;
		&lt;Stem_1 requiresInflection&gt; = &lt;Stem_3 requiresInflection&gt;
		&lt;Stem_1 inflectionClass&gt; = &lt;Stem_3 inflectionClass&gt;
		&lt;Stem_1 exception&gt; = &lt;Stem_3 exception&gt;
			   | for stem names, use priority union to handle case of compound within a compound; last one wins
		&lt;Stem_1 stemName&gt;   &lt;= &lt;Stem_3 stemName&gt;
</xsl:text>
				  </xsl:when>
				  <xsl:otherwise>
					 <xsl:text>                                | percolation
		&lt;Stem_1 morphoSyntax&gt; = &lt;Stem_2 morphoSyntax&gt;
		&lt;Stem_1 synCat&gt; = &lt;Stem_2 synCat&gt;
		&lt;Stem_1 requiresInflection&gt; = &lt;Stem_2 requiresInflection&gt;
		&lt;Stem_1 inflectionClass&gt; = &lt;Stem_2 inflectionClass&gt;
		&lt;Stem_1 exception&gt; = &lt;Stem_2 exception&gt;
			   | for stem names, use priority union to handle case of compound within a compound; last one wins
		&lt;Stem_1 stemName&gt;   &lt;= &lt;Stem_2 stemName&gt;
</xsl:text>
				  </xsl:otherwise>
			   </xsl:choose>
			   <xsl:variable name="overridingMsa" select="key('StemMsaID',OverridingMsa/@dst)"/>
			   <xsl:variable name="overridingPOS" select="$overridingMsa/@PartOfSpeech"/>
			   <xsl:if test="$overridingPOS!=0">
				  <xsl:text>        &lt;Stem_1 synCat&gt; &lt;= </xsl:text>
				  <xsl:value-of select="$overridingPOS"/>
				  <xsl:text>                                | override category</xsl:text>
				<xsl:variable name="overridingInflectionClass" select="$overridingMsa/@InflectionClass"/>
				<xsl:if test="$overridingInflectionClass!=0">
				<xsl:text>&#x0a;        &lt;Stem_1 inflectionClass&gt; &lt;= </xsl:text>
				<xsl:value-of select="$overridingInflectionClass"/>
				<xsl:text>                                | override inflection class</xsl:text>
				</xsl:if>
			   </xsl:if>
			</xsl:when>
			<xsl:when test="name()='MoExoCompound'">
			   <xsl:if test="$ToPartOfSpeech">                                | percolation
		&lt;Stem_1 synCat&gt;       = <xsl:value-of select="$ToPartOfSpeech"/>
				  <!--        &lt;Stem_1 inflectonClass&gt;       = <xsl:value-of select="$ToInflectionClass"/> -->
				  <xsl:text>&#x20;
</xsl:text>
				  <xsl:variable name="sHasInflTemplate">
					 <xsl:call-template name="SuperPOSHasTemplate">
						<xsl:with-param name="pos" select="$ToPartOfSpeech"/>
					 </xsl:call-template>
				  </xsl:variable>
				  <xsl:choose>
					 <xsl:when test="$sHasInflTemplate='Y'">
		&lt;Stem_1 requiresInflection&gt; = +
		&lt;Stem_1 inflected&gt; = -
						</xsl:when>
					 <xsl:otherwise>
		&lt;Stem_1 requiresInflection&gt; = -
			</xsl:otherwise>
				  </xsl:choose>
			   </xsl:if>
			   <xsl:if test="$ToInflectionClass">
		&lt;Stem_1 inflectionClass&gt;       = <xsl:value-of select="$ToInflectionClass"/>
			   </xsl:if>
			   <xsl:for-each select="$ToMsa/ExceptionFeatures/FsFeatStruc/FsClosedValue | $ToMsa/ExceptionFeatures/FsFeatStruc/FsNegatedValue">
		&lt;Stem_1 exception <xsl:value-of select="@Feature"/>&gt;       = +
		  </xsl:for-each>
			</xsl:when>
		 </xsl:choose>
		 <!-- Common to all compound rules -->
		&lt;Stem_1 blocksInflection&gt; = - | This stem can now be inflected
						  | constraints
<xsl:for-each select="ToExceptionFeatures/FsFeatStruc/FsClosedValue | ToExceptionFeatures/FsFeatStruc/FsNegatedValue">
		&lt;Stem_1 exception <xsl:value-of select="@Feature"/>&gt;      &lt;= +
	  </xsl:for-each>
		 <xsl:variable name="leftFeatures" select="key('StemMsaID', LeftMsa/@dst)/ExceptionFeatures/FsFeatStruc"/>
		 <xsl:if test="$leftFeatures">
			<xsl:call-template name="OutputCompoundRuleFeatureMatch">
			   <xsl:with-param name="sStem">2</xsl:with-param>
			   <xsl:with-param name="features" select="$leftFeatures"/>
			</xsl:call-template>
		 </xsl:if>
		 <xsl:variable name="rightFeatures" select="key('StemMsaID', RightMsa/@dst)/ExceptionFeatures/FsFeatStruc"/>
		 <xsl:if test="$rightFeatures">
			<xsl:call-template name="OutputCompoundRuleFeatureMatch">
			   <xsl:with-param name="sStem">3</xsl:with-param>
			   <xsl:with-param name="features" select="$rightFeatures"/>
			</xsl:call-template>
		 </xsl:if>
		 <xsl:choose>
			<xsl:when test="count($LeftNestedPOS)=0">
		&lt;Stem_2 synCat&gt; = 				<xsl:value-of select="$LeftPartOfSpeech"/>
			</xsl:when>
			<xsl:otherwise>
				{
		&lt;Stem_2 synCat&gt; =  <xsl:value-of select="$LeftPartOfSpeech"/>
			   <xsl:call-template name="NestedPOSids">
				  <xsl:with-param name="pos" select="$LeftPartOfSpeech"/>
				  <xsl:with-param name="sType" select="'CompoundStem2'"/>
			   </xsl:call-template> }
								</xsl:otherwise>
		 </xsl:choose>
		 <xsl:choose>
			<xsl:when test="count($RightNestedPOS)=0">
		&lt;Stem_3 synCat&gt; = <xsl:value-of select="$RightPartOfSpeech"/>
			</xsl:when>
			<xsl:otherwise>
				{
		&lt;Stem_3 synCat&gt; =  <xsl:value-of select="$RightPartOfSpeech"/>
			   <xsl:call-template name="NestedPOSids">
				  <xsl:with-param name="pos" select="$RightPartOfSpeech"/>
				  <xsl:with-param name="sType" select="'CompoundStem3'"/>
			   </xsl:call-template> }
				</xsl:otherwise>
		 </xsl:choose>
		 <xsl:if test="LeftMsFS">
		&lt;Stem_2 morphoSyntax&gt; =        <xsl:value-of select="key('FSID',$LeftMsFS)/@PATRTxt"/>
		 </xsl:if>
		 <xsl:if test="RightMsFS">
		&lt;Stem_2 morphoSyntax&gt; =        <xsl:value-of select="key('FSID',$RightMsFS)/@PATRTxt"/>
		 </xsl:if>
		 <xsl:if test="LeftExcepFS">
		&lt;Stem_2 exception&gt; =        <xsl:value-of select="key('FSID',$LeftExcepFS)/@PATRTxt"/>
		 </xsl:if>
		 <xsl:if test="RightExcepFS">
		&lt;Stem_2 exception&gt; =        <xsl:value-of select="key('FSID',$RightExcepFS)/@PATRTxt"/>
		 </xsl:if>
	  </xsl:for-each>
	  <!-- 3.1.6	Partially Analyzed Word Portion -->
| ------------------------------------------------------------
|                PARTIALLY ANALYZED WORD PORTION
| ------------------------------------------------------------
<!-- 3.1.6.1	Partially Analyzed Affix Sequences -->
			  | an unmarked root
rule {A root unmarked for category is a partial analysis}
Partial = root
								| percolation
  &lt;Partial synCat&gt; = &lt;root rootCat&gt;
								| constraint
  &lt;root rootCat&gt; = unknown

			  | affixes on an unmarked root
rule {One or more prefixes and suffixes on an unmarked stem}
Partial_1 = Prefs Partial_2 Suffs
								| percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraint
  &lt;Partial_2 synCat&gt; = unknown

			  | prefixes on an unmarked root
rule {One or more prefixes on an unmarked stem}
Partial_1 = Prefs Partial_2
								| percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraint
  &lt;Partial_2 synCat&gt; = unknown

			  | suffixes on an unmarked root
rule {One or more suffixes on an unmarked stem}
Partial_1 = Partial_2 Suffs
								| percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraint
  &lt;Partial_2 synCat&gt; = unknown

rule {Derivational circumfix on an unmarked stem}
Partial_1 = derivCircumPfx Partial_2 derivCircumSfx
								| percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraint
  &lt;Partial_2 synCat&gt; = unknown
rule {Derivational circumfix on an unmarked stem where second is an infix}
Partial_1 = derivCircumPfx_1 derivCircumPfx_2 Partial_2
								 | percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								 | constraint
  &lt;Partial_2 synCat&gt; = unknown
								 | rightmost "prefix" must be an infix
  &lt;derivCircumPfx_2&gt; == [morphType : infix]

rule {Unclassifed circumfix on an unmarked stem}
Partial_1 = circumPfx Partial_2 circumSfx
								| percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraint
  &lt;Partial_2 synCat&gt; = unknown
  rule {Unclassifed circumfix on an unmarked stem where second is an infix}
  Partial_1 = circumPfx_1 circumPfx_2 Partial_2
								| percolation
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraint
  &lt;Partial_2 synCat&gt; = unknown
								| rightmost "prefix" must be an infix
  &lt;circumPfx_2&gt; == [morphType : infix]

rule {An unanalyzed prefix added to a sequence of prefixes; no compound rules}
  Prefs_1 = prefix (Prefs_2)
				| no percolation or constraints

rule {A derivational prefix added to a sequence of prefixes; the derivational prefix may be next to the stem}
  Prefs_1 = derivPfx (Prefs_2)
				| no percolation or constraints

rule {An unanalyzed suffix added to a sequence of suffixes; no compound rules}
  Suffs_1 = (Suffs_2) suffix
				| no percolation or constraints

rule {A derivational suffix added to a sequence of suffixes; the derivational suffix may be next to the stem}
  Suffs_1 = (Suffs_2) derivSfx
				| no percolation or constraints

			  | affixes on otherwise fully analyzed
			  | these never allow derivational affixes next to the stem
rule {One or more unanalyzed prefixes and suffixes on a fully analyzed stem}
  Partial = Prefixes Full Suffixes
								| percolation
  &lt;Partial inflected&gt; = &lt;Full inflected&gt;
  &lt;Partial synCat&gt; = &lt;Full synCat&gt;
								| constraints
  <!-- need to check category hierarchy for these unclassifieds, too -->
  {
  <xsl:call-template
		 name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">Prefixes</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Full</xsl:with-param>
		 <xsl:with-param name="sCat">synCat</xsl:with-param>
		 <xsl:with-param name="sSecondNode">Suffixes</xsl:with-param>
	  </xsl:call-template>
  }

rule {One or more unanalyzed prefixes on a fully analyzed stem}
  Partial = Prefixes Full
								| percolation
  &lt;Partial inflected&gt; = &lt;Full inflected&gt;
  &lt;Partial synCat&gt; = &lt;Full synCat&gt;
								| constraints
  <!-- need to check category hierarchy for these unclassifieds, too -->
  {
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">Prefixes</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Full</xsl:with-param>
		 <xsl:with-param name="sCat">synCat</xsl:with-param>
	  </xsl:call-template>
  }

rule {One or more unanalyzed suffixes on a fully analyzed stem}
  Partial =          Full Suffixes
								| percolation
  &lt;Partial inflected&gt; = &lt;Full inflected&gt;
  &lt;Partial synCat&gt; = &lt;Full synCat&gt;
								| constraints
  <!-- need to check category hierarchy for these unclassifieds, too -->
  {
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">Suffixes</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Full</xsl:with-param>
		 <xsl:with-param name="sCat">synCat</xsl:with-param>
	  </xsl:call-template>
  }

rule {Unanalyzed circumfix on a fully analyzed stem}
  Partial = circumPfx Full circumSfx
								| percolation
  &lt;Partial inflected&gt; = &lt;Full inflected&gt;
  &lt;Partial synCat&gt; = &lt;Full synCat&gt;
								| constraints
  <!-- need to check category hierarchy for these unclassifieds, too -->
  {
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">circumPfx</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Full</xsl:with-param>
		 <xsl:with-param name="sCat">synCat</xsl:with-param>
		 <xsl:with-param name="sSecondNode">circumSfx</xsl:with-param>
	  </xsl:call-template>
  }
	| (Note: we do not allow for a derivational circumfix to attach to a Full in order to produce a partial - that would be an error.)
rule {Unanalyzed circumfix on a fully analyzed stem where second is an infix}
 Partial = circumPfx_1 circumPfx_2 Full
								 | percolation
	&lt;Partial inflected&gt; = &lt;Full inflected&gt;
	&lt;Partial synCat&gt; = &lt;Full synCat&gt;
								 | constraints
								 | rightmost "prefix" must be an infix
	&lt;circumPfx_2&gt; == [morphType : infix]
	  <!-- need to check category hierarchy for these unclassifieds, too -->
	  {
	  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">circumPfx_1</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Full</xsl:with-param>
		 <xsl:with-param name="sCat">synCat</xsl:with-param>
		 <xsl:with-param name="sSecondNode">circumPfx_2</xsl:with-param>
	  </xsl:call-template>
	  }
	  | (Note: we do not allow for a derivational circumfix to attach to a Full in order to produce a partial - that would be an error.)

			  | affixes on partial with non-final inflection
rule {One or more unanalyzed prefixes and suffixes on partial}
  Partial_1 = Prefs Partial_2 Suffs
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]

rule {One or more unanalyzed prefixes on partial}
  Partial_1 = Prefs Partial_2
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]

rule {One or more unanalyzed suffixes on partial}
  Partial_1 =          Partial_2 Suffs
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]

rule {Unanalyzed circumfix on partial}
  Partial_1 = circumPfx Partial_2 circumSfx
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]
rule {Unanalyzed circumfix on partial, where second part is an infix}
  Partial_1 = circumPfx_1 circumPfx_2 Partial_2
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]
								| rightmost "prefix" must be an infix
  &lt;circumPfx_2&gt; == [morphType : infix]

rule {Derivational circumfix on partial}
  Partial_1 = derivCircumPfx Partial_2 derivCircumSfx
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]
rule {Derivational circumfix on partial, where second part is an infix}
  Partial_1 = derivCircumPfx_1 derivCircumPfx_2 Partial_2
								| percolation
  &lt;Partial_1 inflected&gt; = &lt;Partial_2 inflected&gt;
  &lt;Partial_1 synCat&gt; = &lt;Partial_2 synCat&gt;
								| constraints
  &lt;Partial_2&gt; == ~[synCat:unknown]
								| rightmost "prefix" must be an infix
   &lt;derivCircumPfx_2&gt; == [morphType : infix]

rule {An unanalyzed prefix added to a sequence of prefixes}
  Prefixes_1 = prefix (Prefixes_2)
								| percolation
  &lt;Prefixes_1 synCat&gt; = &lt;prefix fromCat&gt;  | keep the same category
								| constraints
  <!-- need to check category hierarchy for these unclassifieds, too -->
  {
  <xsl:call-template
		 name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">prefix</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Prefixes_2</xsl:with-param>
	  </xsl:call-template>
  }

rule {A derivational prefix added to a sequence of prefixes; the derivational cannot be next to the stem}
  Prefixes_1 = derivPfx Prefixes_2
								| percolation
  &lt;Prefixes_1 synCat&gt; = &lt;derivPfx toCat&gt;
								| constraints
  {
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivPfx</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Prefixes_2</xsl:with-param>
	  </xsl:call-template>
  }

rule {A derivational prefix added to a partial analysis}
Partial_1 = derivPfx Partial_2
								| percolation
&lt;Partial_1 synCat&gt; = &lt;derivPfx toCat&gt;
								| constraints
{
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivPfx</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Partial_2</xsl:with-param>
	  </xsl:call-template>
  }

rule {An unanalyzed suffix added to a sequence of suffixes}
  Suffixes_1 = (Suffixes_2) suffix
								| percolation
  &lt;Suffixes_1 synCat&gt; = &lt;suffix fromCat&gt;  | keep the same category
								| constraints
  <!-- need to check category hierarchy for these unclassifieds, too -->
  {
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">suffix</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Suffixes_2</xsl:with-param>
	  </xsl:call-template>
  }

rule {A derivational suffix added to a sequence of suffixes; the derivational cannot be next to the stem}
  Suffixes_1 = Suffixes_2 derivSfx
								| percolation
  &lt;Suffixes_1 synCat&gt; = &lt;derivSfx toCat&gt;
								| constraints
  {
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivSfx</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Suffixes_2</xsl:with-param>
	  </xsl:call-template>
  }

rule {A derivational suffix added to a partial analysis}
Partial_1 = Partial_2 derivSfx
								| percolation
&lt;Partial_1 synCat&gt; = &lt;derivSfx toCat&gt;
								| constraints
{
  <xsl:call-template name="ConstrainNestedCategories">
		 <xsl:with-param name="sOtherNode">derivSfx</xsl:with-param>
		 <xsl:with-param name="sStemOrFull">Partial_2</xsl:with-param>
	  </xsl:call-template>
  }

<!-- 3.1.6.2	Inflectional Template Applied to a Partial Word Portion -->
rule {Partially analyzed stem that's been inflected with empty template}
	Partial = PartialInflected
								| percolation
	&lt;Partial synCat&gt; = &lt;PartialInflected synCat&gt;
								| constraints
	&lt;Partial synCat&gt; = &lt;PartialInflected synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;PartialInflected morphoSyntax&gt;

	&lt;Partial inflected&gt; = +
	&lt;PartialInflected inflected&gt; = +

	<xsl:for-each select="$PartsOfSpeech">
		 <xsl:variable name="posID" select="@Id"/>
		 <xsl:for-each select="AffixTemplates/MoInflAffixTemplate">
			<xsl:if test="count(PrefixSlots | SuffixSlots)>0">
rule {Partially analyzed stem with inflectional template  <xsl:value-of select="@Id"/>}
		<xsl:variable name="sAllSlotsOptional">
			<xsl:for-each select="PrefixSlots | SuffixSlots">
				<xsl:if test="key('SlotsID',@dst)/@Optional='false'">N</xsl:if>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="sPartial1">
			<xsl:choose>
				<xsl:when test="contains($sAllSlotsOptional,'N')">Partial_1</xsl:when>
				<xsl:otherwise>PartialInflected</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="sPartial2">
			<xsl:choose>
				<xsl:when test="contains($sAllSlotsOptional,'N')">Partial_2</xsl:when>
				<xsl:otherwise>Partial</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
  <xsl:value-of select="$sPartial1"/> =  <xsl:call-template name="AffixTemplateSlotsPSR">
				  <xsl:with-param name="Slots" select="PrefixSlots"/>
				  <xsl:with-param name="sAllSlotsOptional" select="$sAllSlotsOptional"/>
				  <xsl:with-param name="bPrefix">Y</xsl:with-param>
				  <xsl:with-param name="sType">P</xsl:with-param>
  </xsl:call-template>
				<xsl:text>&#x20;</xsl:text>
				<xsl:value-of select="$sPartial2"/> <xsl:call-template name="AffixTemplateSlotsPSR">
				  <xsl:with-param name="Slots" select="SuffixSlots"/>
				  <xsl:with-param name="sAllSlotsOptional" select="$sAllSlotsOptional"/>
				  <xsl:with-param name="bPrefix">N</xsl:with-param>
				  <xsl:with-param name="sType">P</xsl:with-param>
			   </xsl:call-template>
			   <xsl:text>&#x20; :</xsl:text>
														 | percolation
  &lt;<xsl:value-of select="$sPartial1"/> synCat&gt;       = &lt;<xsl:value-of select="$sPartial2"/> synCat&gt;
														 | constraints
<xsl:variable name="NestedPOS" select="../../SubPossibilities"/>
			   <xsl:choose>
				  <xsl:when test="count($NestedPOS)>0">{
  &lt;<xsl:value-of select="$sPartial2"/> synCat&gt;       = <xsl:value-of select="../../@Id"/>
					 <xsl:call-template name="NestedPOSids">
						<xsl:with-param name="pos" select="../../@Id"/>
						<xsl:with-param name="sType" select="'Partial'"/>
					 </xsl:call-template>
}</xsl:when>
				  <xsl:otherwise>  &lt;<xsl:value-of select="$sPartial2"/> synCat&gt;       = <xsl:value-of select="../../@Id"/>
				  </xsl:otherwise>
			   </xsl:choose>
			   <xsl:if test="@Final='false'">
  &lt;<xsl:value-of select="$sPartial1"/> blocksInflection&gt; = + | prevent a non-final template from immediately being inflected without any intervening derivation or compounding
</xsl:if>
			   <xsl:text>&#x20;
</xsl:text>
			   <xsl:call-template name="AffixTemplateSlotsConstraints">
				  <xsl:with-param name="Slots" select="PrefixSlots"/>
				  <xsl:with-param name="bPrefix">Y</xsl:with-param>
				  <xsl:with-param name="bFull">N</xsl:with-param>
			   </xsl:call-template>
			   <xsl:call-template name="AffixTemplateSlotsConstraints">
				  <xsl:with-param name="Slots" select="SuffixSlots"/>
				  <xsl:with-param name="bPrefix">N</xsl:with-param>
				  <xsl:with-param name="bFull">N</xsl:with-param>
			   </xsl:call-template>
			   <!-- need to avoid nesting inflected items; do this by forcing Patial_2 to be minus and Partial_1 to be plus inflected -->
														 | constraint
  &lt;<xsl:value-of select="$sPartial1"/> inflected&gt; = +
  &lt;<xsl:value-of select="$sPartial2"/> inflected&gt; = -
		</xsl:if>
		 </xsl:for-each>
	  </xsl:for-each>
	  <!-- 3.1.6.3	Compounded Roots without Compound Rules -->
	  <xsl:if test="not($compRules/MoEndoCompound | $compRules/MoExoCompound)"
		 >
		| if there are no compound rules, use the remaining rules:
			| these allow derivational affixes next to the stem
rule {Totally unanalyzed form with one or more prefixes and suffixes; no compound rules}
  Partial = Prefs Roots Suffs
				| percolation
	&lt;Partial synCat&gt; = &lt;Roots synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;Roots morphoSyntax&gt;
	&lt;Partial inflectionClass&gt; = &lt;Roots inflectionClass&gt;

rule {Totally unanalyzed form with one or more prefixes; no compound rules}
  Partial = Prefs Roots
				| percolation
	&lt;Partial synCat&gt; = &lt;Roots synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;Roots morphoSyntax&gt;
	&lt;Partial inflectionClass&gt; = &lt;Roots inflectionClass&gt;

rule {Totally unanalyzed form with one or more suffixes; no compound rules}
  Partial =       Roots Suffs
				| percolation
	&lt;Partial synCat&gt; = &lt;Roots synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;Roots morphoSyntax&gt;
	&lt;Partial inflectionClass&gt; = &lt;Roots inflectionClass&gt;

<!-- not needed
rule {Unanalyzed compound roots with unclassified circumfix; no compound rules}
  Partial = circumPfx Roots circumSfx
				| percolation
	&lt;Partial synCat&gt; = &lt;Roots synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;Roots morphoSyntax&gt;
	&lt;Partial inflectionClass&gt; = &lt;Roots inflectionClass&gt;

rule {Unanalyzed compound roots with derivational circumfix; no compound rules}
  Partial = derivCircumPfx Roots derivCircumSfx
				| percolation
	&lt;Partial synCat&gt; = &lt;Roots synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;Roots morphoSyntax&gt;
	&lt;Partial inflectionClass&gt; = &lt;Roots inflectionClass&gt;
-->
rule {Totally unanalyzed sequence of roots; no compound rules}
  Partial =       Roots
				| percolation
	&lt;Partial synCat&gt; = &lt;Roots synCat&gt;
	&lt;Partial morphoSyntax&gt; = &lt;Roots morphoSyntax&gt;
	&lt;Partial inflectionClass&gt; = &lt;Roots inflectionClass&gt;

rule {A root added to a sequence of roots; no compound rules}
  Roots_1 = Roots_2 root
				| percolation
	&lt;Roots_1 synCat&gt;      = &lt;Roots_2 synCat&gt;      | arbitrarily use 1st
	&lt;Roots_1 morphoSyntax&gt; = &lt;Roots_2 morphoSyntax&gt; | arbitrarily use 1st
	&lt;Roots_1 inflectionClass&gt; = &lt;Roots_2 inflectionClass&gt; | arbitrarily use 1st

rule {A sequence of two roots; no compound rules}
  Roots = root_1 root_2
				| percolation
	&lt;Roots synCat&gt;      = &lt;root_1 rootCat&gt;      | arbitrarily use 1st
	&lt;Roots morphoSyntax&gt; = &lt;root_1 morphoSyntax&gt; | arbitrarily use 1st
	&lt;Roots inflectionClass&gt; = &lt;root_1 inflectionClass&gt; | arbitrarily use 1st

rule {A sequence of two roots with one or more interfixes; no compound rules}
  Roots = root_1 Interfixes root_2
				| percolation
	&lt;Roots synCat&gt;      = &lt;root_1 synCat&gt;      | arbitrarily use 1st
	&lt;Roots morphoSyntax&gt; = &lt;root_1 morphoSyntax&gt; | arbitrarily use 1st
	&lt;Roots inflectionClass&gt; = &lt;root_1 inflectionClass&gt; | arbitrarily use 1st

rule {A sequence of two or more interfixes; no compound rules}
  Interfixes_1 = Interfixes_2 interfix

rule {An interfix; no compound rules}
  Interfixes = interfix
  </xsl:if>
	  <!-- 3.2	Creating the templates -->
  <xsl:text>
| ------------------------------------------------------------
|                TEMPLATES
| ------------------------------------------------------------
Let W be []
Let W/W be []
Let Prt be []
Let Linker be []
Let Proclitic be []
Let Enclitic be []
Let Bound be []
</xsl:text>
	<xsl:if test="$bSuffixingOnly='Y'">
		<xsl:text>
Let pos0 be []&#xa;</xsl:text>
		<xsl:variable name="topLevelPOSes">
			<xsl:for-each select="$PartsOfSpeech">
				<xsl:variable name="posid" select="@Id"/>
				<xsl:if test="not($PartsOfSpeech/SubPossibilities[@dst=$posid])">
					<xsl:text>&#x20;</xsl:text>
					<xsl:value-of select="$posid"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:variable>
		<xsl:call-template name="OutputLetsForTopLevelCategories">
			<xsl:with-param name="sList" select="normalize-space($topLevelPOSes)"/>
		</xsl:call-template>
		<xsl:call-template name="OutputLetsForDerivMsas">
			<xsl:with-param name="derivMsa" select="//MoDerivAffMsa[1]"/>
			<xsl:with-param name="sExistingMappings" select="''"/>
		</xsl:call-template>
	</xsl:if>
<!-- 3.2.1	Template types -->
	  <xsl:variable name="ExceptionFeatures" select="$root/ProdRestrict/CmPossibility"/>
	  <xsl:if test="$ExceptionFeatures">
		 <xsl:for-each select="$ExceptionFeatures">
			<xsl:variable name="thisEF" select="@Id"/>
Let <xsl:value-of select="$sExceptionFeature"/><xsl:value-of select="@Id"/>Plus  be [exception:[<xsl:value-of select="@Id"/>:+]]
Let <xsl:value-of select="$sExceptionFeature"/><xsl:value-of select="@Id"/>Minus be [exception:[<xsl:value-of select="@Id"/>:-]]
Let <xsl:value-of select="$sFromExceptionFeature"/><xsl:value-of select="@Id"/>Plus  be [fromException:[<xsl:value-of select="@Id"/>:+]]
Let <xsl:value-of select="$sFromExceptionFeature"/><xsl:value-of select="@Id"/>Minus be [fromException:[<xsl:value-of select="@Id"/>:-]]
<!-- for the To Plus case, need to make sure that it defaults to minus for other exceptoin features.
	  Otherwise, do not correctly override any extant exception features of the stem to which the affix attaches. -->
Let <xsl:value-of select="$sToExceptionFeature"/><xsl:value-of select="@Id"/>Plus  be [toException:[<xsl:value-of select="@Id"/>:+ <xsl:call-template name="GetOtherExceptionFeaturesAsDefault">
			   <xsl:with-param name="ExceptionFeatures" select="$ExceptionFeatures"/>
			   <xsl:with-param name="thisEF" select="$thisEF"/>
			</xsl:call-template>]]
Let <xsl:value-of select="$sToExceptionFeature"/><xsl:value-of select="@Id"/>Minus be [toException:[<xsl:value-of select="@Id"/>:-]]</xsl:for-each>
Let <xsl:value-of select="$sDefaultExceptionFeatures"/> be [exception:[<xsl:for-each select="$ExceptionFeatures">
			<xsl:value-of select="@Id"/>:!- </xsl:for-each>]]
</xsl:if>
Let <xsl:value-of select="$sRootPOS"/>0 be [rootCat:unknown] <!-- An stem unspecified for POS  -->
Let <xsl:value-of select="$sCliticPOS"/>0 be [rootCat:unknown] <!-- An stem unspecified for POS  -->
	  <xsl:for-each select="$PartsOfSpeech">
		 <xsl:text>
Let </xsl:text>
		 <xsl:value-of select="$sRootPOS"/>
		 <xsl:value-of select="./@Id"/>
		 <xsl:text> be [rootCat:</xsl:text>
		 <xsl:value-of select="./@Id"/>
		 <xsl:call-template name="GetPOSFeatures">
			<xsl:with-param name="pos" select="@Id"/>
		 </xsl:call-template>
		 <xsl:text>]</xsl:text>
		 <xsl:if test="$ExceptionFeatures">
			<xsl:text> [DefaultExcpFeatures]</xsl:text>
		 </xsl:if>
Let <xsl:value-of select="$sMSEnvPOS"/><xsl:value-of select="./@Id"/>
		 <xsl:call-template name="TemplateWithNestedPOS">
			<xsl:with-param name="pos" select="@Id"/>
			<xsl:with-param name="sFeature">
			   <xsl:text>envCat</xsl:text>
			</xsl:with-param>
		 </xsl:call-template>
Let <xsl:value-of select="$sFromPOS"/><xsl:value-of select="./@Id"/> be [fromCat:<xsl:value-of select="./@Id"/>]
<!-- habby play @#@
Let FromPOS<xsl:value-of select="./@Id"/>
			<xsl:call-template name="TemplateWithNestedPOS">
				<xsl:with-param name="pos" select="@Id"/>
				<xsl:with-param name="sFeature">
					<xsl:text>fromCat</xsl:text>
				</xsl:with-param>
			</xsl:call-template> -->
Let <xsl:value-of select="$sToPOS"/><xsl:value-of select="./@Id"/> be [toCat:<xsl:value-of select="./@Id"/>
		 <xsl:call-template name="GetPOSFeatures">
			<xsl:with-param name="pos" select="@Id"/>
		 </xsl:call-template>]<!-- no need to have To POS include subcats because the derivational rule handles it
			<xsl:call-template name="TemplateWithNestedPOS">
				<xsl:with-param name="pos" select="@Id"/>
				<xsl:with-param name="sFeature">
					<xsl:text>toCat</xsl:text>
				</xsl:with-param>
			</xsl:call-template> -->
Let <xsl:value-of select="$sCliticPOS"/><xsl:value-of select="./@Id"/>
		 <xsl:call-template name="TemplateWithNestedPOS">
			<xsl:with-param name="pos" select="@Id"/>
			<xsl:with-param name="sFeature">
			   <xsl:text>rootCat</xsl:text>
			</xsl:with-param>
		 </xsl:call-template>
Let <xsl:value-of select="$sCliticFromPOS"/><xsl:value-of select="./@Id"/>
		 <xsl:call-template name="TemplateWithNestedPOS">
			<xsl:with-param name="pos" select="@Id"/>
			<xsl:with-param name="sFeature">
			   <xsl:text>fromCat</xsl:text>
			</xsl:with-param>
		 </xsl:call-template>
		 <xsl:for-each select="descendant::MoStemName">
Let <xsl:value-of select="$sStemName"/><xsl:value-of select="@Id"/> be [stemName:<xsl:value-of select="@Id"/>]
Let <xsl:value-of select="$sStemName"/><xsl:text>Affix</xsl:text><xsl:value-of select="@Id"/> be []</xsl:for-each>
		  </xsl:for-each>
	  <xsl:call-template name="OutputLetsForStemNamesUsedInLexicalEntries">
		 <xsl:with-param name="sList" select="$sUniqueStemNamesUsedInLexicalEntries"/>
	  </xsl:call-template>
	   <xsl:for-each select="$allos/MoAffixAllomorph/MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]">
Let <xsl:value-of select="$sMSEnvFS"/><xsl:value-of select="@Id"/>
		 <xsl:text> be [ envMorphoSyntax:[name</xsl:text>
		 <xsl:value-of select="@Id"/>
		   <xsl:text>:</xsl:text>
		   <xsl:value-of select="@Id"/>
		   <xsl:text> morphoSyntax:[</xsl:text>
		 <xsl:call-template name="OutputFsFeatStruc"/>
		 <xsl:text>] ]]</xsl:text>
	  </xsl:for-each>
	  <xsl:for-each select="$entries/LexEntry">
		 <xsl:variable name="allomorphs" select="AlternateForms | LexemeForm"/>
		  <xsl:variable name="allosConditionedByFeatures" select="$allos/MoAffixAllomorph[@Id=$allomorphs/@dst and MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]]"/>
		 <xsl:if test="count($allosConditionedByFeatures) &gt; 0">
			<xsl:text>
Let </xsl:text>
			<xsl:value-of select="$sMSEnvFS"/>
			<xsl:variable name="NotValues">
			   <xsl:for-each select="$allosConditionedByFeatures">
				  <xsl:text>Not</xsl:text>
				   <xsl:value-of select="MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]/@Id"/>
			   </xsl:for-each>
			</xsl:variable>
			<xsl:value-of select="$NotValues"/>
			<xsl:text> be [ envMorphoSyntax : [name</xsl:text>
			<xsl:value-of select="$NotValues"/>
			 <xsl:text>:</xsl:text>
			 <xsl:value-of select="$NotValues"/>
			 <xsl:text>]]</xsl:text>
		 </xsl:if>
	  </xsl:for-each>
	  <!-- @@@ need data for following 2002.01.04 -->
	   <!--xsl:for-each select="//MsFeatures">
Let <xsl:value-of select="$sMSFS"/><xsl:value-of select="@dst"/> be <xsl:value-of select="key('FSID',@dst)/@PATRTxt"/>
	  </xsl:for-each -->
	  <xsl:for-each select="$analyses/MoStemMsa/InflectionFeatures/FsFeatStruc">
		 <xsl:call-template name="OutputFS">
			<xsl:with-param name="sTemplateName">MSFS</xsl:with-param>
		 </xsl:call-template>
	  </xsl:for-each>
	  <xsl:for-each select="$lexEntryInflTypes/InflectionFeatures/FsFeatStruc">
		 <xsl:call-template name="OutputFS">
			<xsl:with-param name="sTemplateName">MSFS</xsl:with-param>
		 </xsl:call-template>
	  </xsl:for-each>
	  <xsl:for-each select="$analyses/MoDerivAffMsa/FromMsFeatures/FsFeatStruc">
		 <xsl:call-template name="OutputFS">
			<xsl:with-param name="sTemplateName" select="$sFromMSFS"/>
			<xsl:with-param name="sMorphoSyntaxName">fromMorphoSyntax</xsl:with-param>
		 </xsl:call-template>
	  </xsl:for-each>
	  <xsl:for-each select="$analyses/MoDerivAffMsa/ToMsFeatures/FsFeatStruc">
		 <xsl:call-template name="OutputFS">
			<xsl:with-param name="sTemplateName" select="$sToMSFS"/>
			<xsl:with-param name="sMorphoSyntaxName">toMorphoSyntax</xsl:with-param>
		 </xsl:call-template>
	  </xsl:for-each>
	  <xsl:for-each select="$analyses/MoInflAffMsa/InflectionFeatures/FsFeatStruc">
		 <xsl:call-template name="OutputFS">
			<xsl:with-param name="sTemplateName">InflectionFS</xsl:with-param>
		 </xsl:call-template>
	  </xsl:for-each>
	  <xsl:call-template name="OutputInflectionClassTemplates"/>
	  <!-- combination of fromPOSes for proclitics and enclitics
	The methodology here is to create a string (sAllFromPOSNames) containing the Let statements that need to be created.
	Some of these may be duplicates since more than one clitic could attach to the same POS.
	Each such Let statement originally uses ampersands instead of spaces within it.  Each such Let statement is then
	separated by a space.
	We use the OutputUniqueStrings routine to find the unique Let statements, convert their ampersands to spaces, and
	then output the Let statement in its PC-PATR form.
	-->
	  <xsl:variable name="sAllFromPOSNames">
		 <xsl:for-each select="$analyses/MoStemMsa/FromPartsOfSpeech[count(FromPOS)&gt;1]">
			<xsl:text>
Let&amp;</xsl:text>
			<xsl:for-each select="FromPOS">
			   <xsl:value-of select="$sCliticFromPOS"/>
			   <xsl:value-of select="@dst"/>
			</xsl:for-each>
			<xsl:text>&amp;be&amp;{</xsl:text>
			<xsl:for-each select="FromPOS">
			   <xsl:text>[</xsl:text>
			   <xsl:value-of select="$sCliticFromPOS"/>
			   <xsl:value-of select="@dst"/>
			   <xsl:text>]</xsl:text>
			</xsl:for-each>
			<xsl:text>}</xsl:text>
		 </xsl:for-each>
	  </xsl:variable>
	  <xsl:text>&#x20;
</xsl:text>
	  <xsl:call-template name="OutputUniqueStrings">
		 <xsl:with-param name="sList" select="$sAllFromPOSNames"/>
		 <xsl:with-param name="bDoNewLine" select="'Y'"/>
	  </xsl:call-template>
	  <xsl:for-each select="$lexEntryInflTypes">
		 <xsl:text>
Let </xsl:text>
		 <xsl:value-of select="$sIrregularlyInflectedForm"/><xsl:value-of select="@Id"/>
		 <xsl:text> be []</xsl:text>
	  </xsl:for-each>
	  <!-- handling interfixes -->
	  <xsl:text>
Let Infix be [morphType:infix]
Let prefixinginterfix be {[cat:prefix]
						  [cat:interfix]}
Let suffixinginterfix be {[cat:suffix]
						  [cat:interfix]}
</xsl:text>
	  <!-- 3.2.1.4	Inflectional Affixes belonging to more than one slot -->
	  <!--
	The methodology here is to create a string (sAllNames) containing the Let statements that need to be created.
	Some of these may be duplicates since more than one set of affixes could occur in more than one slot.
	Each such Let statement originally uses ampersands instead of spaces within it.  Each such Let statement is then
	separated by a space.
	We use the OutputUniqueStrings routine to find the unique Let statements, convert their ampersands to spaces, and
	then output the Let statement in its PC-PATR form.
	-->
	  <!-- After model change removing the Affixes attr on MoInflAffixSlot, this is not needed
		<xsl:variable name="sAllNames">
			<xsl:for-each select="//MoInflAffMsa">
				<xsl:variable name="ThisInflMsaId">
					<xsl:value-of select="@Id"/>
				</xsl:variable>
				<- variable Slots contains those MoInflAffixSlot elements which have the affix in ThisInflMsaId ->
				<xsl:variable name="Slots" select="//MoInflAffixSlot[Affixes/@dst=$ThisInflMsaId]"/>
				<xsl:if test="count($Slots)&gt;1">Let&amp;<xsl:for-each select="$Slots">
						<xsl:text>slot</xsl:text>
						<xsl:value-of select="@Id"/>
					</xsl:for-each>&amp;be&amp;{<xsl:for-each select="$Slots">[cat:<xsl:value-of select="@Id"/>]</xsl:for-each>} </xsl:if>
			</xsl:for-each>
		</xsl:variable>
		<xsl:text>&#x20;
</xsl:text>
		<xsl:call-template name="OutputUniqueStrings">
			<xsl:with-param name="sList" select="$sAllNames"/>
		</xsl:call-template>
		-->
   </xsl:template>
   <!--
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	  OutputInflectionClassTemplates
	  Routine to output inflection class templates
	  Parameters: none
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   -->
   <xsl:template name="OutputInflectionClassTemplates">
	  <!-- singleton inflection classes (from individual msas) -->
	  <xsl:for-each select="$PartsOfSpeech/InflectionClasses//MoInflClass">
		 <xsl:text>
Let </xsl:text>
		 <xsl:value-of select="$sInflClass"/>
		 <xsl:value-of select="@Id"/>
		 <xsl:text> be [inflectionClass:</xsl:text>
		 <xsl:value-of select="@Id"/>
		 <xsl:text>]
Let </xsl:text>
		 <xsl:value-of select="$sFromInflClass"/>
		 <xsl:value-of select="@Id"/>
		 <xsl:text> be [fromInflectionClass:</xsl:text>
		 <xsl:value-of select="@Id"/>
		 <xsl:text>]
Let </xsl:text>
		 <xsl:value-of select="$sToInflClass"/>
		 <xsl:value-of select="@Id"/>
		 <xsl:text> be [toInflectionClass:</xsl:text>
		 <xsl:value-of select="@Id"/>
		 <xsl:text>]
</xsl:text>
		 <xsl:text>Let </xsl:text>
		  <xsl:value-of select="$sInflClassAffix"/>
		 <xsl:value-of select="@Id"/>
		 <xsl:choose>
			<xsl:when test="Subclasses/MoInflClass">
			   <xsl:text> be {
		 [inflectionClass:</xsl:text>
			</xsl:when>
			<xsl:otherwise>
			   <xsl:text> be [inflectionClass:</xsl:text>
			</xsl:otherwise>
		 </xsl:choose>
		 <xsl:value-of select="@Id"/>
		 <xsl:text>]
		 </xsl:text>
		 <xsl:call-template name="OutputInflectionSubclassTemplates"/>
		 <xsl:if test="Subclasses/MoInflClass">
			<xsl:text>}
			</xsl:text>
		 </xsl:if>
	  </xsl:for-each>
	  <!-- combination inflection classes (from MoAffixAllomorph)
		 The methodology here is to create a string (sAllNames) containing the Let statements that need to be created.
		 Some of these may be duplicates since more than one set of affixes could occur in more than one slot.
		 Each such Let statement originally uses ampersands instead of spaces within it.  Each such Let statement is then
		 separated by a space.
		 We use the OutputUniqueStrings routine to find the unique Let statements, convert their ampersands to spaces, and
		 then output the Let statement in its PC-PATR form.
	  -->
	  <xsl:variable name="sAllNames">
		 <xsl:for-each select="$allos/MoAffixAllomorph[count(InflectionClasses)&gt;1]">
			<xsl:text>
Let&amp;</xsl:text>
			<xsl:for-each select="InflectionClasses">
				<xsl:value-of select="$sInflClassAffix"/>
			   <xsl:value-of select="@dst"/>
			</xsl:for-each>
			<xsl:text>&amp;be&amp;{</xsl:text>
			<xsl:for-each select="InflectionClasses">
			   <xsl:text>[inflectionClass:</xsl:text>
			   <xsl:value-of select="@dst"/>
			   <xsl:text>]</xsl:text>
			   <xsl:for-each select="key('InflClassID',@dst)[Subclasses/MoInflClass]">
				  <xsl:call-template name="OutputInflectionSubclassTemplates"/>
			   </xsl:for-each>
			</xsl:for-each>
			<xsl:text>}</xsl:text>
		 </xsl:for-each>
	  </xsl:variable>
	  <xsl:text>&#x20;
</xsl:text>
	  <xsl:call-template name="OutputUniqueStrings">
		 <xsl:with-param name="sList" select="$sAllNames"/>
		 <xsl:with-param name="bDoNewLine" select="'Y'"/>
	  </xsl:call-template>
   </xsl:template>
   <!--
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	  OutputInflectionSubclassTemplates
	  Routine to recursively output inflection class templates for subclasses
	  Parameters: none
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   -->
   <xsl:template name="OutputInflectionSubclassTemplates">
	  <xsl:for-each select="Subclasses/MoInflClass">
		 <xsl:text>[inflectionClass:</xsl:text>
		 <xsl:value-of select="@Id"/>
		  <!-- It is crucial tha the following does *not* have any whitespace in it -->
		 <xsl:text>]</xsl:text>
		 <xsl:call-template name="OutputInflectionSubclassTemplates"/>
	  </xsl:for-each>
   </xsl:template>
   <!--
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	  AffixAlloWithFeaturesConstraints
	  if needed, build stem name contraints
	  Parameters: posID = ID of current PartOfSpeech
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   -->
   <xsl:template name="AffixAlloWithFeaturesConstraints">
	  <xsl:param name="sNonTerm"/>
	  <xsl:if test="$affixAllosWithFeatures">
		&lt;<xsl:value-of select="$sNonTerm"/> envMorphoSyntaxInfo fullMorphoSyntax&gt; = &lt;<xsl:value-of select="$sNonTerm"/> morphoSyntax>
			| environment morpho-syntax logical constraint
		&lt;<xsl:value-of select="$sNonTerm"/> envMorphoSyntaxInfo&gt; == (
		 <xsl:value-of select="$sAffixAlloWithFeaturesLogicalConstraint"/>
		 <xsl:text>)</xsl:text>
	  </xsl:if>
   </xsl:template>
   <!--
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	  AffixAlloWithFeaturesConstraintsAffixNode
	  if needed, build stem name contraints
	  Parameters: posID = ID of current PartOfSpeech
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   -->
   <xsl:template name="AffixAlloWithFeaturesConstraintsAffixNode">
	  <xsl:param name="sNonTerm"/>
	  <xsl:param name="sAffixNode"/>
	  <xsl:if test="$affixAllosWithFeatures">
		  &lt;<xsl:value-of select="$sNonTerm"/> envMorphoSyntaxInfo&gt; = &lt;<xsl:value-of select="$sAffixNode"/> envMorphoSyntax&gt;
	  </xsl:if>
   </xsl:template>
   <!--
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	  AffixAlloWithFeaturesLogicalConstraint
	  if needed, build logical constraint based on stem names
	  Parameters: posID = ID of current PartOfSpeech
	  bContinues = flag for whether are continuing or not
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   -->
   <xsl:template name="AffixAlloWithFeaturesLogicalConstraint">
	  <xsl:variable name="affixEnvFeatures" select="$affixAllosWithFeatures"/>
	  <!-- first do all affix environment features -->
	  <xsl:for-each select="$affixEnvFeatures">
		 <xsl:if test="position()!=1">
			<!-- nested items need to be enclosed in parens -->
			<xsl:text>
	 &amp; ( </xsl:text>
		 </xsl:if>
		 <xsl:text>([name</xsl:text>
		 <xsl:value-of select="@Id"/>
		  <xsl:text>:</xsl:text>
		  <xsl:value-of select="@Id"/>
		  <xsl:text>] -> </xsl:text>
		 <xsl:text>[fullMorphoSyntax:[</xsl:text>
		 <xsl:call-template name="OutputFsFeatStruc"/>
		 <xsl:text>]] </xsl:text>
		 <xsl:text>)</xsl:text>
	  </xsl:for-each>
	  <!-- now do elsewhere cases  so we can control nested parens -->
	  <xsl:for-each select="$entries/LexEntry">
		 <xsl:variable name="allomorphs" select="AlternateForms | LexemeForm"/>
		  <xsl:variable name="allosConditionedByFeatures" select="$allos/MoAffixAllomorph[@Id=$allomorphs/@dst and MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]]"/>
		 <xsl:if test="count($allosConditionedByFeatures) &gt; 0">
			<xsl:variable name="sNotValue">
			   <xsl:for-each select="$allosConditionedByFeatures">
				  <xsl:text>Not</xsl:text>
				   <xsl:value-of select="MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]/@Id"/>
			   </xsl:for-each>
			</xsl:variable>
			<xsl:text>
	 &amp; ( ([name</xsl:text>
			 <xsl:value-of select="$sNotValue"/>
			 <xsl:text>:</xsl:text>
			 <xsl:value-of select="$sNotValue"/>
			 <xsl:text>] -&gt; ( </xsl:text>
			<xsl:for-each select="$allosConditionedByFeatures">
			   <xsl:if test="position()!=1">
				  <xsl:text>
		  &amp; (</xsl:text>
			   </xsl:if>
			   <xsl:text>(~[fullMorphoSyntax:[</xsl:text>
				<xsl:for-each select="MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]">
				  <xsl:call-template name="OutputFsFeatStruc"/>
			   </xsl:for-each>
			   <xsl:text>]] </xsl:text>
			   <xsl:text>)</xsl:text>
			</xsl:for-each>
			<xsl:text> ))</xsl:text>
			<xsl:for-each select="$allosConditionedByFeatures">
			   <xsl:if test="position()!=1">
				  <xsl:text> ) </xsl:text>
			   </xsl:if>
			</xsl:for-each>
		 </xsl:if>
	  </xsl:for-each>
	  <!-- close all nested elsewhere cases  -->
	  <xsl:for-each select="$entries/LexEntry">
		 <xsl:variable name="allomorphs" select="AlternateForms | LexemeForm"/>
		  <xsl:variable name="allosConditionedByFeatures" select="$allos/MoAffixAllomorph[@Id=$allomorphs/@dst and MsEnvFeatures/FsFeatStruc[descendant::FsClosedValue]]"/>
		 <xsl:if test="count($allosConditionedByFeatures) &gt; 0">
				  <xsl:text> ) </xsl:text>
		 </xsl:if>
	  </xsl:for-each>
	  <!-- close all nested affix environment features  -->
	  <xsl:for-each select="$affixEnvFeatures">
		 <xsl:if test="position()!=1">
			<xsl:text> ) </xsl:text>
		 </xsl:if>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
AffixTemplateSlots
	Routine to output a list of affix template slot id names
		Parameters: sList = list of strings to look at, in determining which are unique
					   bConstraints = if true, output the slot name in the PC-PATR constraints;
											   if false, output the slot name in the phrase structure rule
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="AffixTemplateSlots">
	  <xsl:param name="sList"/>
	  <xsl:param name="bConstraints"/>
	  <xsl:variable name="sNewList" select="concat(normalize-space($sList),' ')"/>
	  <xsl:variable name="sFirst" select="substring-before($sNewList,' ')"/>
	  <xsl:variable name="sRest" select="substring-after($sNewList,' ')"/>
	  <xsl:variable name="sIndex" select="string-length($sRest)"/>
	  <!-- Need to distinguish between any identical terminal symbols in PATR rule, so using this as a unique number (as long as the same item does not appear on both sides of the stem....  -->
	   <xsl:for-each select="key('SlotsID', $sFirst)">
		 <xsl:if test="$bConstraints='N'">
			<xsl:text>&#x20;</xsl:text>
			<xsl:if test="@optional='true'">(</xsl:if>
			<xsl:value-of select="@Id"/>_<xsl:value-of select="$sIndex"/>
			<xsl:if test="@optional='true'">)</xsl:if>
		 </xsl:if>
		 <xsl:if test="$bConstraints!='N'">
  &lt;Stem morphoSyntax&gt;    = &lt;<xsl:value-of select="@Id"/>_<xsl:value-of select="$sIndex"/> morphoSyntax&gt;
  &lt;Stem synCat&gt;          = &lt;<xsl:value-of select="@Id"/>_<xsl:value-of select="$sIndex"/> envCat&gt;   | allomorph
  &lt;Stem inflectionClass&gt; = &lt;<xsl:value-of select="@Id"/>_<xsl:value-of select="$sIndex"/> inflectionClass&gt;</xsl:if>
	  </xsl:for-each>
	  <xsl:if test="$sRest">
		 <xsl:call-template name="AffixTemplateSlots">
			<xsl:with-param name="sList" select="$sRest"/>
			<xsl:with-param name="bConstraints" select="$bConstraints"/>
		 </xsl:call-template>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
AffixTemplateSlotsConstraints
	Routine to output a list of affix template slot id names as unification constraints
		Parameters: Slots    	= Node-set of slots
							bPrefix 	= Flag for if the slots are prefix slots
							bFull	= Flag for whether to do the full or partial version
							bStem	= Flag for whether to do the Stem or Stem_2 version
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="AffixTemplateSlotsConstraints">
	  <xsl:param name="Slots"/>
	  <xsl:param name="bPrefix">Y</xsl:param>
	  <xsl:param name="bFull">Y</xsl:param>
	  <xsl:param name="bStem">Y</xsl:param>
	  <xsl:param name="sNonTerm" select="'Full'"/>
	  <xsl:for-each select="$Slots">
<!--         <xsl:sort select="@ord"/> now it is just usual position-->
		 <xsl:variable name="sItem">
			<xsl:value-of select="@dst"/>
			<!-- Need to distinguish between any identical terminal symbols in PATR rule,
		  so are appending an underscore, and the position() value to create a unique value.
  -->
			<xsl:text>_</xsl:text>
			<xsl:value-of select="position() - 1"/>
		 </xsl:variable>
		 <xsl:if test="$bFull='Y'">
			<xsl:variable name="sStem">
			   <xsl:text>Stem</xsl:text>
			   <xsl:if test="$bStem!='Y'">_2</xsl:if>
			</xsl:variable>
  &lt;<xsl:value-of select="$sStem"/> morphoSyntax&gt;    = &lt;<xsl:value-of select="$sItem"/> morphoSyntax&gt;
  &lt;<xsl:value-of select="$sStem"/> synCat&gt;          = &lt;<xsl:value-of select="$sItem"/> envCat&gt;   | allomorph
  &lt;<xsl:value-of select="$sStem"/> exception&gt;       = &lt;<xsl:value-of select="$sItem"/> fromException&gt;
  &lt;<xsl:value-of select="$sStem"/> inflectionClass&gt; = &lt;<xsl:value-of select="$sItem"/> inflectionClass&gt;
  &lt;<xsl:value-of select="$sNonTerm"/> stemNameInfo morphoSyntax&gt; = &lt;<xsl:value-of select="$sItem"/> morphoSyntax&gt;</xsl:if>
		 <xsl:if test="$bFull='Y'">
			<xsl:call-template name="AffixAlloWithFeaturesConstraintsAffixNode">
			   <xsl:with-param name="sAffixNode" select="$sItem"/>
			   <xsl:with-param name="sNonTerm" select="$sNonTerm"/>
			</xsl:call-template>
		 </xsl:if>
		 <xsl:if test="$bFull='N'">
  &lt;Partial_1 morphoSyntax&gt;    = &lt;<xsl:value-of select="$sItem"/> morphoSyntax&gt;</xsl:if>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
AffixTemplateSlotsPSR
	Routine to output a list of affix template slot id names in a phrase structure rule
		Parameters: Slots    = Node-set of slots
					sAllSlotsOptional = contains one 'N' for each required slot (i.e. if it's empty then all slots are optional)
							bPrefix = Flag for if the slots are prefix slots
					sType = 'F' for Full rule, 'P' for Partial rule, or 'S' for Stem rule
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="AffixTemplateSlotsPSR">
	  <xsl:param name="Slots"/>
	  <xsl:param name="sAllSlotsOptional"/>
	  <xsl:param name="bPrefix">Y</xsl:param>
	  <xsl:param name="sType">F</xsl:param>
	  <xsl:for-each select="$Slots">
<!--         <xsl:sort select="@ord"/> now it is just position -->
		 <xsl:text>&#x20;</xsl:text>
		 <xsl:variable name="bOptional">
			<xsl:if test="$sType!='S'">
			   <!-- is a Full rule; use optionality of slot -->
			   <xsl:value-of select="key('SlotsID', @dst)/@Optional"/>
			</xsl:if>
			<xsl:if test="$sType='S'">
			   <!-- is a Stem rule; use optionality of slot only if some slots are required;
	if all slots are optional, treat all slots as required (otherwise this rule is not needed and causes a PC-PATR warning)
 -->
			   <xsl:if test="contains($sAllSlotsOptional,'N')">
				  <xsl:value-of select="key('SlotsID', @dst)/@Optional"/>
			   </xsl:if>
			   <xsl:if test="not(contains($sAllSlotsOptional,'N'))">false</xsl:if>
			</xsl:if>
		 </xsl:variable>
		 <xsl:if test="$bOptional='true'">(</xsl:if>
		 <xsl:value-of select="@dst"/>
		 <!-- Need to distinguish between any identical terminal symbols in PATR rule,
		  so are appending an underscore, and the position() value to create a unique value.
  -->
		 <xsl:text>_</xsl:text>
		 <xsl:value-of select="position() - 1"/>
		 <xsl:if test="$bOptional='true'">)</xsl:if>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ConstrainNestedCategories
	routine to output category constraints (especially to handle nested POS)
		Parameters: sOtherNode = string of non-Stem, non-Full node
							 sStemOrFull = string of Stem or Full
							 sCat = category feature attribute name
							 sSecondNode = string of node to use as second when have two nodes to check
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="ConstrainNestedCategories">
	  <xsl:param name="sOtherNode">derivPfx</xsl:param>
	  <xsl:param name="sStemOrFull">Stem_2</xsl:param>
	  <xsl:param name="sCat">fromCat</xsl:param>
	  <xsl:param name="sSecondNode"/>
	  <xsl:text>
		&lt;</xsl:text>
	  <xsl:value-of select="$sStemOrFull"/>
	  <xsl:text> synCat&gt;           = &lt;</xsl:text>
	  <xsl:value-of select="$sOtherNode"/>
	  <xsl:text>&#x20;</xsl:text>
	  <xsl:value-of select="$sCat"/>
	  <xsl:text>&gt;</xsl:text>
	  <xsl:if test="$sStemOrFull!='Prefixes_2' and $sStemOrFull!='Suffixes_2'">
		 <xsl:text>
		&lt;</xsl:text>
		 <xsl:value-of select="$sStemOrFull"/>
		 <xsl:text> synCat&gt;           = &lt;</xsl:text>
		 <xsl:value-of select="$sOtherNode"/>
		 <xsl:text> envCat&gt;</xsl:text>
	  </xsl:if>
	  <xsl:if test="$sSecondNode">
		 <xsl:text>
		&lt;</xsl:text>
		 <xsl:value-of select="$sStemOrFull"/>
		 <xsl:text> synCat&gt;           = &lt;</xsl:text>
		 <xsl:value-of select="$sSecondNode"/>
		 <xsl:text>&#x20;</xsl:text>
		 <xsl:value-of select="$sCat"/>
		 <xsl:text>&gt;</xsl:text>
		 <xsl:text>
		&lt;</xsl:text>
		 <xsl:value-of select="$sStemOrFull"/>
		 <xsl:text> synCat&gt;           = &lt;</xsl:text>
		 <xsl:value-of select="$sSecondNode"/>
		 <xsl:text> envCat&gt;</xsl:text>
	  </xsl:if>
	  <xsl:for-each select="$PartsOfSpeech[SubPossibilities]">
		 <xsl:text>
		/
		&lt;</xsl:text>
		 <xsl:value-of select="$sOtherNode"/>
		 <xsl:text>&#x20;</xsl:text>
		 <xsl:value-of select="$sCat"/>
		 <xsl:text>&gt;        = </xsl:text>
		 <xsl:value-of select="@Id"/>
		 <xsl:if test="$sStemOrFull!='Prefixes_2' and $sStemOrFull!='Suffixes_2'">
			<xsl:text>
		&lt;</xsl:text>
			<xsl:value-of select="$sOtherNode"/>
			<xsl:text> envCat&gt;         = </xsl:text>
			<xsl:value-of select="@Id"/>
		 </xsl:if>
		 <xsl:if test="$sSecondNode">
			<xsl:text>
		&lt;</xsl:text>
			<xsl:value-of select="$sSecondNode"/>
			<xsl:text>&#x20;</xsl:text>
			<xsl:value-of select="$sCat"/>
			<xsl:text>&gt;        = </xsl:text>
			<xsl:value-of select="@Id"/>
			<xsl:text>
		&lt;</xsl:text>
			<xsl:value-of select="$sSecondNode"/>
			<xsl:text> envCat&gt;         = </xsl:text>
			<xsl:value-of select="@Id"/>
		 </xsl:if>
{
	  <xsl:text>
		&lt;</xsl:text>
		 <xsl:value-of select="$sStemOrFull"/>
		 <xsl:text> synCat&gt;           = </xsl:text>
		 <xsl:value-of select="@Id"/>
		 <xsl:call-template name="NestedPOSids">
			<xsl:with-param name="pos" select="@Id"/>
			<xsl:with-param name="sType">DerivAffix</xsl:with-param>
			<xsl:with-param name="sStemOrFull">
			   <xsl:value-of select="$sStemOrFull"/>
			</xsl:with-param>
		 </xsl:call-template>
		 <xsl:text>
}
</xsl:text>
	  </xsl:for-each>
   </xsl:template>
	<!--
		- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		GetDerivPOSId
		get top level POS Id for a derivaitonal MSA mapping
		Parameters: posid = the Id of one part of the mapping
		- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	-->
	<xsl:template name="GetDerivPOSId">
		<xsl:param name="posid"/>
		<xsl:choose>
			<xsl:when test="$posid=0">
				<xsl:text>0</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="GetTopLevelPOSId">
					<xsl:with-param name="pos" select="key('POSID',$posid)"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
GetOtherExceptionFeaturesAsDefault
	get any other exception features and set them to default minus
		Parameters: ExceptionFeatures = set of exception features
							 thisEF = Id of exception feature to not create a default for
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="GetOtherExceptionFeaturesAsDefault">
	  <xsl:param name="ExceptionFeatures"/>
	  <xsl:param name="thisEF"/>
	  <xsl:for-each select="$ExceptionFeatures[@Id!=$thisEF]">
		 <xsl:value-of select="@Id"/>:!- </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
GetPOSFeatures
	get any features associated with this and all super PartOfSpeech elements (i.e.
	those that have a SubPossibilities element that refers to this PartOfSpeech)
		Parameters: pos = current PartOfSpeech
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="GetPOSFeatures">
	  <xsl:param name="pos"/>
	  <xsl:call-template name="SuperPOSGetDefaultFeatures">
		 <xsl:with-param name="pos" select="$pos"/>
	  </xsl:call-template>
	  <xsl:variable name="sHasInflTemplate">
		 <xsl:call-template name="SuperPOSHasTemplate">
			<xsl:with-param name="pos" select="$pos"/>
		 </xsl:call-template>
	  </xsl:variable>
	  <xsl:text>
	requiresInflection : </xsl:text>
	  <xsl:choose>
		 <xsl:when test="$sHasInflTemplate='Y'">
			<xsl:text>+</xsl:text>
		 </xsl:when>
		 <xsl:otherwise>
			<xsl:text>-</xsl:text>
		 </xsl:otherwise>
	  </xsl:choose>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NestedPOSids
	Perform a recursive pass through nested PartOfSpeech elements
		Parameters: pos = key for current PartOfSpeech
						 sType = flag for whether it's for
						'Full'	a Full production
						'Stem_1'	a Full production, but for a non-final inflectional template
						'Partial'	a Partial production
						'Label'	PartOfSpeech label only (as of 2003.08.13, no longer used)
						'DerivAffix'	DerivationalAffix
						'CompoundStem2' Left member of a compound
						'CompoundStem3' Right member of a compound
						'envCat' part of a POS template
						'fromCat' part of a POS template
						'toCat' part of a POS template
						 bIsConstraint = flag for whether it's for a constraint or not
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <!-- recursive pass through POS -->
   <xsl:template name="NestedPOSids">
	  <xsl:param name="pos" select="."/>
	  <xsl:param name="sType"/>
	  <xsl:param name="sStemOrFull">Stem_2</xsl:param>
	  <xsl:param name="bIsConstraint">Y</xsl:param>
	  <xsl:for-each select="key('POSID',$pos)/SubPossibilities">
		 <xsl:if test="$bIsConstraint='Y'">
			<xsl:text> /</xsl:text>
		 </xsl:if>
		 <xsl:choose>
			<xsl:when test="$sType='Full'">
  &lt;Stem  synCat&gt;       =  <xsl:value-of select="@dst"/>
			</xsl:when>
			<xsl:when test="$sType='Stem_1'">
  &lt;Stem_1  synCat&gt;       =  <xsl:value-of select="@dst"/>
			</xsl:when>
			<xsl:when test="$sType='Partial'">
				  &lt;Partial_2 synCat&gt;       =  <xsl:value-of select="@dst"/>
			</xsl:when>
			<xsl:when test="$sType='Label'">
			   <xsl:text>&#x20;</xsl:text>
			   <xsl:value-of select="@dst"/>
			</xsl:when>
			<xsl:when test="$sType='DerivAffix' or $sType='CompoundStem2'">
			   <!-- habby try was: @#@
				<xsl:when test="$sType='CompoundStem2'"> -->
			   <xsl:text>
		&lt;</xsl:text>
			   <xsl:value-of select="$sStemOrFull"/>
			   <xsl:text> synCat&gt;           = </xsl:text>
			   <xsl:value-of select="@dst"/>
			</xsl:when>
			<xsl:when test="$sType='CompoundStem3'">
			   <xsl:text>
		&lt;Stem_3 synCat&gt;           = </xsl:text>
			   <xsl:value-of select="@dst"/>
			</xsl:when>
			<xsl:when test="$sType='fromCat' or $sType='envCat'">
			   <xsl:text>[</xsl:text>
			   <xsl:value-of select="$sType"/>
			   <xsl:text>:</xsl:text>
			   <xsl:value-of select="@dst"/>
			   <xsl:text>]</xsl:text>
			</xsl:when>
			<xsl:when test="$sType='toCat'">
			   <xsl:text>[</xsl:text>
			   <xsl:value-of select="$sType"/>
			   <xsl:text>:</xsl:text>
			   <xsl:value-of select="@dst"/>
			   <xsl:call-template name="GetPOSFeatures">
				  <xsl:with-param name="pos" select="@dst"/>
			   </xsl:call-template>
			   <xsl:text>]</xsl:text>
			</xsl:when>
			<xsl:when test="$sType='rootCat'">
			   <xsl:text>[</xsl:text>
			   <xsl:value-of select="$sType"/>
			   <xsl:text>:</xsl:text>
			   <xsl:value-of select="@dst"/>
			   <xsl:text>]</xsl:text>
			</xsl:when>
		 </xsl:choose>
		 <xsl:call-template name="NestedPOSids">
			<xsl:with-param name="pos" select="@dst"/>
			<xsl:with-param name="sType" select="$sType"/>
			<xsl:with-param name="sStemOrFull" select="$sStemOrFull"/>
			<xsl:with-param name="bIsConstraint" select="$bIsConstraint"/>
		 </xsl:call-template>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputCompoundRuleFeatureMatch
	Routine to output a logical constraint for a stem in a compound rule which must match features
		Parameters: sStem = Stem_ appendix
							 features = features to match
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputCompoundRuleFeatureMatch">
	  <xsl:param name="sStem"/>
	  <xsl:param name="features"/>
	  <xsl:text>
		&lt;Stem_</xsl:text>
	  <xsl:value-of select="$sStem"/>
	  <xsl:text>&gt; == [exception :[</xsl:text>
	  <xsl:for-each select="$features/*">
		 <xsl:value-of select="@Feature"/>
		 <xsl:text>:+ </xsl:text>
	  </xsl:for-each>
	  <xsl:text>]]</xsl:text>
   </xsl:template>
   <!--
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	  OutputElsewhereLogicalConstraintsForAllosNotConditionedByFeaturesInLexicalEntries
	  Output logical constraint statements for "not" stem names used in lexical entries
	  Parameters: sList = list of strings to look at
	  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   -->
   <xsl:template name="OutputElsewhereLogicalConstraintsForAllosNotConditionedByFeaturesInLexicalEntries">
	  <xsl:param name="sList"/>
	  <xsl:variable name="sFirst" select="substring-before($sList,' ')"/>
	  <xsl:variable name="sRest" select="substring-after($sList,' ')"/>
	  <xsl:if test="string-length($sFirst) &gt; 0">
		 <xsl:text>
			&amp; ( ([name</xsl:text>
		 <xsl:value-of select="$sFirst"/>
		  <xsl:text>:</xsl:text>
		  <xsl:value-of select="$sFirst"/>
		  <xsl:text>] -&gt; ~(</xsl:text>
		 <!-- @#@ -->
		 <xsl:call-template name="OutputMultipleStemNameRegions">
			<xsl:with-param name="sStemNames" select="$sFirst"/>
		 </xsl:call-template>
		 <xsl:text>))</xsl:text>
	  </xsl:if>
	  <xsl:if test="$sRest">
		 <xsl:call-template name="OutputElsewhereLogicalConstraintsForAllosNotConditionedByFeaturesInLexicalEntries">
			<xsl:with-param name="sList" select="$sRest"/>
		 </xsl:call-template>
	  </xsl:if>
	  <xsl:text>)</xsl:text>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputElsewhereLogicalConstraintsForStemNamesUsedInLexicalEntries
	Output logical constraint statements for "not" stem names used in lexical entries
		Parameters: sList = list of strings to look at
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputElsewhereLogicalConstraintsForStemNamesUsedInLexicalEntries">
	  <xsl:param name="sList"/>
	  <xsl:param name="origPosID"/>
	  <xsl:variable name="sFirst" select="substring-before($sList,' ')"/>
	  <xsl:variable name="sRest" select="substring-after($sList,' ')"/>
	  <xsl:if test="string-length($sFirst) &gt; 0">
		 <xsl:variable name="bStemNameRelevantToPOS">
			<xsl:call-template name="StemNamesRelevantToPOS">
			   <xsl:with-param name="sStemNames" select="$sFirst"/>
			   <xsl:with-param name="origPosID" select="$origPosID"/>
			</xsl:call-template>
		 </xsl:variable>
		 <xsl:if test="contains($bStemNameRelevantToPOS,'Y')">
			<xsl:text>
			&amp; ( ([stemName:</xsl:text>
			<xsl:value-of select="$sFirst"/>
			<xsl:text>] -> ~(</xsl:text>
			<!-- @#@ -->
			<xsl:call-template name="OutputMultipleStemNameRegions">
			   <xsl:with-param name="sStemNames" select="$sFirst"/>
			</xsl:call-template>
			<xsl:text>))</xsl:text>
		 </xsl:if>
		 <xsl:if test="$sRest">
			<xsl:call-template name="OutputElsewhereLogicalConstraintsForStemNamesUsedInLexicalEntries">
			   <xsl:with-param name="sList" select="$sRest"/>
			   <xsl:with-param name="origPosID" select="$origPosID"/>
			</xsl:call-template>
		 </xsl:if>
		 <xsl:if test="contains($bStemNameRelevantToPOS,'Y')">
			<!-- close off paren -->
			<xsl:text>)</xsl:text>
		 </xsl:if>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputFS
	Routine to output a feature structure
		Parameters: sTemplateName = name of PC-PATR template
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputFS">
	  <xsl:param name="sTemplateName"/>
	  <xsl:param name="sMorphoSyntaxName">
		 <xsl:text>morphoSyntax</xsl:text>
	  </xsl:param>
Let <xsl:value-of select="$sTemplateName"/>
	  <xsl:value-of select="@Id"/>
	  <xsl:text> be [ </xsl:text>
	  <xsl:value-of select="$sMorphoSyntaxName"/>
	  <xsl:text> : [</xsl:text>
	  <xsl:call-template name="OutputFsFeatStruc"/>
	  <xsl:text>] ]</xsl:text>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputFsFeatStruc
	Routine to recursively output an FsFeatStruc
		Parameters: none
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputFsFeatStruc">
	  <xsl:for-each select="FsComplexValue">
		 <xsl:value-of select="@Feature"/>
		 <xsl:text> : [</xsl:text>
		 <xsl:for-each select="FsFeatStruc">
			<xsl:call-template name="OutputFsFeatStruc"/>
		 </xsl:for-each>
		 <xsl:text>]</xsl:text>
	  </xsl:for-each>
	  <xsl:for-each select="FsClosedValue">
		 <xsl:text disable-output-escaping="yes">&#x20;</xsl:text>
		 <xsl:value-of select="@Feature"/>:<xsl:value-of select="@Value"/>
	  </xsl:for-each>
   </xsl:template>
	<!--
		- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		OutputLetsForTopLevelCategories
		Output Let statements for top level categories
		Parameters: sList = list of strings to look at
		- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	-->
	<xsl:template name="OutputLetsForTopLevelCategories">
		<xsl:param name="sList"/>
		<xsl:variable name="sFirst" select="substring-before($sList,' ')"/>
		<xsl:variable name="sRest" select="substring-after($sList,' ')"/>
		<xsl:if test="string-length($sFirst) &gt; 0">
			<xsl:text>Let pos</xsl:text>
			<xsl:value-of select="$sFirst"/>
			<xsl:text> be []
Let pos</xsl:text>
			<xsl:value-of select="$sFirst"/>
			<xsl:text>/pos</xsl:text>
			<xsl:value-of select="$sFirst"/>
			<xsl:text> be []
</xsl:text>
			<xsl:if test="$sRest">
				<xsl:call-template name="OutputLetsForTopLevelCategories">
					<xsl:with-param name="sList" select="$sRest"/>
				</xsl:call-template>
			</xsl:if>
		</xsl:if>
	</xsl:template>
	<!--
		- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		OutputLetsForDerivMsas
		Output Let statements for derivational affix category mappings
		Parameters: derivMsa = current derivational MSA
		sExistingMappings = list of mappings already handled
		- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	-->
	<xsl:template name="OutputLetsForDerivMsas">
		<xsl:param name="derivMsa"/>
		<xsl:param name="sExistingMappings"/>
		<xsl:if test="$derivMsa">
			<xsl:variable name="fromPosId">
				<xsl:call-template name="GetDerivPOSId">
					<xsl:with-param name="posid" select="$derivMsa/@FromPartOfSpeech"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="toPosId">
				<xsl:call-template name="GetDerivPOSId">
					<xsl:with-param name="posid" select="$derivMsa/@ToPartOfSpeech"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="thisMapping">
				<xsl:text>|</xsl:text>
				<xsl:value-of select="$fromPosId"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="$toPosId"/>
				<xsl:text>|</xsl:text>
			</xsl:variable>
			<xsl:if test="$fromPosId!=$toPosId and not(contains($sExistingMappings,$thisMapping))">
				<xsl:text>Let pos</xsl:text>
				<xsl:value-of select="$fromPosId"/>
				<xsl:text>/pos</xsl:text>
				<xsl:value-of select="$toPosId"/>
				<xsl:text> be []&#xa;</xsl:text>
			</xsl:if>
			<xsl:variable name="sMappings">
				<xsl:choose>
					<xsl:when test="contains($sExistingMappings,$thisMapping)">
						<xsl:value-of select="$sExistingMappings"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat($sExistingMappings,$thisMapping)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:call-template name="OutputLetsForDerivMsas">
				<xsl:with-param name="derivMsa" select="$derivMsa/following-sibling::MoDerivAffMsa[1]"/>
				<xsl:with-param name="sExistingMappings" select="$sMappings"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>
	<!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputLetsForStemNamesUsedInLexicalEntries
	Output Let statements for "not" stem names used in lexical entries
		Parameters: sList = list of strings to look at
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputLetsForStemNamesUsedInLexicalEntries">
	  <xsl:param name="sList"/>
	  <xsl:variable name="sFirst" select="substring-before($sList,' ')"/>
	  <xsl:variable name="sRest" select="substring-after($sList,' ')"/>
	  <xsl:if test="string-length($sFirst) &gt; 0">
Let <xsl:value-of select="$sFirst"/>
		 <xsl:text> be [stemName:</xsl:text>
		 <xsl:value-of select="$sFirst"/>
		 <xsl:text>]</xsl:text>
		 <xsl:if test="$sRest">
			<xsl:call-template name="OutputLetsForStemNamesUsedInLexicalEntries">
			   <xsl:with-param name="sList" select="$sRest"/>
			</xsl:call-template>
		 </xsl:if>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputMultipleStemNameRegions
	Output feature structures based on a list of stem names
		Parameters: sStemNames = the list of stem names in the form StemNameXStemNameY...StemNameZ
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputMultipleStemNameRegions">
	  <xsl:param name="sStemNames"/>
	  <xsl:param name="bContinue"/>
	  <xsl:variable name="sn1" select="substring-after($sStemNames, 'StemName')"/>
	  <xsl:variable name="sn2" select="substring-before($sn1,'StemName')"/>
	  <xsl:variable name="sn">
		 <xsl:choose>
			<xsl:when test="string-length($sn2) &gt; 0">
			   <xsl:value-of select="$sn2"/>
			</xsl:when>
			<xsl:otherwise>
			   <xsl:value-of select="$sn1"/>
			</xsl:otherwise>
		 </xsl:choose>
	  </xsl:variable>
	  <xsl:for-each select="key('StemNameID',$sn)">
		 <xsl:if test="$bContinue='Y'">
			<xsl:text>/ (</xsl:text>
		 </xsl:if>
		 <xsl:variable name="regions" select="Regions/FsFeatStruc"/>
		 <xsl:choose>
			<xsl:when test="$regions">
			   <xsl:for-each select="$regions">
				  <xsl:if test="position()!=1">
					 <xsl:text> / (</xsl:text>
				  </xsl:if>
				  <xsl:text>[morphoSyntax:[</xsl:text>
				  <xsl:call-template name="OutputFsFeatStruc"/>
				  <xsl:text>]] </xsl:text>
			   </xsl:for-each>
			</xsl:when>
			<xsl:otherwise>
			   <xsl:text>[morphoSyntax:missingRegion]</xsl:text>
			</xsl:otherwise>
		 </xsl:choose>
		 <xsl:if test="string-length($sn2) &gt; 0">
			<xsl:call-template name="OutputMultipleStemNameRegions">
			   <xsl:with-param name="sStemNames" select="substring-after($sStemNames, $sn2)"/>
			   <xsl:with-param name="bContinue" select="'Y'"/>
			</xsl:call-template>
		 </xsl:if>
		 <xsl:if test="$bContinue='Y'">
			<xsl:text>)</xsl:text>
		 </xsl:if>
		 <xsl:for-each select="$regions">
			<xsl:if test="position()!=1">
			   <xsl:text>)</xsl:text>
			</xsl:if>
		 </xsl:for-each>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputRegionFeatureStructures
	Output feature structures in a stem name's regions
		Parameters: none
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputRegionFeatureStructures">
	  <xsl:variable name="regions" select="Regions/FsFeatStruc"/>
	  <xsl:for-each select="$regions">
		 <xsl:if test="position()!=1">
			<xsl:text> / (</xsl:text>
		 </xsl:if>
		 <xsl:text>[morphoSyntax:[</xsl:text>
		 <xsl:call-template name="OutputFsFeatStruc"/>
		 <xsl:text>]] </xsl:text>
	  </xsl:for-each>
	  <xsl:for-each select="$regions">
		 <xsl:if test="position()!=1">
			<xsl:text>)</xsl:text>
		 </xsl:if>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
OutputUniqueStrings
	Routine to output a list of strings, only using those strings which are unique
		Parameters: sList = list of strings to look at, in determining which are unique
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="OutputUniqueStrings">
	  <xsl:param name="sList"/>
	  <xsl:param name="bDoNewLine"/>
	   <!-- make sure there's a trailing space -->
	   <xsl:variable name="sNewList" select="concat(normalize-space($sList),' ')"/>
	  <xsl:variable name="sFirst" select="substring-before($sNewList,' ')"/>
	  <xsl:variable name="sRest" select="substring-after($sNewList,' ')"/>
	   <!-- need to compare entire string, so when looking, append a space before and after; the rest variable also needs to be sure
		   to have an initial space or we can skip one when it occurs more than once in a row. -->
	   <xsl:if test="not(contains(concat(' ',$sRest),concat(' ',concat($sFirst,' '))))">
		 <xsl:value-of select="translate($sFirst,'&amp;',' ')"/>
		 <xsl:choose>
			<xsl:when test="$bDoNewLine='Y'">
			   <xsl:text>&#x20;
</xsl:text>
			</xsl:when>
			<xsl:otherwise>
			   <xsl:text>&#x20;</xsl:text>
			</xsl:otherwise>
		 </xsl:choose>
	  </xsl:if>
	  <xsl:if test="$sRest">
		 <xsl:call-template name="OutputUniqueStrings">
			<xsl:with-param name="sList" select="$sRest"/>
			<xsl:with-param name="bDoNewLine" select="$bDoNewLine"/>
		 </xsl:call-template>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
POSorParentHasStemNames
	Output a 'Y' if this or a parent POS has StemNames
		Parameters: posID = ID of current PartOfSpeech
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="POSorParentHasStemNames">
	  <xsl:param name="posID"/>
	  <xsl:variable name="stemNames" select="key('POSID', $posID)/StemNames/MoStemName[descendant::FsClosedValue]"/>
	  <xsl:choose>
		 <xsl:when test="$stemNames">
			<xsl:text>Y</xsl:text>
		 </xsl:when>
		 <xsl:otherwise>
			<!-- now check parent POS -->
			<xsl:for-each select="$PartsOfSpeech/SubPossibilities[@dst=$posID]">
			   <xsl:call-template name="POSorParentHasStemNames">
				  <xsl:with-param name="posID" select="../@Id"/>
			   </xsl:call-template>
			</xsl:for-each>
		 </xsl:otherwise>
	  </xsl:choose>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
StemNameDefaultLogicalConstraint
	if needed, build logical constraint based on stem names
		Parameters: posID = ID of current PartOfSpeech
							 bDoAmp = flag for whether need ampersand or not
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="StemNameDefaultLogicalConstraint">
	  <xsl:param name="posID"/>
	  <xsl:param name="bContinues"/>
	  <xsl:variable name="stemNames" select="key('POSID', $posID)/StemNames/MoStemName[descendant::FsClosedValue]"/>
	  <xsl:variable name="iCount" select="count($stemNames)"/>
	  <xsl:for-each select="$stemNames">
		 <xsl:if test="$bContinues!='Y' and position()=1">
			<xsl:text>
			&amp; ( ([stemName:default] -> ~(</xsl:text>
		 </xsl:if>
		 <xsl:if test="position()!=1 or $bContinues='Y'">
			<xsl:text>
				 / </xsl:text>
		 </xsl:if>
		 <xsl:for-each select="Regions/FsFeatStruc">
			<xsl:if test="position()!=1">
			   <xsl:text>/ </xsl:text>
			</xsl:if>
			<xsl:text>[morphoSyntax:[</xsl:text>
			<xsl:call-template name="OutputFsFeatStruc"/>
		 </xsl:for-each>
		 <xsl:text>]]</xsl:text>
	  </xsl:for-each>
	  <!-- now check parent POS -->
	  <xsl:for-each select="$PartsOfSpeech/SubPossibilities[@dst=$posID]">
		 <xsl:call-template name="StemNameDefaultLogicalConstraint">
			<xsl:with-param name="posID" select="../@Id"/>
			<xsl:with-param name="bContinues">
			   <xsl:if test="$bContinues='Y' or $iCount &gt; 0">
				  <xsl:text>Y</xsl:text>
			   </xsl:if>
			</xsl:with-param>
		 </xsl:call-template>
	  </xsl:for-each>
	  <xsl:if test="$bContinues!='Y' and $iCount &gt; 0">
		 <xsl:text>)) )</xsl:text>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
StemNameConstraints
	if needed, build stem name contraints
		Parameters: posID = ID of current PartOfSpeech
			leftNT = left non-terminal symbol to use
			rightNT = right non-terminal symbol to use
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="StemNameConstraints">
	  <xsl:param name="posID"/>
	  <xsl:param name="leftNT" select="'Full'"/>
	  <xsl:param name="rightNT" select="'Stem'"/>
	  <xsl:variable name="bPOSorParentHasStemNames">
		 <xsl:call-template name="POSorParentHasStemNames">
			<xsl:with-param name="posID" select="$posID"/>
		 </xsl:call-template>
	  </xsl:variable>
	  <xsl:if test="contains($bPOSorParentHasStemNames, 'Y')">
		 <xsl:text>
  &lt;</xsl:text>
		 <xsl:value-of select="$leftNT"/>
		 <xsl:text> stemNameInfo stemName&gt;       = &lt;</xsl:text>
		 <xsl:value-of select="$rightNT"/>
		 <xsl:text> stemName&gt;
				  | stem name logical constraint
  &lt;</xsl:text>
		 <xsl:value-of select="$leftNT"/>
		 <xsl:text> stemNameInfo&gt; == (
  </xsl:text>
		 <xsl:call-template name="StemNameLogicalConstraint">
			<xsl:with-param name="posID" select="$posID"/>
			<xsl:with-param name="origPosID" select="$posID"/>
		 </xsl:call-template>
		 <!--
			<xsl:call-template name="StemNameDefaultLogicalConstraint">
				<xsl:with-param name="posID" select="$posID"/>
			</xsl:call-template>
			-->
		 <xsl:text>)</xsl:text>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
StemNameLogicalConstraint
	if needed, build logical constraint based on stem names
		Parameters: posID = ID of current PartOfSpeech
							 bContinues = flag for whether are continuing or not
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="StemNameLogicalConstraint">
	  <xsl:param name="posID"/>
	  <xsl:param name="bContinues"/>
	  <xsl:param name="origPosID"/>
	<xsl:variable name="stemNames" select="key('POSID', $posID)/StemNames/MoStemName[descendant::FsClosedValue]"/>
	  <xsl:for-each select="$stemNames">
		 <!-- nested items need to be enclosed in parens -->
		 <xsl:if test="position()!=1 or $bContinues='Y'">
			<xsl:text>
				 &amp; ( </xsl:text>
		 </xsl:if>
		 <xsl:text>([stemName:</xsl:text>
		 <xsl:value-of select="@Id"/>
		 <xsl:text>] -> (</xsl:text>
		 <xsl:call-template name="OutputRegionFeatureStructures"/>
		 <xsl:text>))</xsl:text>
	  </xsl:for-each>
	  <!-- now check parent POS -->
	  <xsl:variable name="parentPOS" select="$PartsOfSpeech/SubPossibilities[@dst=$posID]"/>
	  <xsl:for-each select="$parentPOS">
		 <xsl:call-template name="StemNameLogicalConstraint">
			<xsl:with-param name="posID" select="../@Id"/>
			<xsl:with-param name="bContinues">
			   <xsl:if test="$bContinues='Y' or count($stemNames) &gt; 0">
				  <xsl:text>Y</xsl:text>
			   </xsl:if>
			</xsl:with-param>
			<xsl:with-param name="origPosID" select="$origPosID"/>
		 </xsl:call-template>
	  </xsl:for-each>
	  <!-- do elsewhere cases here, too, so we can more easily control nested parens -->
	  <xsl:if test="not($parentPOS)">
		 <xsl:call-template name="OutputElsewhereLogicalConstraintsForStemNamesUsedInLexicalEntries">
			<xsl:with-param name="sList" select="$sUniqueStemNamesUsedInLexicalEntries"/>
			<xsl:with-param name="origPosID" select="$origPosID"/>
		 </xsl:call-template>
	  </xsl:if>
	  <!-- need to close off nested stem name id -->
	  <xsl:for-each select="$stemNames">
		 <xsl:if test="position()!=1 or $bContinues='Y'">
			<xsl:text>)</xsl:text>
		 </xsl:if>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
StemNameRelevantToPOS
	Determine if the stem name is relevant for this POS or any of its parent POSes
	Output a 'Y' if it is.
		Parameters: stemname = stem name to check
							 pos = current PartOfSpeech
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="StemNameRelevantToPOS">
	  <xsl:param name="stemname"/>
	  <xsl:param name="pos"/>
	  <xsl:choose>
		 <xsl:when test="$pos/StemNames/MoStemName[@Id=$stemname/@Id]">
			<xsl:text>Y</xsl:text>
		 </xsl:when>
		 <xsl:otherwise>
			<!-- this POS did not; check parent POS -->
			<xsl:for-each select="$PartsOfSpeech[SubPossibilities/@dst=$pos/@Id]">
			   <xsl:call-template name="StemNameRelevantToPOS">
				  <xsl:with-param name="stemname" select="$stemname"/>
				  <xsl:with-param name="pos" select="."/>
			   </xsl:call-template>
			</xsl:for-each>
		 </xsl:otherwise>
	  </xsl:choose>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
StemNamesRelevantToPOS
	Output feature structures based on a list of stem names
		Parameters: sStemNames = the list of stem names in the form StemNameXStemNameY...StemNameZ
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="StemNamesRelevantToPOS">
	  <xsl:param name="sStemNames"/>
	  <xsl:param name="origPosID"/>
	  <xsl:variable name="sn1" select="substring-after($sStemNames, 'StemName')"/>
	  <xsl:variable name="sn2" select="substring-before($sn1,'StemName')"/>
	  <xsl:variable name="sn">
		 <xsl:choose>
			<xsl:when test="string-length($sn2) &gt; 0">
			   <xsl:value-of select="$sn2"/>
			</xsl:when>
			<xsl:otherwise>
			   <xsl:value-of select="$sn1"/>
			</xsl:otherwise>
		 </xsl:choose>
	  </xsl:variable>
	  <xsl:for-each select="key('StemNameID',$sn)">
		 <xsl:call-template name="StemNameRelevantToPOS">
			<xsl:with-param name="stemname" select="."/>
			<xsl:with-param name="pos" select="key('POSID',$origPosID)"/>
		 </xsl:call-template>
		 <xsl:if test="string-length($sn2) &gt; 0">
			<xsl:call-template name="StemNamesRelevantToPOS">
			   <xsl:with-param name="sStemNames" select="substring-after($sStemNames, $sn2)"/>
			   <xsl:with-param name="origPosID" select="$origPosID"/>
			</xsl:call-template>
		 </xsl:if>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SuperPOSHasGetDefaultFeatures
	find all Default FeatureValues in this and all super PartOfSpeech elements (i.e.
	those that have a SubPossibilities element that refers to this PartOfSpeech)
		Parameters: pos = current PartOfSpeech
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="SuperPOSGetDefaultFeatures">
	  <xsl:param name="pos"/>
	  <xsl:variable name="CurrentPOS" select="key('POSID',$pos)"/>
	  <xsl:for-each select="$CurrentPOS/DefaultFeatures">
		 <xsl:text>
morphoSyntax : </xsl:text>
		 <xsl:value-of select="key('FSID',@dst)/@PATRTxt"/>
	  </xsl:for-each>
	  <xsl:for-each select="$CurrentPOS/BearableFeatures/BearableFeature">
		 <xsl:if test="position()=1">
			<xsl:text>
	exception : [</xsl:text>
		 </xsl:if>
		 <xsl:value-of select="@dst"/>
		 <xsl:text> : !- </xsl:text>
		 <xsl:if test="position()=last()">]</xsl:if>
	  </xsl:for-each>
	  <!-- Now check for any above. -->
	  <xsl:for-each select="$PartsOfSpeech/SubPossibilities[@dst=$pos]">
		 <xsl:call-template name="SuperPOSGetDefaultFeatures">
			<xsl:with-param name="pos" select="../@Id"/>
		 </xsl:call-template>
	  </xsl:for-each>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SuperPOSHasTemplate
	check for inflectional template in this and all super PartOfSpeech elements (i.e.
	those that have a SubPossibilities element that refers to this PartOfSpeech)
		Parameters: pos = current PartOfSpeech
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="SuperPOSHasTemplate">
	  <xsl:param name="pos"/>
	  <xsl:variable name="CurrentPOS" select="key('POSID',$pos)"/>
	  <!-- if this has a template, we're done.  -->
	  <xsl:if test="$CurrentPOS/AffixTemplates/MoInflAffixTemplate">Y</xsl:if>
	  <xsl:if test="not($CurrentPOS/AffixTemplates/MoInflAffixTemplate)">
		 <!-- Did not have one.  Check for any above. -->
		 <xsl:for-each select="$PartsOfSpeech/SubPossibilities[@dst=$pos]">
			<xsl:call-template name="SuperPOSHasTemplate">
			   <xsl:with-param name="pos" select="../@Id"/>
			</xsl:call-template>
		 </xsl:for-each>
	  </xsl:if>
   </xsl:template>
   <!--
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TemplateWithNestedPOS
	output a PC-PATR template with nested POS values
		Parameters: pos = current PartOfSpeech id
						   sFeature = feature name whose value is the POS id
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-->
   <xsl:template name="TemplateWithNestedPOS">
	  <xsl:param name="pos"/>
	  <xsl:param name="sFeature">fromCat</xsl:param>
	  <xsl:text> be {[</xsl:text>
	  <xsl:value-of select="$sFeature"/>
	  <xsl:text>:</xsl:text>
	  <xsl:value-of select="$pos"/>
	  <xsl:if test="$sFeature='toCat'">
		 <xsl:call-template name="GetPOSFeatures">
			<xsl:with-param name="pos" select="$pos"/>
		 </xsl:call-template>
	  </xsl:if>
	  <xsl:text>]</xsl:text>
	  <xsl:call-template name="NestedPOSids">
		 <xsl:with-param name="pos" select="$pos"/>
		 <xsl:with-param name="sType">
			<xsl:value-of select="$sFeature"/>
		 </xsl:with-param>
		 <xsl:with-param name="bIsConstraint">
			<xsl:text>N</xsl:text>
		 </xsl:with-param>
	  </xsl:call-template>
	  <xsl:text>}</xsl:text>
   </xsl:template>
</xsl:stylesheet>
<!--
================================================================
Revision History
- - - - - - - - - - - - - - - - - - -
03-Aug-2016    Andy Black  Remove non-final verbiage from stock partial rules (they did nothing)
			Allow a partial inflectional template to have all optional slots
27-Mar-2012    Steve McConnel  Tweak for effiency in libxslt based processing.
09-Mar-2006      Andy Black    Handle category hierarchy for unclassified affixes
09-Dec-2005      Andy Black    Undo "use template disjunction for fromPOS, envPOS, and toPOS instead of constraint disjunction" because it was so inefficient
23-Sep-2005	 Andy Black	Revise derivational affixation so the resulting stem defaults to the cat of the original stem and the tocat does priority union
16-Aug-2005	 Andy Black	Allow for inflection features
26-Jul-2005    	 Andy Black	Allow for circumfixes.
07-Jul-2005    	 Andy Black	Allow derivational affixes to override requiresInflection of the stem.
07-Jun-2005	 Andy Black	Handle exception features.
27-Apr-2005	 Andy Black	Modify to allow an allomorph to belong to more than one inflection class
22-Apr-2005	Andy Black	Modification for MoUnclassifiedAffixMsa - final pass: use template disjunction for fromPOS, envPOS, and toPOS instead of constraint disjunction
21-Apr-2005	Andy Black	Modification for MoUnclassifiedAffixMsa - initial pass
07-Apr-2005	Andy Black	Make non-final templates with all optional slots output with obligatory slots
							 (doesn't make sense otherwise and causes an infinite loop in PC-PATR)
25-Jan-2005	Andy Black	Stem = root needed to check for overt category
							Allow for partial analyses with non-final templates
							Non-final templates need to percolate infl class and check rhs stem
07-Dec-2004	Andy Black	Allow for interfixes when there are no compound rules.
23-Nov-2004	Andy Black	Allow for a stem without a POS.  Streamline how to deal with derivation outside inflection.
05-Mar-2004	Andy Black	Do not output template if there are no prefix or suffix slots
						Do not use Slots element, but rather use PrefixSlots and SuffixSlots since we may not be using Slots
						Allow Derivation outside of Inflection
12-Nov-2003	Andy Black	Modify for FXT output via DistFiles\WW\FXTs\M3Paser.fxt
02-Oct-2003		Andy Black	Add linker in compound rules
13-Aug-2003	Andy Black	Re-work stem daughter POS constraints to be one path per disjunction (what it had did not work)
							Also use <xsl:choose> instead of several <xsl:if>s in a few places
12-Aug-2003	Andy Black	Exocentric compound rules were missing To POS and To Inflection class.
12-Aug-2003	Andy Black	Have derivational affixes use priority union to set inflectionClass; default is the
							inflection class of the daughter stem.
29-Jul-2003	Andy Black	Have derivational affixes (via ToPOSxxx) include appropriate requiresInflection values.
							Compound rules also need to percolate approprieate requiresInflection and inflected values
							Compound rules also need to percolate inflectionClass info; still need to handle infl Class for Exocentric compound
10-Jul-2003	Andy Black	Make changes per model changes
03-Dec-2002      Andy Black  Change Msi to Msa
11-Feb-2002	Andy Black	Fix derivational affix nested POS rules so PC-PATR behaves properly
08-Feb-2002	Andy Black	Modify for "flat" form of xml
05-Feb-2002	Andy Black	Modify to handle recursive POS in derivational affix rules
02-Feb-2002	Andy Black	Modify to handle new compound rule design
15-Jan-2002	Andy Black	Add priority union constraint to Stem = root rule.
							Rework template optional slots in templates to be aware of whether it is for a
								Full or a Partial rule.
14-Jan-2002	Andy Black	Fix template slot names to use just the id, an underscore and @ord value.
							Fix a typo "morphosyntax" s/b "morphoSyntax" in SuperPOSGetInherentFeatures().
04-Jan-2002	Andy Black	Add feature structure processing.
							Finish changing  3.2.1.4 "Inflectional Affixes belonging to more than one slot"
							If all slots are optional in a template, treat them as if they were all required (this keeps
								PC-PATR from giving an error).  Note that this is not the complete solution.
14-Dec-2001	Andy Black	Modify to apply to XML output from M3ParserSvr which
								has been passed through CleanFWDump.xslt
							(Still have FS stuff to do)
13-Sep-2001	Andy Black	Now handles entire feature system (although I'm not sure FS disjunctions are being
								mapped rightly)
12-Sep-2001	Andy Black	Now handles open, closed, and complex feature structures.
07-Sep-2001	Andy Black	Rework to handle fuller feature structure system and definitions.  Only handles closed
								feature/values.
03-May-2001	Andy Black	Reworked section 3.2.1.4
01-May-2001	Andy Black	Added constraints to avoid getting double inflection on partials.
							Added NestedPOSids() to recurse through POSs in inflectional templates
26-Apr-2001	Andy Black	Initial Draft
================================================================
-->
