# FieldWorks Test Modernization & Lib/C++ Paths

## Repository Baseline
- Build orchestration: `FieldWorks.proj` traversal drives `Build/FieldWorks.targets`, which wires every `*Tests.csproj` through `<NUnit3>` tasks using `NUnit.ConsoleRunner.3.12.0` plus custom XML + optional dotCover output.
- Shared test dependencies: `Directory.Build.props` injects `Microsoft.NET.Test.Sdk`, `NUnit3TestAdapter`, and related settings. One notable exception is `Lib/src/ScrChecks/ScrChecksTests/ScrChecksTests.csproj`, which pins its own package versions.
- Native layer: `Lib/src/unit++/VS/unit++.vcxproj` builds the bundled unit++ static library leveraged by native suites (e.g., `Src/views/Test/TestViews`). Native tests currently lack automated MSBuild targets and produce no machine-readable result artifacts. Supporting assets (like `Lib/src/graphite2/TestFonts`) are purely manual fixtures.

## Managed Test Modernization Options

| Path                                         | Scope & Required Work                                                                                                                                                                                      | Fit With Modern Tooling                                                          | Advantages                                                                                                         | Risks / Unknowns                                                                                                                                                                 |
| -------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **A. Status Quo (NUnit console)**            | Keep existing `<NUnit3>` targets; periodically bump console runner + adapters; add XMLâ†’TRX converters if richer reporting is needed.                                                                       | Works everywhere today but relies on legacy runner.                              | Zero churn, no project file edits, predictable CI behavior.                                                        | Diverges from mainstream `.NET` tooling; requires bespoke maintenance for console runner packaging and coverage adapters.                                                        |
| **B. MSBuild wrapper over `vstest.console`** | Replace `<NUnit3>` tasks with `<Exec>` or custom task calling `vstest.console` per assembly while retaining traversal ordering, timeout plumbing, coverage triggers, and category filters.                 | Aligns with Visual Studio Test Explorer, Azure DevOps, GitHub Actions, Coverlet. | Decouples from NUnit console, keeps MSBuild phases, enables native TRX output.                                     | Needs translation of existing timeout/category props; still runs assemblies serially so total duration unchanged.                                                                |
| **C. Full `.dotnet test` adoption**          | Provide solution filters or props so `dotnet test FieldWorks.sln` can run after native prerequisites build. Remove console-runner assumptions from csproj files, ensure repo-wide props remain compatible. | Native fit for modern CLI/IDE workflows.                                         | Parallel discovery, data collectors, and live test explorer work out of the box; simpler container/CI integration. | Largest scope: must redesign traversal `/p:action=test`, ensure native generations (ViewsInterfaces) finish before `dotnet test`, provide guidance for developers on sequencing. |
| **D. Consolidated test host(s)**             | Build custom host binaries that load multiple assemblies to reduce process spin-up, then invoke host via MSBuild/dotnet.                                                                                   | Custom approach; can sit atop vstest/dotnet.                                     | Improves throughput dramatically, centralizes logging.                                                             | Extra engineering overhead, non-standard debugging, needs design for fixture lifecycle + isolation.                                                                              |

**Recommended arc:** implement Path **B** first to break dependence on NUnit console while retaining traversal gating, then introduce Path **C** entrypoints (per solution slice or full repo) once parity is proven. Treat `ScrChecksTests` as a pilot project by moving its package references back into shared props and ensuring it succeeds under `vstest.console`.

## Lib / Native Test Options

| Path                                            | Scope & Required Work                                                                                                                                                                                                                              | Toolchain Compatibility                                                                              | Advantages                                                                                                       | Risks / Unknowns                                                                                                                                  |
| ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Formalize current unit++ harness**         | Keep unit++ sources; add MSBuild or CMake targets that compile & execute all native test binaries, emitting TRX/JUnit XML (custom reporters). Wire traversal native phase (e.g., `Build/Src/NativeBuild/NativeBuild.csproj`) to invoke the runner. | Minimal dependencies; works with existing MSBuild environments.                                      | Fastest path to automated native coverage; no rewrites of existing tests.                                        | unit++ is largely unmaintained; lacks IDE integration; would need bespoke result adapters and debugging is clunky.                                |
| **2. Port suites to GoogleTest (or Catch2)**    | Migrate unit++ macros/tests to a supported framework, adding it via vcpkg or vendored source. Update native projects to consume new framework and emit standard XML reports.                                                                       | Excellent IDE/CI support; integrates cleanly with CMake/MSBuild/VSTest.                              | Long-term maintainability, wide community support, easy TRX/JUnit output, debugger-aware assertions.             | Mechanical rewrite required; need plan for incremental conversion per suite; must manage new dependency across agents/containers.                 |
| **3. Bridge native tests into managed runners** | Wrap native functionality in C++/CLI or COM shims so NUnit/VSTest can call into them, allowing native verification to piggyback on managed infrastructure.                                                                                         | Leverages existing managed tooling; no separate native runner needed.                                | Produces unified reports and gating; easier to enforce sequencing (managed tests already run late in traversal). | Hard to debug; risk of masking native lifecycle issues; requires meticulous init/teardown boundaries.                                             |
| **4. Add CMake/CTest-only lane**                | Introduce a secondary build under `Lib/src` that uses upstream CMake (Graphite2 already ships one) strictly for testing, while MSBuild still produces shipping binaries. CI runs both MSBuild (product) and CMake (tests).                         | Unlocks modern tooling (CLion, Ninja, CTest dashboards) without disturbing existing MSBuild outputs. | Allows gradual adoption, encourages upstream sync for third-party libs, opens door to Linux/macOS validation.    | Dual build systems to maintain; needs Docker/agent prep for CMake; still must handle dependencies on generated artifacts (ViewsInterfaces, etc.). |

**Additional considerations**
- `Lib/src/ScrChecks/ScrChecksTests` already lives as an SDK-style csproj and can become the exemplar for test configuration once managed modernization advances.
- Graphite fixtures (`Lib/src/graphite2/TestFonts`) are currently only consumed manually; adding scripted rendering comparisons (e.g., via FreeType) fits naturally into Paths 2 or 4.
- unit++ conversion paths should account for `Lib/debug`/`Lib/release` outputs referenced by other projects; ensuring ABI parity is critical if the framework library itself ships.

## Suggested Roadmap

1. **Short-term (weeks):**
   - Prototype Path **B** by swapping one `<NUnit3>` target (e.g., `FwControlsTests`) to `vstest.console` behind a feature flag; compare TRX output and duration.
   - Create a native `UnitTests` MSBuild target that builds and runs the existing unit++ binaries, capturing stdout/stderr as CI artifacts (Path **1** bootstrap).

2. **Medium-term (quarter):**
   - Roll `vstest.console` wrapping across the entire traversal, documenting opt-in `dotnet test` commands for developers.
   - Decide between Paths **1** and **2** for native coverage. If porting to GoogleTest, start with `Src/views/Test/TestViews` as pilot, ensuring dependency packaging works inside Docker agents.

3. **Long-term:**
   - Enable full `.dotnet test` runs for at least one slice (e.g., `Src/Common`), using traversal only when native prerequisites change.
   - Explore Path **4** (CMake lane) for third-party libs like Graphite2 and xmlparse to reduce divergence from upstream while improving test reliability.
   - Investigate unified reporting (TRX/SARIF) that merges managed and native runs for CI dashboards and gating.
